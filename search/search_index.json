{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kernpy documentation","text":"<p><code>kernpy</code> is a python package that provides utilities for working with kern and mens data. </p>"},{"location":"#useful-links","title":"Useful links:","text":"<p>Installation | Source Repository | Project Website (PRAIG)</p>"},{"location":"#contents","title":"Contents","text":"<ol> <li>Get started</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> <li>About</li> </ol> <p>Quickly find what you are looking for depending on your use case by looking at the different pages.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>University of Alicante. </p>"},{"location":"about/","title":"Who are we?","text":"<p>We are a research group affiliated with the University of Alicante. </p> <p>To learn more about our work, please visit our website.</p>"},{"location":"explanation/","title":"Explanations","text":"<p>Soon!</p>"},{"location":"get-started/","title":"Overview of the get started guide","text":"<p>Learn how to use <code>kernpy</code>. </p> <ul> <li>Installation</li> <li>Quick Start</li> </ul>"},{"location":"how-to-guides/","title":"Guides: learn what you can do with <code>kernpy</code>","text":"<p>This section contains a series of guides that will help you get started with <code>kernpy</code> and learn how to use it to perform different tasks.</p> <ul> <li>Get started</li> </ul>"},{"location":"reference/","title":"API Reference","text":""},{"location":"reference/#modules","title":"Modules","text":"<p>kernpy.core</p> <p>=====</p> <p>This module contains the core functionality of the <code>kernpy</code> package.</p> <p>kernpy.util</p> <p>=====</p> <p>This module contains utility functions for the kernpy package.</p> <p>polish_scores</p> <p>====</p> <p>This module provides a way to download and process the Polish Scores dataset.</p>"},{"location":"reference/#kernpy--kernpy","title":"kernpy","text":"<p>=====</p> <p>Python Humdrum kern and mens utilities package.</p> <p>Execute the following command to run kernpy as a module:</p> <pre><code>python -m kernpy --help\npython -m kernpy &lt;command&gt; &lt;options&gt;\n</code></pre> <p>Run <code>kernpy</code> from your script:</p> <pre><code>import kernpy\n\nhelp(kernpy)\n</code></pre> <p>While the package is not published in <code>pip</code>, the <code>kernpy</code> module must be in the root directory.</p>"},{"location":"reference/#kernpy--kern2ekern-convertir-un-solo-archivo-krn-a-ekern","title":"\ud83c\udfaf kern2ekern: Convertir un solo archivo .krn a .ekern:","text":"<pre><code>python -m kernpy --kern2ekern --input_path &lt;input_file&gt;  &lt;v | --verbose [0-2]&gt;\n</code></pre> <p>The command has the following arguments: * input_path: Ruta del archivo .krn a convertir. * output_path: Ruta del archivo .ekern a generar (opcional). Si no se especifica, se generar\u00e1 en la misma ubicaci\u00f3n. * -r: Recursivo (opcional). * --verbose[0-2]: Nivel de verbosidad (opcional).</p> <p>\ud83d\udccc Basic usage running kernpy as a module:</p> <pre><code>python -m kernpy --input_path /my/path/to/file.krn # New ekern generated in /my/path/to/file.ekern\n</code></pre> <p>\ud83d\udccc Generate an ekrn file in specific location running kernpy as a module:</p> <pre><code>python -m kernpy --input_path /my/path/to/file.krn --output_path /new/output.ekern\n</code></pre> <p>\ud83d\udccc Converting all the .krn files in a directory to .ekern files running kernpy as a module: * Every .krn file in the directory will be converted to .ekern in the same location. * Using, at least, one additional directory level is required.</p> <pre><code>root\n\u251c\u2500 kern-folder\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2.krn\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 3.krn\n\u251c\u2500\u2500 more-kerns\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n</code></pre> <p>Run:</p> <pre><code>python -m kernpy --input_path /my/path/to/directory/ -r\n</code></pre> <p>\u270f\ufe0f This function is also available as a python function:</p> <pre><code># converter.py\nfrom kernpy import kern_to_ekern\n\nkern_to_ekern('/my/path/to/input.krn', '/to/my/output.ekrn')\n\n# Many files\nfiles = ['file1.krn', 'file2.krn', 'file3.krn']\n[kern_to_ekern(f) for f in files]\n\n# This function raises an exception if the conversion fails.\n# Handle the errors using try-except statement if many files are going to be converted in series.\n</code></pre>"},{"location":"reference/#kernpy--ekern2kern-convertir-un-solo-archivo-ekern-a-krn","title":"\ud83c\udfaf ekern2kern: Convertir un solo archivo .ekern a .krn:","text":"<pre><code>python -m kernpy --ekern2kern --input_path &lt;input_file&gt;  &lt;--verbose [0-2]&gt;\n</code></pre> <p>The command has the following arguments: * input_path: Ruta del archivo .ekern a convertir. * output_path: Ruta del archivo .krn a generar (opcional). Si no se especifica, se generar\u00e1 en la misma ubicaci\u00f3n. * -r: Recursivo (opcional). * --verbose[0-2]: Nivel de verbosidad (opcional).</p> <ul> <li>Basic usage running kernpy as a module:</li> </ul> <pre><code>python -m kernpy --input_path /my/path/to/file.ekern # New krn generated in /my/path/to/file.krn\n</code></pre> <p>\ud83d\udccc Generate a krn file in specific location running kernpy as a module:</p> <pre><code>python -m kernpy --input_path /my/path/to/file.ekern --output_path /new/output.krn\n</code></pre> <p>\ud83d\udccc Converting all the .ekern files in a directory to .krn files running kernpy as a module:</p> <ul> <li>Every .ekrn file in the directory will be converted to .krn in the same location.</li> <li>Using, at least, one additional directory level is required.</li> </ul> <pre><code>root\n\u251c\u2500 ekern-folder\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.ekrn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2.ekrn\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 3.ekrn\n\u251c\u2500\u2500 more-ekerns\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.ekrn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n</code></pre> <p>Run:</p> <pre><code>python -m kernpy --input_path /my/path/to/directory/ -r\n</code></pre> <p>\u270f\ufe0f This function is also available as a python function:</p> <pre><code># converter.py\nfrom kernpy import ekern_to_krn\n\n# Only one file\nekern_to_krn('/my/path/to/input.ekrn', '/to/my/output.krn')\n\n# Many files\nfiles = ['file1.ekrn', 'file2.ekrn', 'file3.ekrn']\n[ekern_to_krn(f) for f in files]\n\n# This function raises an exception if the conversion fails.\n# Handle the errors using try-except statement if many files are going to be converted in series.\n</code></pre>"},{"location":"reference/#kernpy--create-fragments","title":"\ud83c\udfaf create fragments","text":"<p>Generate new valid kern files from an original kern file. Every new fragment will be a subset of the original file.</p> <p>Explore the documentation website for more information about the parameters.</p> <p>Use: - create_fragments_from_kern to generate using always the same measure length. - create_fragments_from_directory to generate using a Gaussian distribution for the measure length. Static measure is also available if the standard deviation is set to 0.</p> <p>\ud83d\udccc Create new scores from one original kern directory running kernpy as a module:</p> <pre><code>python -m kernpy --generate_fragments --input_directory /from/my/kerns --output_directory /to/my/fragments --log_file log.csv  --verbose 2 --mean 4.2 --std_dev 1.5 --offset 1 --num_processes 12\n</code></pre> <p>\u270f\ufe0f Create new scores from one original kern file:</p> <pre><code># generator.py\nfrom kernpy import create_fragments_from_kern\n\n# View docs:\nhelp(create_fragments_from_kern)\n\ncreate_fragments_from_kern('/my/path/to/input.krn', '/to/my/output_dir/',\n                           measure_length=4, offset=1,\n                           log_file='/dev/null')\n</code></pre> <p>\u270f\ufe0f Create new scores from one original kern directory: - Using, at least, one additional directory level is required.</p> <pre><code>root\n\u251c\u2500 kern-folder\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2.krn\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 3.krn\n\u251c\u2500\u2500 more-kerns\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n</code></pre> <p>Run:</p> <pre><code># generator.py\nfrom kernpy import create_fragments_from_directory\n\n# View docs:\nhelp(create_fragments_from_directory)\n\ncreate_fragments_from_directory('/my/path/to/input_dir/', '/to/my/output_dir/',\n                                mean=4.1, std_dev=0.2, offset=2,\n                                log_file='/logs/fragments.csv',\n                                num_processes=12)\n</code></pre>"},{"location":"reference/#kernpy.core.ExportOptions","title":"<code>ExportOptions</code>","text":"Source code in <code>kernpy/core/import_humdrum.py</code> <pre><code>class ExportOptions:\n    def __init__(self, spine_types=[], token_categories=[], from_measure=None, to_measure=None):\n        \"\"\"\n        :spine_types: **kern, **mens, etc...\n        :token_types: TokenCategory\n        \"\"\"\n        self.spine_types = spine_types\n        self.from_measure = from_measure\n        self.to_measure = to_measure\n        self.token_categories = token_categories\n</code></pre>"},{"location":"reference/#kernpy.core.ExportOptions.__init__","title":"<code>__init__(spine_types=[], token_categories=[], from_measure=None, to_measure=None)</code>","text":"<p>:spine_types: kern, mens, etc... :token_types: TokenCategory</p> Source code in <code>kernpy/core/import_humdrum.py</code> <pre><code>def __init__(self, spine_types=[], token_categories=[], from_measure=None, to_measure=None):\n    \"\"\"\n    :spine_types: **kern, **mens, etc...\n    :token_types: TokenCategory\n    \"\"\"\n    self.spine_types = spine_types\n    self.from_measure = from_measure\n    self.to_measure = to_measure\n    self.token_categories = token_categories\n</code></pre>"},{"location":"reference/#kernpy.core.HumdrumImporter","title":"<code>HumdrumImporter</code>","text":"Source code in <code>kernpy/core/import_humdrum.py</code> <pre><code>class HumdrumImporter:\n    HEADERS = {\"**mens\", \"**kern\", \"**text\", \"**harm\", \"**mxhm\", \"**root\", \"**dyn\", \"**dynam\", \"**fing\"}\n    SPINE_OPERATIONS = {\"*-\", \"*+\", \"*^\", \"*v\"}\n\n    def __init__(self):\n        self.spines = []\n        self.current_spine_index = 0\n        # self.page_start_rows = []\n        self.measure_start_rows = []  # starting from 1. Rows after removing empty lines and line comments\n        self.page_bounding_boxes = {}\n        self.last_measure_number = None\n        self.last_bounding_box = None\n        self.errors = []\n\n    def getMetacomments(self, KeyComment: str = None, clean: bool = True):  # each metacomment is contained in all spines as a reference to the same object\n        \"\"\"\n        Get the metacomments of the file.\n\n        Args:\n            KeyComment: The key of the metacomment. (optional).\\\n                If not specified, all the metacomments will be returned.\n                If specified, all the content of the metacomment with the specified key will be returned.\n            clean: If True, the metacomments will be returned applying a .strip(). Only valid if KeyComment is not None.\n\n        Returns:\n            A list with the metacomments.\\\n                if KeyComment is not None, a list be returned anyway. \\\n                If there are no metacomments with the specified key, an empty list will be returned.\n\n        Example:\n            ```python\n            from kernpy import HumdrumImporter\n            importer = HumdrumImporter()\n\n            # Read the file\n            importer.doImportFile('file.krn')\n\n            # Get all the metacomments\n            all_metacomments = importer.getMetacomments()\n            # ... modify the metacomments using your own logic\n\n            # Get the metacomments with the key: get the composer:\n            composer = importer.getMetacomments(KeyComment='!!!COM')\n\n            # check if your kern file format is compatible with the expected format. If it is not, do not clen it:\n            raw_compose = importer.getMetacomments(KeyComment='!!!COM', clean=False)\n            ```\n\n        \"\"\"\n        result = []\n        for token in self.spines[0].rows:\n            if isinstance(token[0], MetacommentToken):\n                if clean:\n                    result.append(token[0].encoding.strip())\n                else:\n                    result.append(token[0].encoding)\n\n        if KeyComment is not None:\n            clean_rows = [row.replace('!!!', '').replace('!!', '') for row in result]\n            filtered_rows = [row for row in clean_rows if row.startswith(KeyComment)]\n            valid_rows = [row.replace(KeyComment, '').strip()[2:] for row in filtered_rows] if clean else filtered_rows\n            return valid_rows\n\n        return result\n\n    def doImport(self, reader):\n        importers = {}\n        header_row_number = None\n        row_number = 1\n        pending_metacomments = []  # those appearing before the headers\n        for row in reader:\n            for spine in self.spines:\n                self.current_spine_index = 0\n                spine.addRow()\n            if len(row) &gt; 0:  # the last one\n                if row[0].startswith(\"!!\"):\n                    mt = MetacommentToken(row[0])\n                    if len(self.spines) == 0:\n                        pending_metacomments.append(mt)\n                    else:\n                        for spine in self.spines:\n                            spine.addToken(mt)  # the same reference for all spines\n                else:\n                    is_barline = False\n                    for column in row:\n                        if column in self.HEADERS:\n                            if header_row_number is not None and header_row_number != row_number:\n                                raise Exception(\n                                    f\"Several header rows not supported, there is a header row in #{header_row_number} and another in #{row_number} \")\n\n                            header_row_number = row_number\n                            importer = importers.get(column)\n                            if not importer:\n                                importer = createImporter(column)\n                                importers[column] = importer\n                            spine = Spine(column, importer)\n                            for pending_metacomment in pending_metacomments:\n                                spine.addRow()\n                                spine.addToken(pending_metacomment)  # same reference for all spines\n\n                            token = HeaderToken(column)\n                            spine.addRow()\n                            spine.addToken(token)\n                            self.spines.append(spine)\n                        else:\n                            try:\n                                current_spine = self.getNextSpine()\n                                logging.debug(\n                                    f'Row #{row_number}, current spine #{self.current_spine_index} of size {current_spine.importing_subspines}, and importer {current_spine.importer}')\n                            except Exception as e:\n                                raise Exception(\n                                    f'Cannot get next spine at row {row_number}: {e} while reading row {row} ')\n\n                            if column in self.SPINE_OPERATIONS:\n                                current_spine.addToken(SpineOperationToken(column))\n\n                                if column == '*-':\n                                    current_spine.terminate()\n                                elif column == \"*+\" or column == \"*^\":\n                                    current_spine.increaseSubspines()\n                                elif column == \"*v\":\n                                    current_spine.decreaseSubspines()\n                            else:\n                                if column.startswith(\"!\"):\n                                    token = FieldCommentToken(column)\n                                else:\n                                    try:\n                                        token = current_spine.importer.doImport(column)\n                                    except Exception as error:\n                                        token = ErrorToken(column, row_number, error)\n                                        self.errors.append(token)\n                                if not token:\n                                    raise Exception(\n                                        f'No token generated for input {column} in row number #{row_number} using importer {current_spine.importer}')\n                                current_spine.addToken(token)\n                                if token.category == TokenCategory.BARLINES or token.category == TokenCategory.CORE and len(\n                                        self.measure_start_rows) == 0:\n                                    is_barline = True\n                                elif isinstance(token, BoundingBoxToken):\n                                    self.handleBoundingBox(token)\n\n                    if is_barline:\n                        self.measure_start_rows.append(row_number)\n                        self.last_measure_number = len(self.measure_start_rows)\n                        if self.last_bounding_box:\n                            self.last_bounding_box.to_measure = self.last_measure_number\n                row_number = row_number + 1\n\n    def doImportFile(self, file_path: string):\n        with open(file_path, 'r', newline='', encoding='utf-8', errors='ignore') as file:\n            reader = csv.reader(file, delimiter='\\t')\n            self.doImport(reader)\n\n    def doImportString(self, text: string):\n        lines = text.splitlines()\n        reader = csv.reader(lines)\n        self.doImport(reader)\n\n    def getSpine(self, index: int) -&gt; Spine:\n        if index &lt; 0:\n            raise Exception(f'Negative index {index}')\n        elif index &gt;= len(self.spines):\n            raise Exception(f'Index {index} out of bounds for an array of {len(self.spines)} spines')\n        return self.spines[index]\n\n    def getNextSpine(self):\n        spine = self.getSpine(self.current_spine_index)\n        while spine.isFullRow() and self.current_spine_index &lt; (len(self.spines) - 1):\n            self.current_spine_index = self.current_spine_index + 1\n            spine = self.getSpine(self.current_spine_index)\n\n        if self.current_spine_index == len(self.spines):\n            raise Exception('All spines are full, the spine divisions may be wrong')\n\n        return spine\n\n    def doExportNormalizedKern(self, options: ExportOptions) -&gt; string:\n        return self.doExport(KernTypeExporter.normalizedKern, options)\n\n    def doExportEKern(self, options: ExportOptions) -&gt; string:\n        return self.doExport(KernTypeExporter.eKern, options)\n\n    def doExportUnprocessed(self, options: ExportOptions) -&gt; string:\n        return self.doExport(KernTypeExporter.unprocessed, options)\n\n    def handleBoundingBox(self, token: BoundingBoxToken):\n        page_number = token.page_number\n        last_page_bb = self.page_bounding_boxes.get(page_number)\n        if last_page_bb is None:\n            # print(f'Adding {page_number}')\n            if self.last_measure_number is None:\n                self.last_measure_number = 0\n            self.last_bounding_box = BoundingBoxMeasures(token.bounding_box, self.last_measure_number,\n                                                         self.last_measure_number)\n            self.page_bounding_boxes[page_number] = self.last_bounding_box\n        else:\n            # print(f'Extending page {page_number}')\n            last_page_bb.bounding_box.extend(token.bounding_box)\n            last_page_bb.to_measure = self.last_measure_number\n\n    def getMaxRows(self):\n        return max(spine.size() for spine in self.spines)\n\n    def checkMeasure(self, measure_number):\n        if measure_number &lt; 1:\n            raise Exception(f'The measure number must be &gt;=1, and it is {measure_number}')\n\n        max_measures = len(self.measure_start_rows)\n        if measure_number &gt; max_measures:\n            raise Exception(f'The measure number must be &lt;= {max_measures}, and it is {measure_number}')\n\n    def doExport(self, kern_type: KernTypeExporter, options: ExportOptions) -&gt; string:\n        max_rows = self.getMaxRows()\n        signatures_at_each_row = []\n        row_contents = []\n\n        # patch to correct when user uses 0 instead of None to set the first measure as 1\n        if options.from_measure == 0:\n            options.from_measure = 1\n        # TODO: David: Hay que valorar si lanzar una excepci\u00f3n si from_measure o to_measure no es v\u00e1lido. A veces se genera la partitura entera cuando no deber\u00eda. Alternativa abajo\n        #if options.from_measure is None or options.from_measure &lt; 1:\n        #    raise Exception(f'option from_measure must be &gt;=1 but {options.from_measure} was found. ')\n\n        last_signature = None\n        for i in range(max_rows):\n            row_result = ''\n            if last_signature:\n                current_signature = last_signature.clone()\n            else:\n                current_signature = Signatures(None, None, None, None, None)\n            last_signature = current_signature\n            empty = True\n            for spine in self.spines:\n                if spine.spine_type in options.spine_types:\n                    if i &lt; spine.size():  # required because the spine may be terminated\n                        if len(row_result) &gt; 0:\n                            row_result += '\\t'\n\n                        if kern_type == KernTypeExporter.normalizedKern:\n                            content = spine.getNormalizedRow(i, options.token_categories)\n                        elif kern_type == KernTypeExporter.eKern:\n                            content = spine.getEKernRow(i, options.token_categories)\n                        elif kern_type == KernTypeExporter.unprocessed:\n                            content = spine.getUnprocessedRow(i, options.token_categories)\n                        else:\n                            raise ValueError(f'Unknown kern type {kern_type}.\\nView {help(KernTypeExporter)} ')\n\n                        if content and content != '.' and content != '*':\n                            empty = False\n                            if options.from_measure:  # if not, we don't need to compute this value\n                                if spine.isContentOfType(i, HeaderToken):\n                                    current_signature.last_header_row = i\n                                elif spine.isContentOfType(i, ClefToken):\n                                    current_signature.last_clef_row = i\n                                elif spine.isContentOfType(i, KeySignatureToken):\n                                    current_signature.last_key_signature_row = i\n                                elif spine.isContentOfType(i, TimeSignatureToken):\n                                    current_signature.last_time_signature_row = i\n                                elif spine.isContentOfType(i, MeterSymbolToken):\n                                    current_signature.last_meter_symbol_row = i\n\n                        row_result += content\n            if not empty:\n                row_contents.append(row_result)\n            else:\n                row_contents.append(None)  # in order to maintain the indexes\n\n            signatures_at_each_row.append(current_signature)\n\n        # if last_header_row is None:\n        #     raise Exception('No header row found')\n        #\n        # if last_clef_row is None:\n        #     raise Exception('No clef row found')\n        #\n        # if last_time_signature_row is None and last_meter_symbol_row is None:\n        #     raise Exception('No time signature or meter symbol row found')\n\n        result = ''\n        if options.from_measure is None and options.to_measure is None:\n            for row_content in row_contents:\n                if row_content:\n                    result += row_content\n                    result += '\\n'\n        else:\n            if options.from_measure:\n                self.checkMeasure(options.from_measure)\n            else:\n                options.from_measure = 1\n\n            if options.to_measure:\n                self.checkMeasure(options.to_measure)\n            else:\n                options.to_measure = len(self.measure_start_rows)\n\n            from_row = self.measure_start_rows[options.from_measure - 1] - 1  # measures and rows are counted from 1\n            if options.to_measure == len(self.measure_start_rows):\n                to_row = self.measure_start_rows[options.to_measure - 1]\n            else:\n                to_row = self.measure_start_rows[options.to_measure]  # to the next one\n            signature = signatures_at_each_row[from_row]\n\n            # first, attach the signatures if not in the exported range\n            result = self.addSignatureRowIfRequired(row_contents, result, from_row, signature.last_header_row)\n            result = self.addSignatureRowIfRequired(row_contents, result, from_row, signature.last_clef_row)\n            result = self.addSignatureRowIfRequired(row_contents, result, from_row, signature.last_key_signature_row)\n            result = self.addSignatureRowIfRequired(row_contents, result, from_row, signature.last_time_signature_row)\n            result = self.addSignatureRowIfRequired(row_contents, result, from_row, signature.last_meter_symbol_row)\n\n            for row in range(from_row, to_row):\n                row_content = row_contents[row]\n                if row_content:\n                    result += row_content\n                    result += '\\n'\n\n            if to_row &lt; max_rows:\n                row_content = ''\n                for spine in self.spines:\n                    if spine.spine_type in options.spine_types and not spine.isTerminated():\n                        if len(row_content) &gt; 0:\n                            row_content += '\\t'\n                        row_content += '*-'\n                result += row_content\n                result += '\\n'\n        return result\n\n    def addSignatureRowIfRequired(self, row_contents, result, from_row, signature_row):\n        if signature_row is not None and signature_row &lt; from_row:\n            srow = row_contents[signature_row]\n            result += srow\n            result += '\\n'\n        return result\n\n    def getErrorMessages(self):\n        result = ''\n        for err in self.errors:\n            result += str(err)\n            result + '\\n'\n        return result\n\n    def hasErrors(self):\n        return len(self.errors) &gt; 0\n\n\n    def hasToken(self, token_goal: str):\n        \"\"\"\n        Check if the importer has a specific token.\n\n        Args:\n            token_goal: The token to check.\n\n        Returns:\n            True if the importer has the token, False otherwise.\n\n        Example:\n        ```python\n        # Create the importer\n        hi = HumdrumImporter()\n\n        # Read the file\n        hi.doImportFile('file.krn')\n\n        # Check if the importer has a specific token\n        has_f_4_clef = hi.has('*clefF4')\n        ```\n        \"\"\"\n        for spine in self.spines:\n            for row in spine.rows:\n                if any(token.encoding == token_goal for token in row):\n                    return True\n\n        return False\n\n    def hasCategory(self, token_category_goal: TokenCategory):\n        \"\"\"\n        Check if the importer has a specific token.\n\n        Args:\n            token_category_goal: The token category to check.\n        Returns:\n            True if the importer has the token category, False otherwise.\n\n        Example:\n        ```python\n        # Create the importer\n        hi = HumdrumImporter()\n\n        # Read the file\n        hi.doImportFile('file.krn')\n\n        # Check if the importer has a specific token\n        has_barlines = hi.has(TokenCategory.BARLINES)\n        ```\n        \"\"\"\n        #for spine in self.spines:\n        #    for row in spine.rows:\n        #        if any(isinstance(token_category_goal, token) for token in row):\n        #            return True\n        #\n        #return False\n        pass\n</code></pre>"},{"location":"reference/#kernpy.core.HumdrumImporter.getMetacomments","title":"<code>getMetacomments(KeyComment=None, clean=True)</code>","text":"<p>Get the metacomments of the file.</p> <p>Parameters:</p> Name Type Description Default <code>KeyComment</code> <code>str</code> <p>The key of the metacomment. (optional).                If not specified, all the metacomments will be returned. If specified, all the content of the metacomment with the specified key will be returned.</p> <code>None</code> <code>clean</code> <code>bool</code> <p>If True, the metacomments will be returned applying a .strip(). Only valid if KeyComment is not None.</p> <code>True</code> <p>Returns:</p> Type Description <p>A list with the metacomments.                if KeyComment is not None, a list be returned anyway.                 If there are no metacomments with the specified key, an empty list will be returned.</p> Example <pre><code>from kernpy import HumdrumImporter\nimporter = HumdrumImporter()\n\n# Read the file\nimporter.doImportFile('file.krn')\n\n# Get all the metacomments\nall_metacomments = importer.getMetacomments()\n# ... modify the metacomments using your own logic\n\n# Get the metacomments with the key: get the composer:\ncomposer = importer.getMetacomments(KeyComment='!!!COM')\n\n# check if your kern file format is compatible with the expected format. If it is not, do not clen it:\nraw_compose = importer.getMetacomments(KeyComment='!!!COM', clean=False)\n</code></pre> Source code in <code>kernpy/core/import_humdrum.py</code> <pre><code>def getMetacomments(self, KeyComment: str = None, clean: bool = True):  # each metacomment is contained in all spines as a reference to the same object\n    \"\"\"\n    Get the metacomments of the file.\n\n    Args:\n        KeyComment: The key of the metacomment. (optional).\\\n            If not specified, all the metacomments will be returned.\n            If specified, all the content of the metacomment with the specified key will be returned.\n        clean: If True, the metacomments will be returned applying a .strip(). Only valid if KeyComment is not None.\n\n    Returns:\n        A list with the metacomments.\\\n            if KeyComment is not None, a list be returned anyway. \\\n            If there are no metacomments with the specified key, an empty list will be returned.\n\n    Example:\n        ```python\n        from kernpy import HumdrumImporter\n        importer = HumdrumImporter()\n\n        # Read the file\n        importer.doImportFile('file.krn')\n\n        # Get all the metacomments\n        all_metacomments = importer.getMetacomments()\n        # ... modify the metacomments using your own logic\n\n        # Get the metacomments with the key: get the composer:\n        composer = importer.getMetacomments(KeyComment='!!!COM')\n\n        # check if your kern file format is compatible with the expected format. If it is not, do not clen it:\n        raw_compose = importer.getMetacomments(KeyComment='!!!COM', clean=False)\n        ```\n\n    \"\"\"\n    result = []\n    for token in self.spines[0].rows:\n        if isinstance(token[0], MetacommentToken):\n            if clean:\n                result.append(token[0].encoding.strip())\n            else:\n                result.append(token[0].encoding)\n\n    if KeyComment is not None:\n        clean_rows = [row.replace('!!!', '').replace('!!', '') for row in result]\n        filtered_rows = [row for row in clean_rows if row.startswith(KeyComment)]\n        valid_rows = [row.replace(KeyComment, '').strip()[2:] for row in filtered_rows] if clean else filtered_rows\n        return valid_rows\n\n    return result\n</code></pre>"},{"location":"reference/#kernpy.core.HumdrumImporter.hasCategory","title":"<code>hasCategory(token_category_goal)</code>","text":"<p>Check if the importer has a specific token.</p> <p>Parameters:</p> Name Type Description Default <code>token_category_goal</code> <code>TokenCategory</code> <p>The token category to check.</p> required <p>Returns:     True if the importer has the token category, False otherwise.</p> <p>Example:</p> <pre><code># Create the importer\nhi = HumdrumImporter()\n\n# Read the file\nhi.doImportFile('file.krn')\n\n# Check if the importer has a specific token\nhas_barlines = hi.has(TokenCategory.BARLINES)\n</code></pre> Source code in <code>kernpy/core/import_humdrum.py</code> <pre><code>def hasCategory(self, token_category_goal: TokenCategory):\n    \"\"\"\n    Check if the importer has a specific token.\n\n    Args:\n        token_category_goal: The token category to check.\n    Returns:\n        True if the importer has the token category, False otherwise.\n\n    Example:\n    ```python\n    # Create the importer\n    hi = HumdrumImporter()\n\n    # Read the file\n    hi.doImportFile('file.krn')\n\n    # Check if the importer has a specific token\n    has_barlines = hi.has(TokenCategory.BARLINES)\n    ```\n    \"\"\"\n    #for spine in self.spines:\n    #    for row in spine.rows:\n    #        if any(isinstance(token_category_goal, token) for token in row):\n    #            return True\n    #\n    #return False\n    pass\n</code></pre>"},{"location":"reference/#kernpy.core.HumdrumImporter.hasToken","title":"<code>hasToken(token_goal)</code>","text":"<p>Check if the importer has a specific token.</p> <p>Parameters:</p> Name Type Description Default <code>token_goal</code> <code>str</code> <p>The token to check.</p> required <p>Returns:</p> Type Description <p>True if the importer has the token, False otherwise.</p> <p>Example:</p> <pre><code># Create the importer\nhi = HumdrumImporter()\n\n# Read the file\nhi.doImportFile('file.krn')\n\n# Check if the importer has a specific token\nhas_f_4_clef = hi.has('*clefF4')\n</code></pre> Source code in <code>kernpy/core/import_humdrum.py</code> <pre><code>def hasToken(self, token_goal: str):\n    \"\"\"\n    Check if the importer has a specific token.\n\n    Args:\n        token_goal: The token to check.\n\n    Returns:\n        True if the importer has the token, False otherwise.\n\n    Example:\n    ```python\n    # Create the importer\n    hi = HumdrumImporter()\n\n    # Read the file\n    hi.doImportFile('file.krn')\n\n    # Check if the importer has a specific token\n    has_f_4_clef = hi.has('*clefF4')\n    ```\n    \"\"\"\n    for spine in self.spines:\n        for row in spine.rows:\n            if any(token.encoding == token_goal for token in row):\n                return True\n\n    return False\n</code></pre>"},{"location":"reference/#kernpy.core.KernTypeExporter","title":"<code>KernTypeExporter</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Options for exporting a kern file.</p> <p>Example:</p> <pre><code># Create the importer\nhi = HumdrumImporter()\n\n# Read the file\noptions = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\nhi.doImportFile('file.krn')\n\n# Export the file\noptions = KernExporter.normalizedKern\nexported = hi.doExport(exportOptions)\n</code></pre> Source code in <code>kernpy/core/import_humdrum.py</code> <pre><code>class KernTypeExporter(Enum):\n    \"\"\"\n    Options for exporting a kern file.\n\n    Example:\n    ```\n    # Create the importer\n    hi = HumdrumImporter()\n\n    # Read the file\n    options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n    hi.doImportFile('file.krn')\n\n    # Export the file\n    options = KernExporter.normalizedKern\n    exported = hi.doExport(exportOptions)\n    ```\n    \"\"\"\n    unprocessed = 0\n    eKern = 1\n    normalizedKern = 2\n</code></pre>"},{"location":"reference/#kernpy.core.Score","title":"<code>Score</code>","text":"Source code in <code>kernpy/core/generic.py</code> <pre><code>class Score:\n    def __init__(self, name):\n        self.name = name\n        ...\n\n    def transpose(self, interval: int):\n        \"\"\"\n        Transpose the score by a chromatic interval.\n        Keep the same notes semantic interval. Even if double or triple accidentals are used.\n\n        Args:\n            interval: The chromatic interval to transpose the score.\n\n        Returns:\n            new_score: The transposed score.\n\n        Examples:\n            &gt;&gt;&gt; import kernpy\n            &gt;&gt;&gt; score = kernpy.read_kern('path/to/file.krn')\n            &gt;&gt;&gt; # Transpose 2 semitones up\n            &gt;&gt;&gt; s1 = score.transpose(2)\n            &gt;&gt;&gt; # Transpose 2 semitones down\n            &gt;&gt;&gt; s2 = score.transpose(-2)\n            &gt;&gt;&gt; # Export it to a file\n            &gt;&gt;&gt; s1.to_krn('path/to/up2.krn')\n            &gt;&gt;&gt; s2.to_krn('path/to/down2.krn')\n        \"\"\"\n        raise NotImplementedError()\n\n    def measure_from_time(self, time: float) -&gt; int:\n        \"\"\"\n        Greater number of the measure where the time is not greater than 10 seconds\n\n        Args:\n            time: The max time in seconds.\n\n        Returns:\n            measure: The measure number.\n\n        Examples:\n            &gt;&gt;&gt; import kernpy\n            &gt;&gt;&gt; score = kernpy.read_kern('path/to/file.krn')\n            &gt;&gt;&gt; # Get the measure at 10 seconds\n            &gt;&gt;&gt; measure = score.measure_from_time(10)\n            &gt;&gt;&gt; # Greater number of the measure where the time is not greater than 10 seconds\n            &gt;&gt;&gt; print(measure)\n        \"\"\"\n        raise NotImplementedError()\n\n    def extract_spine(self, spine):\n        \"\"\"\n        Extract a spine from the score. TODO:\n        \"\"\"\n        raise NotImplementedError()\n\n    def extract_measures(self, from_measure=None, to_measure=None):\n        \"\"\"\n        Extract a range of measures from the score and return a new score.\n\n        Args:\n            from_measure: The measure to start the extraction. The first measure starts at 0.\n            to_measure: The measure to end the extraction. The last measure is included. \\\n                        The last measure ends at len(score.measures) - 1.\n        \"\"\"\n        raise NotImplementedError()\n\n    def tokens(self) -&gt; set:\n        \"\"\"\n        Return a set of tokens in the score.\n\n        Returns:\n            tokens: A set of tokens in the score.\n\n        Examples:\n            &gt;&gt;&gt; import kernpy\n            &gt;&gt;&gt; score = kernpy.read_kern('path/to/file.krn')\n            &gt;&gt;&gt; tokens = score.tokens()\n            &gt;&gt;&gt; print(tokens)\n            {\"2r\", \"4G\", \"8c\", \"|\" }\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def to_krn(self):\n        raise NotImplementedError()\n\n    def to_ekrn(self):\n        raise NotImplementedError()\n\n    def export(self, options: ExportOptions):\n        raise NotImplementedError()\n\n    def __str__(self):\n        raise NotImplementedError()\n\n    def __repr__(self):\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/#kernpy.core.Score.extract_measures","title":"<code>extract_measures(from_measure=None, to_measure=None)</code>","text":"<p>Extract a range of measures from the score and return a new score.</p> <p>Parameters:</p> Name Type Description Default <code>from_measure</code> <p>The measure to start the extraction. The first measure starts at 0.</p> <code>None</code> <code>to_measure</code> <p>The measure to end the extraction. The last measure is included.                         The last measure ends at len(score.measures) - 1.</p> <code>None</code> Source code in <code>kernpy/core/generic.py</code> <pre><code>def extract_measures(self, from_measure=None, to_measure=None):\n    \"\"\"\n    Extract a range of measures from the score and return a new score.\n\n    Args:\n        from_measure: The measure to start the extraction. The first measure starts at 0.\n        to_measure: The measure to end the extraction. The last measure is included. \\\n                    The last measure ends at len(score.measures) - 1.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/#kernpy.core.Score.extract_spine","title":"<code>extract_spine(spine)</code>","text":"<p>Extract a spine from the score. TODO:</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>def extract_spine(self, spine):\n    \"\"\"\n    Extract a spine from the score. TODO:\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/#kernpy.core.Score.measure_from_time","title":"<code>measure_from_time(time)</code>","text":"<p>Greater number of the measure where the time is not greater than 10 seconds</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>The max time in seconds.</p> required <p>Returns:</p> Name Type Description <code>measure</code> <code>int</code> <p>The measure number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy\n&gt;&gt;&gt; score = kernpy.read_kern('path/to/file.krn')\n&gt;&gt;&gt; # Get the measure at 10 seconds\n&gt;&gt;&gt; measure = score.measure_from_time(10)\n&gt;&gt;&gt; # Greater number of the measure where the time is not greater than 10 seconds\n&gt;&gt;&gt; print(measure)\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>def measure_from_time(self, time: float) -&gt; int:\n    \"\"\"\n    Greater number of the measure where the time is not greater than 10 seconds\n\n    Args:\n        time: The max time in seconds.\n\n    Returns:\n        measure: The measure number.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy\n        &gt;&gt;&gt; score = kernpy.read_kern('path/to/file.krn')\n        &gt;&gt;&gt; # Get the measure at 10 seconds\n        &gt;&gt;&gt; measure = score.measure_from_time(10)\n        &gt;&gt;&gt; # Greater number of the measure where the time is not greater than 10 seconds\n        &gt;&gt;&gt; print(measure)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/#kernpy.core.Score.tokens","title":"<code>tokens()</code>","text":"<p>Return a set of tokens in the score.</p> <p>Returns:</p> Name Type Description <code>tokens</code> <code>set</code> <p>A set of tokens in the score.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy\n&gt;&gt;&gt; score = kernpy.read_kern('path/to/file.krn')\n&gt;&gt;&gt; tokens = score.tokens()\n&gt;&gt;&gt; print(tokens)\n{\"2r\", \"4G\", \"8c\", \"|\" }\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>def tokens(self) -&gt; set:\n    \"\"\"\n    Return a set of tokens in the score.\n\n    Returns:\n        tokens: A set of tokens in the score.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy\n        &gt;&gt;&gt; score = kernpy.read_kern('path/to/file.krn')\n        &gt;&gt;&gt; tokens = score.tokens()\n        &gt;&gt;&gt; print(tokens)\n        {\"2r\", \"4G\", \"8c\", \"|\" }\n\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/#kernpy.core.Score.transpose","title":"<code>transpose(interval)</code>","text":"<p>Transpose the score by a chromatic interval. Keep the same notes semantic interval. Even if double or triple accidentals are used.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>int</code> <p>The chromatic interval to transpose the score.</p> required <p>Returns:</p> Name Type Description <code>new_score</code> <p>The transposed score.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy\n&gt;&gt;&gt; score = kernpy.read_kern('path/to/file.krn')\n&gt;&gt;&gt; # Transpose 2 semitones up\n&gt;&gt;&gt; s1 = score.transpose(2)\n&gt;&gt;&gt; # Transpose 2 semitones down\n&gt;&gt;&gt; s2 = score.transpose(-2)\n&gt;&gt;&gt; # Export it to a file\n&gt;&gt;&gt; s1.to_krn('path/to/up2.krn')\n&gt;&gt;&gt; s2.to_krn('path/to/down2.krn')\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>def transpose(self, interval: int):\n    \"\"\"\n    Transpose the score by a chromatic interval.\n    Keep the same notes semantic interval. Even if double or triple accidentals are used.\n\n    Args:\n        interval: The chromatic interval to transpose the score.\n\n    Returns:\n        new_score: The transposed score.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy\n        &gt;&gt;&gt; score = kernpy.read_kern('path/to/file.krn')\n        &gt;&gt;&gt; # Transpose 2 semitones up\n        &gt;&gt;&gt; s1 = score.transpose(2)\n        &gt;&gt;&gt; # Transpose 2 semitones down\n        &gt;&gt;&gt; s2 = score.transpose(-2)\n        &gt;&gt;&gt; # Export it to a file\n        &gt;&gt;&gt; s1.to_krn('path/to/up2.krn')\n        &gt;&gt;&gt; s2.to_krn('path/to/down2.krn')\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"reference/#kernpy.core.ekern_to_krn","title":"<code>ekern_to_krn(input_file, output_file)</code>","text":"<p>Convert one .ekrn file to .krn file.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <p>Filepath to the input **ekern</p> required <code>output_file</code> <p>Filepath to the output **kern</p> required <p>Returns:     None</p> Source code in <code>kernpy/core/import_humdrum.py</code> <pre><code>def ekern_to_krn(input_file, output_file) -&gt; None:\n    \"\"\"\n    Convert one .ekrn file to .krn file.\n\n    Args:\n        input_file: Filepath to the input **ekern\n        output_file: Filepath to the output **kern\n    Returns:\n        None\n    \"\"\"\n    with open(input_file, 'r') as file:\n        content = file.read()\n\n    kern_content = get_kern_from_ekern(content)\n\n    with open(output_file, 'w') as file:\n        file.write(kern_content)\n</code></pre>"},{"location":"reference/#kernpy.core.kern_to_ekern","title":"<code>kern_to_ekern(input_file, output_file)</code>","text":"<p>Convert one .krn file to .ekrn file</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <p>Filepath to the input **kern</p> required <code>output_file</code> <p>Filepath to the output **ekern</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kernpy/core/import_humdrum.py</code> <pre><code>def kern_to_ekern(input_file, output_file) -&gt; None:\n    \"\"\"\n    Convert one .krn file to .ekrn file\n\n    Args:\n        input_file: Filepath to the input **kern\n        output_file: Filepath to the output **ekern\n\n    Returns:\n        None\n    \"\"\"\n    importer = HumdrumImporter()\n    importer.doImportFile(input_file)\n\n    if len(importer.errors):\n        raise Exception(f'ERROR: {input_file} has errors {importer.getErrorMessages()}')\n\n    export_options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n    exported_ekern = importer.doExportEKern(export_options)\n\n    with open(output_file, 'w') as file:\n        file.write(exported_ekern)\n</code></pre>"},{"location":"reference/#kernpy.core.read_kern","title":"<code>read_kern(input_file)</code>","text":"<p>Read a kern file and return a Score object.</p> <p>Parameters:</p> Name Type Description Default <code>inputpath</code> <p>The path to the kern file.</p> required <p>Returns:</p> Name Type Description <code>score</code> <p>The score object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy\n&gt;&gt;&gt; score = kernpy.read_kern('path/to/file.krn')\n&gt;&gt;&gt; print(score)\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>def read_kern(input_file: str):\n    \"\"\"\n    Read a kern file and return a Score object.\n\n    Args:\n        inputpath: The path to the kern file.\n\n    Returns:\n        score: The score object.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy\n        &gt;&gt;&gt; score = kernpy.read_kern('path/to/file.krn')\n        &gt;&gt;&gt; print(score)\n    \"\"\"\n    importer = HumdrumImporter()\n    importer.doImportFile(input_file)\n\n    if len(importer.errors):\n        raise Exception(f'ERROR: {input_file} has errors {importer.getErrorMessages()}')\n\n    # TODO: Store the HumdrumImporter object in the Score object\n    score = Score(\"a\")\n    return score\n</code></pre>"},{"location":"reference/#kernpy.util.create_fragments_from_directory","title":"<code>create_fragments_from_directory(input_directory, output_directory, log_file, check_file_extension=True, offset=0, verbose=1, num_processes=None, mean=DEFAULT_MEAN, std_dev=DEFAULT_STD_DEV)</code>","text":"<p>Create a bunch of little kern files from a directory of kern files.</p> <p>Parameters:</p> Name Type Description Default <code>log_file</code> <code>str</code> required <code>input_directory</code> <code>str</code> required <code>output_directory</code> <code>str</code> required <code>check_file_extension</code> <code>bool</code> <code>True</code> <code>offset</code> <code>int</code> <code>0</code> <code>verbose</code> <code>int</code> <code>1</code> <code>num_processes</code> <code>int</code> <code>None</code> <code>mean</code> <code>float</code> <code>DEFAULT_MEAN</code> <code>std_dev</code> <code>float</code> <code>DEFAULT_STD_DEV</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <p>...</p> Source code in <code>kernpy/util/generator.py</code> <pre><code>def create_fragments_from_directory(input_directory: str, output_directory: str, log_file: str,\n                                    check_file_extension: bool = True, offset: int = 0,\n                                    verbose: int = 1, num_processes: int = None,\n                                    mean: float = DEFAULT_MEAN, std_dev: float = DEFAULT_STD_DEV) -&gt; None:\n    \"\"\"\n    Create a bunch of little kern files from a directory of kern files.\n\n    Args:\n        log_file:\n        input_directory:\n        output_directory:\n        check_file_extension:\n        offset:\n        verbose:\n        num_processes:\n        mean:\n        std_dev:\n\n    Returns:\n        None\n\n    Examples:\n        ...\n\n    \"\"\"\n    if any(keyword in input_directory for keyword in ABSOLUTE_PATHS_KEYWORDS):\n        raise ValueError(BAD_PATH_ERROR_MESSAGE)\n    if mean is None:\n        mean = DEFAULT_MEAN\n    if std_dev is None:\n        std_dev = DEFAULT_STD_DEV\n    if check_file_extension is None:\n        check_file_extension = True\n\n    fg = FragmentGenerator(offset=offset, verbose=verbose, num_processes=num_processes, log_file=log_file,\n                           mean=mean, std_dev=std_dev)\n    fg.create_fragments_from_directory(input_directory=input_directory,\n                                       output_directory=output_directory,\n                                       check_file_extension=check_file_extension)\n</code></pre>"},{"location":"reference/#kernpy.util.create_fragments_from_kern","title":"<code>create_fragments_from_kern(input_kern_file, output_directory, measure_length, offset, log_file, verbose=1, num_processes=None, force_path=False)</code>","text":"<p>Create a bunch of little kern files from a single kern file.</p> <p>Parameters:</p> Name Type Description Default <code>log_file</code> <code>str</code> required <code>input_kern_file</code> <code>str</code> required <code>output_directory</code> <code>str</code> required <code>measure_length</code> <code>int</code> required <code>offset</code> <code>int</code> required <code>verbose</code> <code>int</code> <code>1</code> <code>force_path</code> <code>bool</code> <code>False</code> <code>num_processes</code> <code>int</code> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <p>...</p> Source code in <code>kernpy/util/generator.py</code> <pre><code>def create_fragments_from_kern(input_kern_file: str, output_directory: str, measure_length: int,\n                               offset: int, log_file: str, verbose: int = 1, num_processes: int = None,\n                               force_path: bool = False) -&gt; None:\n    \"\"\"\n    Create a bunch of little kern files from a single kern file.\n\n    Args:\n        log_file:\n        input_kern_file:\n        output_directory:\n        measure_length:\n        offset:\n        verbose:\n        force_path:\n        num_processes:\n\n    Returns:\n        None\n\n    Examples:\n        ...\n\n    \"\"\"\n    if not force_path and any(keyword in input_kern_file for keyword in ABSOLUTE_PATHS_KEYWORDS):\n        raise ValueError(BAD_PATH_ERROR_MESSAGE)\n\n    fg = FragmentGenerator(offset=offset, verbose=verbose, num_processes=num_processes, log_file=log_file)\n    fg.create_fragments_from_file(input_kern_file=input_kern_file,\n                                  output_directory=output_directory,\n                                  measure_length=measure_length)\n</code></pre>"},{"location":"reference/#kernpy.polish_scores.main","title":"<code>main(input_directory, output_directory)</code>","text":"<p>Process the files in the input_directory and save the results in the output_directory. http requests are made to download the images.</p> <p>Parameters:</p> Name Type Description Default <code>input_directory</code> <p>directory where the input files are found</p> required <code>output_directory</code> <p>directory where the output files are saved</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern')\n</code></pre> Source code in <code>kernpy/polish_scores/download_polish_dataset.py</code> <pre><code>def main(input_directory, output_directory) -&gt; None:\n    \"\"\"\n    Process the files in the input_directory and save the results in the output_directory.\n    http requests are made to download the images.\n\n    Args:\n        input_directory: directory where the input files are found\n        output_directory: directory where the output files are saved\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; main('/kern_files', '/output_ekern')\n\n    \"\"\"\n    print(f'Processing files in {input_directory} and saving to {output_directory}')\n    kern_with_bboxes = search_files_with_string(input_directory, 'xywh')\n    ok_files = []\n    ko_files = []\n    for kern in kern_with_bboxes:\n        try:\n            filename = remove_extension(kern)\n            kern_path = os.path.join(input_directory, kern)\n            output_kern_path = os.path.join(output_directory, filename)\n            if not os.path.exists(output_kern_path):\n                os.makedirs(output_kern_path)\n            convert_and_download_file(kern_path, output_kern_path)\n            ok_files.append(kern)\n        except Exception as error:\n            ko_files.append(kern)\n            print(f'Errors in {kern}: {error}')\n\n    print(f'----&gt; OK files #{len(ok_files)}')\n    print(f'----&gt; KO files #{len(ko_files)}')\n    print(ko_files)\n</code></pre>"},{"location":"get-started/installation/","title":"Installation","text":"<p>Instructions for installing <code>kernpy</code> are provided below.</p>"},{"location":"get-started/installation/#install-using-pip","title":"Install using <code>pip</code>","text":"<p>Update <code>pip</code> to the latest version:</p> <pre><code>pip install --upgrade pip\n</code></pre> <p>Install <code>kernpy</code> using <code>pip</code>:</p> <pre><code>pip install kernpy\n</code></pre> <p>Check your <code>kernpy</code> version:</p> <pre><code>python -m kernpy --version \n</code></pre>"},{"location":"get-started/installation/#next-steps","title":"Next steps","text":"<ul> <li>Quick Start</li> <li>Reference</li> </ul>"},{"location":"get-started/quick-start/","title":"Quick start","text":""},{"location":"get-started/quick-start/#installation","title":"Installation","text":"<p>First of all, you need to install <code>kernpy</code>. You can do this by running the following command:</p> <p>Go to Installation for more information.</p>"},{"location":"get-started/quick-start/#usage","title":"Usage","text":"<p>Go to the README.md file in the kernpy repository to learn how to use <code>kernpy</code>.</p>"}]}