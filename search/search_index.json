{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kernpy Docs","text":"kernpy documentation <p>Date:  \u00a0|\u00a0 Version: 0.1.2</p> <p>Download documentation: Zipped HTML</p>"},{"location":"#useful-links","title":"Useful links:","text":"<p>Installation \u00a0|\u00a0 Source Repository \u00a0|\u00a0 Project Website (PRAIG)</p> <p><code>kernpy</code> is a python package that provides utilities for working with kern and mens data.</p>"},{"location":"#contents","title":"ContentsGetting startedHow-To guideAPI referenceAbout","text":"<p>New to <code>kernpy</code>? Check out the getting started guides. They contain an introduction to <code>kernpy</code>'s main concepts and links to additional tutorials.</p> To the getting started guides <p>The How-To guides provide in-depth information on how to perform specific tasks with <code>kernpy</code> step-by-step.</p> To the How-To guides <p>The API reference contains a detailed description of the <code>kernpy</code> API. It describes how the methods work and which parameters can be used.</p> To the API reference <p>Find out more about the <code>kernpy</code> project, including the team, how to contribute, and the license.</p> To the About page <p>Next</p> <p>Getting Started</p> <p>Previous</p> <p>Getting Started</p> <p></p> <p>Quickly find what you are looking for depending on your use case by looking at the different pages.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>University of Alicante.</p>"},{"location":"about/","title":"Who are we?","text":"<p>We are a research group <code>Pattern Recognition and Artificial Intelligence Group</code> affiliated with the University of Alicante. </p> <p>To learn more about our work, please visit our website.</p>"},{"location":"get-started/","title":"Getting started","text":""},{"location":"get-started/#installation","title":"Installation","text":"<p>Instructions for installing <code>kernpy</code> are provided below.</p>"},{"location":"get-started/#install-kernpy-using-pip","title":"Install <code>kernpy</code> using <code>pip</code>","text":"<pre><code>pip install kernpy\n</code></pre>"},{"location":"get-started/#install-the-last-version-from-the-repository","title":"Install the last version from the repository","text":"<pre><code>pip install git+https://github.com/OMR-PRAIG-UA-ES/kernpy.git \n</code></pre>"},{"location":"get-started/#install-a-specific-version-from-the-repository","title":"Install a specific version from the repository","text":"<pre><code>pip install git+https://github.com/OMR-PRAIG-UA-ES/kernpy.git@&lt;commit-tag&gt;\n</code></pre>"},{"location":"get-started/#next-steps","title":"Next steps","text":"<ul> <li>Tutorial     Learn how to use <code>kernpy</code> in a few minutes.</li> </ul>"},{"location":"how-to-guides/","title":"Guides: learn what you can do with <code>kernpy</code>","text":"<p>This section contains a series of guides that will help you get started with <code>kernpy</code> and learn how to use it to perform different tasks.</p> <ul> <li>Get started</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>Here you can find the API reference for the <code>kernpy</code> package. The reference contains a detailed description of the <code>kernpy</code> API. The reference describes how the methods work and which parameters can be used. </p> <p>Find the basics of the <code>kernpy</code> package in the Tutorial.</p>"},{"location":"reference/#kernpy--kernpy","title":"kernpy","text":"<p>=====</p> <p>Python Humdrum kern and mens utilities package.</p> <p>Execute the following command to run kernpy as a module:</p> <pre><code>python -m kernpy --help\npython -m kernpy &lt;command&gt; &lt;options&gt;\n</code></pre> <p>Run <code>kernpy</code> from your script:</p> <pre><code>import kernpy\n\nhelp(kernpy)\n</code></pre> <p>While the package is not published in <code>pip</code>, the <code>kernpy</code> module must be in the root directory.</p>"},{"location":"reference/#kernpy--kern2ekern-convertir-un-solo-archivo-krn-a-ekern","title":"\ud83c\udfaf kern2ekern: Convertir un solo archivo .krn a .ekern:","text":"<pre><code>python -m kernpy --kern2ekern --input_path &lt;input_file&gt;  &lt;v | --verbose [0-2]&gt;\n</code></pre> <p>The command has the following arguments: * input_path: Ruta del archivo .krn a convertir. * output_path: Ruta del archivo .ekern a generar (opcional). Si no se especifica, se generar\u00e1 en la misma ubicaci\u00f3n. * -r: Recursivo (opcional). * --verbose[0-2]: Nivel de verbosidad (opcional).</p> <p>\ud83d\udccc Basic usage running kernpy as a module:</p> <pre><code>python -m kernpy --input_path /my/path/to/file.krn # New ekern generated in /my/path/to/file.ekern\n</code></pre> <p>\ud83d\udccc Generate an ekrn file in specific location running kernpy as a module:</p> <pre><code>python -m kernpy --input_path /my/path/to/file.krn --output_path /new/output.ekern\n</code></pre> <p>\ud83d\udccc Converting all the .krn files in a directory to .ekern files running kernpy as a module: * Every .krn file in the directory will be converted to .ekern in the same location. * Using, at least, one additional directory level is required.</p> <pre><code>root\n\u251c\u2500 kern-folder\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2.krn\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 3.krn\n\u251c\u2500\u2500 more-kerns\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n</code></pre> <p>Run:</p> <pre><code>python -m kernpy --input_path /my/path/to/directory/ -r\n</code></pre> <p>\u270f\ufe0f This function is also available as a python function:</p> <pre><code># converter.py\nfrom kernpy import kern_to_ekern\n\nkern_to_ekern('/my/path/to/input.krn', '/to/my/output.ekrn')\n\n# Many files\nfiles = ['file1.krn', 'file2.krn', 'file3.krn']\n[kern_to_ekern(f) for f in files]\n\n# This function raises an exception if the conversion fails.\n# Handle the errors using try-except statement if many files are going to be converted in series.\n</code></pre>"},{"location":"reference/#kernpy--ekern2kern-convertir-un-solo-archivo-ekern-a-krn","title":"\ud83c\udfaf ekern2kern: Convertir un solo archivo .ekern a .krn:","text":"<pre><code>python -m kernpy --ekern2kern --input_path &lt;input_file&gt;  &lt;--verbose [0-2]&gt;\n</code></pre> <p>The command has the following arguments: * input_path: Ruta del archivo .ekern a convertir. * output_path: Ruta del archivo .krn a generar (opcional). Si no se especifica, se generar\u00e1 en la misma ubicaci\u00f3n. * -r: Recursivo (opcional). * --verbose[0-2]: Nivel de verbosidad (opcional).</p> <ul> <li>Basic usage running kernpy as a module:</li> </ul> <pre><code>python -m kernpy --input_path /my/path/to/file.ekern # New krn generated in /my/path/to/file.krn\n</code></pre> <p>\ud83d\udccc Generate a krn file in specific location running kernpy as a module:</p> <pre><code>python -m kernpy --input_path /my/path/to/file.ekern --output_path /new/output.krn\n</code></pre> <p>\ud83d\udccc Converting all the .ekern files in a directory to .krn files running kernpy as a module:</p> <ul> <li>Every .ekrn file in the directory will be converted to .krn in the same location.</li> <li>Using, at least, one additional directory level is required.</li> </ul> <pre><code>root\n\u251c\u2500 ekern-folder\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.ekrn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2.ekrn\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 3.ekrn\n\u251c\u2500\u2500 more-ekerns\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.ekrn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n</code></pre> <p>Run:</p> <pre><code>python -m kernpy --input_path /my/path/to/directory/ -r\n</code></pre> <p>\u270f\ufe0f This function is also available as a python function:</p> <pre><code># converter.py\nfrom kernpy import ekern_to_krn\n\n# Only one file\nekern_to_krn('/my/path/to/input.ekrn', '/to/my/output.krn')\n\n# Many files\nfiles = ['file1.ekrn', 'file2.ekrn', 'file3.ekrn']\n[ekern_to_krn(f) for f in files]\n\n# This function raises an exception if the conversion fails.\n# Handle the errors using try-except statement if many files are going to be converted in series.\n</code></pre>"},{"location":"reference/#kernpy--create-fragments","title":"\ud83c\udfaf create fragments","text":"<p>Generate new valid kern files from an original kern file. Every new fragment will be a subset of the original file.</p> <p>Explore the documentation website for more information about the parameters.</p> <p>Use: - create_fragments_from_kern to generate using always the same measure length. - create_fragments_from_directory to generate using a Gaussian distribution for the measure length. Static measure is also available if the standard deviation is set to 0.</p> <p>\ud83d\udccc Create new scores from one original kern directory running kernpy as a module:</p> <pre><code>python -m kernpy --generate_fragments --input_directory /from/my/kerns --output_directory /to/my/fragments --log_file log.csv  --verbose 2 --mean 4.2 --std_dev 1.5 --offset 1 --num_processes 12\n</code></pre> <p>\u270f\ufe0f Create new scores from one original kern file:</p> <pre><code># generator.py\nfrom kernpy import create_fragments_from_kern\n\n# View docs:\nhelp(create_fragments_from_kern)\n\ncreate_fragments_from_kern('/my/path/to/input.krn', '/to/my/output_dir/',\n                           measure_length=4, offset=1,\n                           log_file='/dev/null')\n</code></pre> <p>\u270f\ufe0f Create new scores from one original kern directory: - Using, at least, one additional directory level is required.</p> <pre><code>root\n\u251c\u2500 kern-folder\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2.krn\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 3.krn\n\u251c\u2500\u2500 more-kerns\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n</code></pre> <p>Run:</p> <pre><code># generator.py\nfrom kernpy import create_fragments_from_directory\n\n# View docs:\nhelp(create_fragments_from_directory)\n\ncreate_fragments_from_directory('/my/path/to/input_dir/', '/to/my/output_dir/',\n                                mean=4.1, std_dev=0.2, offset=2,\n                                log_file='/logs/fragments.csv',\n                                num_processes=12)\n</code></pre>"},{"location":"reference/#kernpy.Intervals","title":"<code>Intervals = {-2: 'dd1', -1: 'd1', 0: 'P1', 1: 'A1', 2: 'AA1', 3: 'dd2', 4: 'd2', 5: 'm2', 6: 'M2', 7: 'A2', 8: 'AA2', 9: 'dd3', 10: 'd3', 11: 'm3', 12: 'M3', 13: 'A3', 14: 'AA3', 15: 'dd4', 16: 'd4', 17: 'P4', 18: 'A4', 19: 'AA4', 21: 'dd5', 22: 'd5', 23: 'P5', 24: 'A5', 25: 'AA5', 26: 'dd6', 27: 'd6', 28: 'm6', 29: 'M6', 30: 'A6', 31: 'AA6', 32: 'dd7', 33: 'd7', 34: 'm7', 35: 'M7', 36: 'A7', 37: 'AA7', 40: 'octave'}</code>  <code>module-attribute</code>","text":"<p>Base-40 interval classes (d=diminished, m=minor, M=major, P=perfect, A=augmented)</p>"},{"location":"reference/#kernpy.AbstractToken","title":"<code>AbstractToken</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class representing a token.</p> <p>This class serves as a blueprint for creating various types of tokens, which are categorized based on their TokenCategory.</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> <code>category</code> <code>TokenCategory</code> <p>The category of the token.</p> <code>hidden</code> <code>bool</code> <p>A flag indicating whether the token is hidden. Defaults to False.</p>"},{"location":"reference/#kernpy.AbstractToken.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two tokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>AbstractToken</code> <p>The other token to compare.</p> required <p>Returns (bool): True if the tokens are equal, False otherwise.</p>"},{"location":"reference/#kernpy.AbstractToken.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the token.</p> <p>Returns (int): The hash of the token.</p>"},{"location":"reference/#kernpy.AbstractToken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>AbstractToken constructor</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>category</code> <code>TokenCategory</code> <p>The category of the token.</p> required"},{"location":"reference/#kernpy.AbstractToken.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two tokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>AbstractToken</code> <p>The other token to compare.</p> required <p>Returns (bool): True if the tokens are different, False otherwise.</p>"},{"location":"reference/#kernpy.AbstractToken.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the token.</p> <p>Returns (str): The string representation of the token without processing.</p>"},{"location":"reference/#kernpy.AbstractToken.export","title":"<code>export(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded token representation, potentially filtered if a filter_categories function is provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token = AbstractToken('*clefF4', TokenCategory.SIGNATURES)\n&gt;&gt;&gt; token.export()\n'*clefF4'\n&gt;&gt;&gt; token.export(filter_categories=lambda cat: cat in {TokenCategory.SIGNATURES, TokenCategory.SIGNATURES.DURATION})\n'*clefF4'\n</code></pre>"},{"location":"reference/#kernpy.AgnosticPitch","title":"<code>AgnosticPitch</code>","text":"<p>Represents a pitch in a generic way, independent of the notation system used.</p>"},{"location":"reference/#kernpy.AgnosticPitch.__init__","title":"<code>__init__(name, octave)</code>","text":"<p>Initialize the AgnosticPitch object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the pitch (e.g., 'C', 'D#', 'Bb').</p> required <code>octave</code> <code>int</code> <p>The octave of the pitch (e.g., 4 for middle C).</p> required"},{"location":"reference/#kernpy.BekernTokenizer","title":"<code>BekernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>BekernTokenizer converts a Token into a bekern (Basic Extended **kern) string representation. This format use a '@' separator for the     main tokens but discards all the decorations tokens.</p>"},{"location":"reference/#kernpy.BekernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new BekernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required"},{"location":"reference/#kernpy.BekernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a bekern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): bekern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; BekernTokenizer().tokenize(token)\n'2@.@bb@-'\n</code></pre>"},{"location":"reference/#kernpy.BkernTokenizer","title":"<code>BkernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>BkernTokenizer converts a Token into a bkern (Basic kern) string representation. This format use     the main tokens but not the decorations tokens. This format is a lightweight version of the classic Humdrum kern format.</p>"},{"location":"reference/#kernpy.BkernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new BkernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required"},{"location":"reference/#kernpy.BkernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a bkern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): bkern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; BkernTokenizer().tokenize(token)\n'2.bb-'\n</code></pre>"},{"location":"reference/#kernpy.C1Clef","title":"<code>C1Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.C1Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p>"},{"location":"reference/#kernpy.C1Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.C2Clef","title":"<code>C2Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.C2Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p>"},{"location":"reference/#kernpy.C2Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.C3Clef","title":"<code>C3Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.C3Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p>"},{"location":"reference/#kernpy.C3Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.C4Clef","title":"<code>C4Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.C4Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p>"},{"location":"reference/#kernpy.C4Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.Clef","title":"<code>Clef</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class representing a clef.</p>"},{"location":"reference/#kernpy.Clef.__init__","title":"<code>__init__(diatonic_pitch, on_line)</code>","text":"<p>Initializes the Clef object. Args:     diatonic_pitch (DiatonicPitch): The diatonic pitch of the clef (e.g., 'C', 'G', 'F'). This value is used as a decorator.     on_line (int): The line number on which the clef is placed (1 for bottom line, 2 for 1st line from bottom, etc.). This value is used as a decorator.</p>"},{"location":"reference/#kernpy.Clef.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation of the clef.</p>"},{"location":"reference/#kernpy.Clef.bottom_line","title":"<code>bottom_line()</code>  <code>abstractmethod</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.Clef.name","title":"<code>name()</code>","text":"<p>Returns the name of the clef.</p>"},{"location":"reference/#kernpy.Clef.reference_point","title":"<code>reference_point()</code>","text":"<p>Returns the reference point for the clef.</p>"},{"location":"reference/#kernpy.ComplexToken","title":"<code>ComplexToken</code>","text":"<p>               Bases: <code>Token</code>, <code>ABC</code></p> <p>Abstract ComplexToken class. This abstract class ensures that the subclasses implement the export method using     the 'filter_categories' parameter to filter the subtokens.</p> <p>Passing the argument 'filter_categories' by **kwargs don't break the compatibility with parent classes.</p> <p>Here we're trying to get the Liskov substitution principle done...</p>"},{"location":"reference/#kernpy.ComplexToken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>Constructor for the ComplexToken</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>category</code> <code>TokenCategory) </code> <p>The category of the token.</p> required"},{"location":"reference/#kernpy.ComplexToken.export","title":"<code>export(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p>"},{"location":"reference/#kernpy.CompoundToken","title":"<code>CompoundToken</code>","text":"<p>               Bases: <code>ComplexToken</code></p>"},{"location":"reference/#kernpy.CompoundToken.__init__","title":"<code>__init__(encoding, category, subtokens)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>category</code> <code>TokenCategory</code> <p>The token category, one of 'TokenCategory'</p> required <code>subtokens</code> <code>List[Subtoken]</code> <p>The individual elements of the token. Also of type 'TokenCategory' but                 in the hierarchy they must be children of the current token.</p> required"},{"location":"reference/#kernpy.CompoundToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p>"},{"location":"reference/#kernpy.Document","title":"<code>Document</code>","text":"<p>Document class.</p> <p>This class store the score content using an agnostic tree structure.</p> <p>Attributes:</p> Name Type Description <code>tree</code> <code>MultistageTree</code> <p>The tree structure of the document where all the nodes are stored.             Each stage of the tree corresponds to a row in the Humdrum **kern file encoding.</p> <code>measure_start_tree_stages</code> <code>List[List[Node]]</code> <p>The list of nodes that corresponds to the measures.             Empty list by default. The index of the list is starting from 1. Rows after removing empty lines and line comments</p> <code>page_bounding_boxes</code> <code>Dict[int, BoundingBoxMeasures]</code> <p>The dictionary of page bounding boxes.             - key: page number - value: BoundingBoxMeasures object</p> <code>header_stage</code> <code>int</code> <p>The index of the stage that contains the headers. None by default.</p>"},{"location":"reference/#kernpy.Document.__init__","title":"<code>__init__(tree)</code>","text":"<p>Constructor for Document class.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>MultistageTree</code> <p>The tree structure of the document where all the nodes are stored.</p> required"},{"location":"reference/#kernpy.Document.__iter__","title":"<code>__iter__()</code>","text":"<p>Get the indexes to export all the document.</p> <p>Returns: An iterator with the indexes to export the document.</p>"},{"location":"reference/#kernpy.Document.__next__","title":"<code>__next__()</code>","text":"<p>Get the next index to export the document.</p> <p>Returns: The next index to export the document.</p>"},{"location":"reference/#kernpy.Document.add","title":"<code>add(other, *, check_core_spines_only=False)</code>","text":"<p>Concatenate one document to the current document: Modify the current object!</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'Document'</code> <p>The document to concatenate.</p> required <code>check_core_spines_only</code> <code>Optional[bool]</code> <p>If True, only the core spines (kern and mens) are checked. If False, all spines are checked.</p> <code>False</code> <p>Returns ('Document'): The current document (self) with the other document concatenated.</p>"},{"location":"reference/#kernpy.Document.append_spines","title":"<code>append_spines(spines)</code>","text":"<pre><code>    Append the spines directly to current document tree.\n\n    Args:\n        spines(list): A list of spines to append.\n\n    Returns: None\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; doc, _ = kp.read('score.krn')\n        &gt;&gt;&gt; spines = [\n        &gt;&gt;&gt; '4e     4f      4g      4a\n</code></pre> <p>4b      4c      4d      4e =       =       =       = ',             &gt;&gt;&gt; '4c     4d      4e      4f 4g      4a      4b      4c =       =       =       = ',            &gt;&gt;&gt; ]            &gt;&gt;&gt; doc.append_spines(spines)            None</p>"},{"location":"reference/#kernpy.Document.clone","title":"<code>clone()</code>","text":"<p>Create a deep copy of the Document instance.</p> <p>Returns: A new instance of Document with the tree copied.</p>"},{"location":"reference/#kernpy.Document.frequencies","title":"<code>frequencies(token_categories=None)</code>","text":"<p>Frequency of tokens in the document.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>If None, all tokens are considered.</p> <code>None</code> <p>Returns (Dict):     A dictionary with the category and the number of occurrences of each token.</p>"},{"location":"reference/#kernpy.Document.get_all_tokens","title":"<code>get_all_tokens(filter_by_categories=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AbstractToken]</code> <p>List[AbstractToken] - A list of all tokens.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n&gt;&gt;&gt; [type(t) for t in tokens]\n[&lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;]\n</code></pre>"},{"location":"reference/#kernpy.Document.get_all_tokens_encodings","title":"<code>get_all_tokens_encodings(filter_by_categories=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str] - A list of all token encodings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens_encodings()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n</code></pre>"},{"location":"reference/#kernpy.Document.get_first_measure","title":"<code>get_first_measure()</code>","text":"<p>Get the index of the first measure of the document.</p> <p>Returns: (Int) The index of the first measure of the document.</p> <p>Raises: Exception - If the document has no measures.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, err = kp.read('score.krn')\n&gt;&gt;&gt; document.get_first_measure()\n1\n</code></pre>"},{"location":"reference/#kernpy.Document.get_header_nodes","title":"<code>get_header_nodes()</code>","text":"<p>Get the header nodes of the current document.</p> <p>Returns: List[HeaderToken]: A list with the header nodes of the current document.</p>"},{"location":"reference/#kernpy.Document.get_header_stage","title":"<code>get_header_stage()</code>","text":"<p>Get the Node list of the header stage.</p> <p>Returns: (Union[List[Node], List[List[Node]]]) The Node list of the header stage.</p> <p>Raises: Exception - If the document has no header stage.</p>"},{"location":"reference/#kernpy.Document.get_leaves","title":"<code>get_leaves()</code>","text":"<p>Get the leaves of the tree.</p> <p>Returns: (List[Node]) The leaves of the tree.</p>"},{"location":"reference/#kernpy.Document.get_metacomments","title":"<code>get_metacomments(KeyComment=None, clear=False)</code>","text":"<p>Get all metacomments in the document</p> <p>Parameters:</p> Name Type Description Default <code>KeyComment</code> <code>Optional[str]</code> <p>Filter by a specific metacomment key: e.g. Use 'COM' to get only comments starting with                '!!!COM: '. If None, all metacomments are returned.</p> <code>None</code> <code>clear</code> <code>bool</code> <p>If True, the metacomment key is removed from the comment. E.g. '!!!COM: Coltrane' -&gt; 'Coltrane'.                If False, the metacomment key is kept. E.g. '!!!COM: Coltrane' -&gt; '!!!COM: Coltrane'.                 The clear functionality is equivalent to the following code:</p> <pre><code>comment = '!!!COM: Coltrane'\nclean_comment = comment.replace(f\"!!!{KeyComment}: \", \"\")\n</code></pre> <p>Other formats are not supported.</p> <code>False</code> <p>Returns: A list of metacomments.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_metacomments()\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='COM')\n['!!!COM: Coltrane']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='COM', clear=True)\n['Coltrane']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='non_existing_key')\n[]\n</code></pre>"},{"location":"reference/#kernpy.Document.get_spine_count","title":"<code>get_spine_count()</code>","text":"<p>Get the number of spines in the document.</p> <p>Returns (int): The number of spines in the document.</p>"},{"location":"reference/#kernpy.Document.get_spine_ids","title":"<code>get_spine_ids()</code>","text":"<p>Get the indexes of the current document.</p> <p>Returns List[int]: A list with the indexes of the current document.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_all_spine_indexes()\n[0, 1, 2, 3, 4]\n</code></pre>"},{"location":"reference/#kernpy.Document.get_unique_token_encodings","title":"<code>get_unique_token_encodings(filter_by_categories=None)</code>","text":"<p>Get unique token encodings.</p> <p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns: List[str] - A list of unique token encodings.</p>"},{"location":"reference/#kernpy.Document.get_unique_tokens","title":"<code>get_unique_tokens(filter_by_categories=None)</code>","text":"<p>Get unique tokens.</p> <p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AbstractToken]</code> <p>List[AbstractToken] - A list of unique tokens.</p>"},{"location":"reference/#kernpy.Document.get_voices","title":"<code>get_voices(clean=False)</code>","text":"<p>Get the voices of the document.</p> <p>Args     clean (bool): Remove the first '!' from the voice name.</p> <p>Returns: A list of voices.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_voices()\n['!sax', '!piano', '!bass']\n&gt;&gt;&gt; document.get_voices(clean=True)\n['sax', 'piano', 'bass']\n&gt;&gt;&gt; document.get_voices(clean=False)\n['!sax', '!piano', '!bass']\n</code></pre>"},{"location":"reference/#kernpy.Document.match","title":"<code>match(a, b, *, check_core_spines_only=False)</code>  <code>classmethod</code>","text":"<p>Match two documents. Two documents match if they have the same spine structure.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Document</code> <p>The first document.</p> required <code>b</code> <code>Document</code> <p>The second document.</p> required <code>check_core_spines_only</code> <code>Optional[bool]</code> <p>If True, only the core spines (kern and mens) are checked. If False, all spines are checked.</p> <code>False</code> <p>Returns: True if the documents match, False otherwise.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.Document.measures_count","title":"<code>measures_count()</code>","text":"<p>Get the index of the last measure of the document.</p> <p>Returns: (Int) The index of the last measure of the document.</p> <p>Raises: Exception - If the document has no measures.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document, _ = kernpy.read('score.krn')\n&gt;&gt;&gt; document.measures_count()\n10\n&gt;&gt;&gt; for i in range(document.get_first_measure(), document.measures_count() + 1):\n&gt;&gt;&gt;   options = kernpy.ExportOptions(from_measure=i, to_measure=i+4)\n</code></pre>"},{"location":"reference/#kernpy.Document.split","title":"<code>split()</code>","text":"<p>Split the current document into a list of documents, one for each kern spine. Each resulting document will contain one kern spine along with all non-kern spines.</p> <p>Returns:</p> Type Description <code>List['Document']</code> <p>List['Document']: A list of documents, where each document contains one **kern spine</p> <code>List['Document']</code> <p>and all non-kern spines from the original document.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.split()\n[&lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;]\n</code></pre>"},{"location":"reference/#kernpy.Document.to_concat","title":"<code>to_concat(first_doc, second_doc, deep_copy=True)</code>  <code>classmethod</code>","text":"<p>Concatenate two documents.</p> <p>Parameters:</p> Name Type Description Default <code>first_doc</code> <code>Document</code> <p>The first document.</p> required <code>second_doc</code> <code>Document</code> <p>The second document.</p> required <code>deep_copy</code> <code>bool</code> <p>If True, the documents are deep copied. If False, the documents are shallow copied.</p> <code>True</code> <p>Returns: A new instance of Document with the documents concatenated.</p>"},{"location":"reference/#kernpy.Document.tokens_to_encodings","title":"<code>tokens_to_encodings(tokens)</code>  <code>classmethod</code>","text":"<p>Get the encodings of a list of tokens.</p> The method is equivalent to the following code <p>tokens = kp.get_all_tokens() [token.encoding for token in tokens if token.encoding is not None]</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>Sequence[AbstractToken]</code> <p>list - A list of tokens.</p> required <p>Returns: List[str] - A list of token encodings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n</code></pre>"},{"location":"reference/#kernpy.Duration","title":"<code>Duration</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Represents the duration of a note or a rest.</p> <p>The duration is represented using the Humdrum Kern format. The duration is a number that represents the number of units of the duration.</p> <p>The duration of a whole note is 1, half note is 2, quarter note is 4, eighth note is 8, etc.</p> <p>The duration of a note is represented by a number. The duration of a rest is also represented by a number.</p> <p>This class do not limit the duration ranges.</p> <p>In the following example, the duration is represented by the number '2'.</p> <pre><code>**kern\n*clefG2\n2c          // whole note\n4c          // half note\n8c          // quarter note\n16c         // eighth note\n*-\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical","title":"<code>DurationClassical</code>","text":"<p>               Bases: <code>Duration</code></p> <p>Represents the duration in classical notation of a note or a rest.</p>"},{"location":"reference/#kernpy.DurationClassical.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool): True if the durations are equal, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration == duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration == duration2\nFalse\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is higher or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt;= duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &gt;= duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt;= duration2\nTrue\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'DurationClassical'</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is higher than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt; duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &gt; duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt; duration2\nFalse\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__init__","title":"<code>__init__(duration)</code>","text":"<p>Create a new Duration object.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>str</code> <p>duration representation in Humdrum Kern format</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(32)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(1)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(0)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(-2)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(3)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(7)\nFalse\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__le__","title":"<code>__le__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this duration is lower or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt;= duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &lt;= duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt;= duration2\nTrue\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is lower than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt; duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &lt; duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt; duration2\nFalse\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if the durations are different, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration != duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration != duration2\nTrue\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.modify","title":"<code>modify(ratio)</code>","text":"<p>Modify the duration of a note or a rest of the current object.</p> <p>Parameters:</p> Name Type Description Default <code>ratio</code> <code>int</code> <p>The factor to modify the duration. The factor must be greater than 0.</p> required <p>Returns (DurationClassical): The new duration object with the modified duration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(2)\n&gt;&gt;&gt; new_duration.duration\n4\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(0)\nTraceback (most recent call last):\n...\nValueError: Invalid factor provided: 0. The factor must be greater than 0.\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(-2)\nTraceback (most recent call last):\n...\nValueError: Invalid factor provided: -2. The factor must be greater than 0.\n</code></pre>"},{"location":"reference/#kernpy.DurationMensural","title":"<code>DurationMensural</code>","text":"<p>               Bases: <code>Duration</code></p> <p>Represents the duration in mensural notation of a note or a rest.</p>"},{"location":"reference/#kernpy.DynSpineImporter","title":"<code>DynSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.DynSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.DynamSpineImporter","title":"<code>DynamSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.DynamSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.EkernTokenizer","title":"<code>EkernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>EkernTokenizer converts a Token into an eKern (Extended **kern) string representation. This format use a '@' separator for the     main tokens and a '\u00b7' separator for the decorations tokens.</p>"},{"location":"reference/#kernpy.EkernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new EkernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>List[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required"},{"location":"reference/#kernpy.EkernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into an eKern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): eKern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; EkernTokenizer().tokenize(token)\n'2@.@bb@-\u00b7_\u00b7L'\n</code></pre>"},{"location":"reference/#kernpy.ExportOptions","title":"<code>ExportOptions</code>","text":"<p><code>ExportOptions</code> class.</p> <p>Store the options to export a **kern file.</p>"},{"location":"reference/#kernpy.ExportOptions.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two ExportOptions objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'ExportOptions'</code> <p>The other ExportOptions object to compare.</p> required <p>Returns (bool):     True if the objects are equal, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 == options2\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 == options3\nFalse\n</code></pre>"},{"location":"reference/#kernpy.ExportOptions.__init__","title":"<code>__init__(spine_types=None, token_categories=None, from_measure=None, to_measure=None, kern_type=KernTypeExporter.normalizedKern, instruments=None, show_measure_numbers=False, spine_ids=None)</code>","text":"<p>Create a new ExportOptions object.</p> <p>Parameters:</p> Name Type Description Default <code>spine_types</code> <code>Iterable</code> <p>kern, mens, etc...</p> <code>None</code> <code>token_categories</code> <code>Iterable</code> <p>TokenCategory</p> <code>None</code> <code>from_measure</code> <code>int</code> <p>The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1</p> <code>None</code> <code>to_measure</code> <code>int</code> <p>The measure to end exporting. When None, the exporter will end at the end of the file.</p> <code>None</code> <code>kern_type</code> <code>KernTypeExporter</code> <p>The type of the kern file to export.</p> <code>normalizedKern</code> <code>instruments</code> <code>Iterable</code> <p>The instruments to export. When None, all the instruments will be exported.</p> <code>None</code> <code>show_measure_numbers</code> <code>Bool</code> <p>Show the measure numbers in the exported file.</p> <code>False</code> <code>spine_ids</code> <code>Iterable</code> <p>The ids of the spines to export. When None, all the spines will be exported. Spines ids start from 0 and they are increased by 1.</p> <code>None</code> Example <p>import kernpy</p> <p>Create the importer and read the file</p> <p>hi = Importer() document = hi.import_file('file.krn') exporter = Exporter()</p> <p>Export the file with the specified options</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES) exported_data = exporter.export_string(document, options)</p> <p>Export only the lyrics</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LYRICS]) exported_data = exporter.export_string(document, options)</p> <p>Export the comments</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LINE_COMMENTS, TokenCategory.FIELD_COMMENTS]) exported_data = exporter.export_string(document, options)</p> <p>Export using the eKern version</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES, kern_type=KernTypeExporter.eKern) exported_data = exporter.export_string(document, options)</p>"},{"location":"reference/#kernpy.ExportOptions.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two ExportOptions objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>ExportOptions</code> <p>The other ExportOptions object to compare.</p> required <p>Returns (bool):     True if the objects are not equal, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 != options2\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 != options3\nTrue\n</code></pre>"},{"location":"reference/#kernpy.Exporter","title":"<code>Exporter</code>","text":""},{"location":"reference/#kernpy.Exporter.append_row","title":"<code>append_row(document, node, options, row)</code>","text":"<p>Append a row to the row list if the node accomplishes the requirements. Args:     document (Document): The document with the spines.     node (Node): The node to append.     options (ExportOptions): The export options to filter the token.     row (list): The row to append.</p> <p>Returns (bool): True if the row was appended. False if the row was not appended.</p>"},{"location":"reference/#kernpy.Exporter.compute_header_type","title":"<code>compute_header_type(node)</code>","text":"<p>Compute the header type of the node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node to compute.</p> required <p>Returns (Optional[Token]): The header type <code>Node</code>object. None if the current node is the header.</p>"},{"location":"reference/#kernpy.Exporter.export_options_validator","title":"<code>export_options_validator(document, options)</code>  <code>classmethod</code>","text":"<p>Validate the export options. Raise an exception if the options are invalid.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p><code>Document</code> - The document to export.</p> required <code>options</code> <code>ExportOptions</code> <p><code>ExportOptions</code> - The options to export the document.</p> required <p>Returns: None</p> Example <p>export_options_validator(document, options) ValueError: option from_measure must be &gt;=0 but -1 was found. export_options_validator(document, options2) None</p>"},{"location":"reference/#kernpy.Exporter.get_spine_types","title":"<code>get_spine_types(document, spine_types=None)</code>","text":"<p>Get the spine types from the document.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>The document with the spines.</p> required <code>spine_types</code> <code>list</code> <p>The spine types to export. If None, all the spine types will be exported.</p> <code>None</code> <p>Returns: A list with the spine types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exporter = Exporter()\n&gt;&gt;&gt; exporter.get_spine_types(document)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern'])\n['**kern', '**kern', '**kern', '**kern']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root'])\n['**kern', '**kern', '**kern', '**kern', '**root']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root', '**harm'])\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, [])\n[]\n</code></pre>"},{"location":"reference/#kernpy.F3Clef","title":"<code>F3Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.F3Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the F Clef object.</p>"},{"location":"reference/#kernpy.F3Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.F4Clef","title":"<code>F4Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.F4Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the F Clef object.</p>"},{"location":"reference/#kernpy.F4Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.FingSpineImporter","title":"<code>FingSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.FingSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.GClef","title":"<code>GClef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.GClef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the G Clef object.</p>"},{"location":"reference/#kernpy.GClef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.GraphvizExporter","title":"<code>GraphvizExporter</code>","text":""},{"location":"reference/#kernpy.GraphvizExporter.export_to_dot","title":"<code>export_to_dot(tree, filename=None)</code>","text":"<p>Export the given MultistageTree to DOT format.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>MultistageTree</code> <p>The tree to export.</p> required <code>filename</code> <code>Path or None</code> <p>The output file path. If None, prints to stdout.</p> <code>None</code>"},{"location":"reference/#kernpy.HarmSpineImporter","title":"<code>HarmSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.HarmSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.HeaderToken","title":"<code>HeaderToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>HeaderTokens class.</p>"},{"location":"reference/#kernpy.HeaderToken.__init__","title":"<code>__init__(encoding, spine_id)</code>","text":"<p>Constructor for the HeaderToken class.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>spine_id</code> <code>int</code> <p>The spine id of the token. The spine id is used to identify the token in the score.                The spine_id starts from 0 and increases by 1 for each new spine like the following example: kern  kern  kern dyn **text 0   1   2   3   4</p> required"},{"location":"reference/#kernpy.HeaderTokenGenerator","title":"<code>HeaderTokenGenerator</code>","text":"<p>HeaderTokenGenerator class.</p> <p>This class is used to translate the HeaderTokens to the specific tokenizer format.</p>"},{"location":"reference/#kernpy.HeaderTokenGenerator.new","title":"<code>new(*, token, type)</code>  <code>classmethod</code>","text":"<p>Create a new HeaderTokenGenerator object. Only accepts stardized Humdrum **kern encodings. </p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>HeaderToken</code> <p>The HeaderToken to be translated.</p> required <code>type</code> <code>KernTypeExporter</code> <p>The tokenizer to be used.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; header = HeaderToken('**kern', 0)\n&gt;&gt;&gt; header.encoding\n'**kern'\n&gt;&gt;&gt; new_header = HeaderTokenGenerator.new(token=header, type=KernTypeExporter.eKern)\n&gt;&gt;&gt; new_header.encoding\n'**ekern'\n</code></pre>"},{"location":"reference/#kernpy.HumdrumPitchImporter","title":"<code>HumdrumPitchImporter</code>","text":"<p>               Bases: <code>PitchImporter</code></p> <p>Represents the pitch in the Humdrum Kern format.</p> <p>The name is represented using the International Standard Organization (ISO) name notation. The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.</p> <p>The Humdrum Kern format uses the following name representation: 'c' = C4 'cc' = C5 'ccc' = C6 'cccc' = C7</p> <p>'C' = C3 'CC' = C2 'CCC' = C1</p> <p>This class do not limit the name ranges.</p> <p>In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.</p> <pre><code>**kern\n*clefG2\n2c          // C4\n2cc         // C5\n2ccc        // C6\n2C          // C3\n2CC         // C2\n2CCC        // C1\n*-\n</code></pre>"},{"location":"reference/#kernpy.Importer","title":"<code>Importer</code>","text":"<p>Importer class.</p> <p>Use this class to import the content from a file or a string to a <code>Document</code> object.</p>"},{"location":"reference/#kernpy.Importer.__init__","title":"<code>__init__()</code>","text":"<pre><code>    Create an instance of the importer.\n\n    Raises:\n        Exception: If the importer content is not a valid **kern file.\n\n    Examples:\n        # Create the importer\n        &gt;&gt;&gt; importer = Importer()\n\n        # Import the content from a file\n        &gt;&gt;&gt; document = importer.import_file('file.krn')\n\n        # Import the content from a string\n        &gt;&gt;&gt; document = importer.import_string(\"**kern\n</code></pre> <p>clefF4 c4 4d 4e 4f -\")</p>"},{"location":"reference/#kernpy.Importer.get_error_messages","title":"<code>get_error_messages()</code>","text":"<p>Get the error messages of the importer.</p> <p>Returns: str - The error messages split by a new line character.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.Importer.get_error_messages--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file(Path('file.krn'))\n&gt;&gt;&gt; print(importer.get_error_messages())\n'Error: Invalid token in row 1'\n</code></pre>"},{"location":"reference/#kernpy.Importer.has_errors","title":"<code>has_errors()</code>","text":"<p>Check if the importer has any errors.</p> <p>Returns: bool - True if the importer has errors, False otherwise.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.Importer.has_errors--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file(Path('file.krn'))    # file.krn has an error\n&gt;&gt;&gt; print(importer.has_errors())\nTrue\n&gt;&gt;&gt; importer.import_file(Path('file2.krn'))   # file2.krn has no errors\n&gt;&gt;&gt; print(importer.has_errors())\nFalse\n</code></pre>"},{"location":"reference/#kernpy.Importer.import_file","title":"<code>import_file(file_path)</code>","text":"<p>Import the content from the importer to the file. Args:     file_path: The path to the file.</p> <p>Returns:</p> Type Description <code>Document</code> <p>Document - The document with the imported content.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.Importer.import_file--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file('file.krn')\n</code></pre>"},{"location":"reference/#kernpy.Importer.import_string","title":"<code>import_string(text)</code>","text":"<pre><code>    Import the content from the content of the score in string format.\n\n    Args:\n        text: The content of the score in string format.\n\n    Returns:\n        Document - The document with the imported content.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_string(\"**kern\n</code></pre> <p>clefF4 c4 4d 4e 4f -\")             # Read the content from a file             &gt;&gt;&gt; with open('file.krn',  'r', newline='', encoding='utf-8', errors='ignore') as f: # We encourage you to use these open file options             &gt;&gt;&gt;     content = f.read()             &gt;&gt;&gt; importer.import_string(content)             &gt;&gt;&gt; document = importer.import_string(content)</p>"},{"location":"reference/#kernpy.KernSpineImporter","title":"<code>KernSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.KernSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.KernTokenizer","title":"<code>KernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>KernTokenizer converts a Token into a normalized kern string representation.</p>"},{"location":"reference/#kernpy.KernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new KernTokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required"},{"location":"reference/#kernpy.KernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a normalized kern string representation. This format is the classic Humdrum **kern representation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>Token to be tokenized.</p> required <p>Returns (str): Normalized kern string representation. This is the classic Humdrum **kern representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; KernTokenizer().tokenize(token)\n'2.bb-_L'\n</code></pre>"},{"location":"reference/#kernpy.KernTypeExporter","title":"<code>KernTypeExporter</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Options for exporting a kern file.</p> Example <p>import kernpy as kp</p>"},{"location":"reference/#kernpy.KernTypeExporter--load-a-file","title":"Load a file","text":"<p>doc, _ = kp.load('path/to/file.krn')</p>"},{"location":"reference/#kernpy.KernTypeExporter--save-the-file-using-the-specified-encoding","title":"Save the file using the specified encoding","text":"<p>exported_content = kp.dumps(tokenizer=kp.KernTypeExporter.normalizedKern)</p>"},{"location":"reference/#kernpy.KernTypeExporter.prefix","title":"<code>prefix()</code>","text":"<p>Get the prefix of the kern type.</p> <p>Returns (str): Prefix of the kern type.</p>"},{"location":"reference/#kernpy.MensSpineImporter","title":"<code>MensSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.MensSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>MensSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.MxhmSpineImporter","title":"<code>MxhmSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.MxhmSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.NoteRestToken","title":"<code>NoteRestToken</code>","text":"<p>               Bases: <code>ComplexToken</code></p> <p>NoteRestToken class.</p> <p>Attributes:</p> Name Type Description <code>pitch_duration_subtokens</code> <code>list</code> <p>The subtokens for the pitch and duration</p> <code>decoration_subtokens</code> <code>list</code> <p>The subtokens for the decorations</p>"},{"location":"reference/#kernpy.NoteRestToken.__init__","title":"<code>__init__(encoding, pitch_duration_subtokens, decoration_subtokens)</code>","text":"<p>NoteRestToken constructor.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>pitch_duration_subtokens</code> <code>List[Subtoken])y</code> <p>The subtokens for the pitch and duration</p> required <code>decoration_subtokens</code> <code>List[Subtoken]</code> <p>The subtokens for the decorations. Individual elements of the token, of type Subtoken</p> required"},{"location":"reference/#kernpy.NoteRestToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p>"},{"location":"reference/#kernpy.PitchPositionReferenceSystem","title":"<code>PitchPositionReferenceSystem</code>","text":""},{"location":"reference/#kernpy.PitchPositionReferenceSystem.__init__","title":"<code>__init__(base_pitch)</code>","text":"<p>Initializes the PitchPositionReferenceSystem object. Args:     base_pitch (AgnosticPitch): The AgnosticPitch in the first line of the Staff.              The AgnosticPitch object that serves as the reference point for the system.</p>"},{"location":"reference/#kernpy.PitchPositionReferenceSystem.compute_position","title":"<code>compute_position(pitch)</code>","text":"<p>Computes the position in staff for the given pitch. Args:     pitch (AgnosticPitch): The AgnosticPitch object to compute the position for. Returns:     PositionInStaff: The PositionInStaff object representing the computed position.</p>"},{"location":"reference/#kernpy.PitchRest","title":"<code>PitchRest</code>","text":"<p>Represents a name or a rest in a note.</p> <p>The name is represented using the International Standard Organization (ISO) name notation. The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.</p> <p>The Humdrum Kern format uses the following name representation: 'c' = C4 'cc' = C5 'ccc' = C6 'cccc' = C7</p> <p>'C' = C3 'CC' = C2 'CCC' = C1</p> <p>The rests are represented by the letter 'r'. The rests do not have name.</p> <p>This class do not limit the name ranges.</p> <p>In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.</p> <pre><code>**kern\n*clefG2\n2c          // C4\n2cc         // C5\n2ccc        // C6\n2C          // C3\n2CC         // C2\n2CCC        // C1\n*-\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two pitches and rests.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PitchRest</code> <p>The other name to compare</p> required <p>Returns (bool):     True if the pitches are equal, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nTrue\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool):     True if this name is higher or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Compare two pitches.</p> <p>If any of the pitches is a rest, the comparison raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PitchRest</code> <p>The other name to compare</p> required <p>Returns (bool): True if this name is higher than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTraceback (most recent call last):\nValueError: ...\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__init__","title":"<code>__init__(raw_pitch)</code>","text":"<p>Create a new PitchRest object.</p> <p>Parameters:</p> Name Type Description Default <code>raw_pitch</code> <code>str</code> <p>name representation in Humdrum Kern format</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest = PitchRest('DDD')\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__le__","title":"<code>__le__(other)</code>","text":"<p>Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool): True if this name is lower or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two pitches.</p> <p>If any of the pitches is a rest, the comparison raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'PitchRest'</code> <p>The other name to compare</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this name is lower than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two pitches and rests. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool):     True if the pitches are different, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nFalse\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.is_rest","title":"<code>is_rest()</code>","text":"<p>Check if the name is a rest.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the name is a rest, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest.is_rest()\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest.is_rest()\nTrue\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.pitch_comparator","title":"<code>pitch_comparator(pitch_a, pitch_b)</code>  <code>staticmethod</code>","text":"<p>Compare two pitches of the same octave.</p> <p>The lower name is 'a'. So 'a' &lt; 'b' &lt; 'c' &lt; 'd' &lt; 'e' &lt; 'f' &lt; 'g'</p> <p>Parameters:</p> Name Type Description Default <code>pitch_a</code> <code>str</code> <p>One name of 'abcdefg'</p> required <code>pitch_b</code> <code>str</code> <p>Another name of 'abcdefg'</p> required <p>Returns:</p> Type Description <code>int</code> <p>-1 if pitch1 is lower than pitch2</p> <code>int</code> <p>0 if pitch1 is equal to pitch2</p> <code>int</code> <p>1 if pitch1 is higher than pitch2</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PitchRest.pitch_comparator('c', 'c')\n0\n&gt;&gt;&gt; PitchRest.pitch_comparator('c', 'd')\n-1\n&gt;&gt;&gt; PitchRest.pitch_comparator('d', 'c')\n1\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff","title":"<code>PositionInStaff</code>","text":""},{"location":"reference/#kernpy.PositionInStaff.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p>"},{"location":"reference/#kernpy.PositionInStaff.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the PositionInStaff object.</p>"},{"location":"reference/#kernpy.PositionInStaff.__init__","title":"<code>__init__(line_space)</code>","text":"<p>Initializes the PositionInStaff object.</p> <p>Parameters:</p> Name Type Description Default <code>line_space</code> <code>int</code> <p>0 for bottom line, -1 for space under bottom line, 1 for space above bottom line.              Increments by 1 for each line or space.</p> required"},{"location":"reference/#kernpy.PositionInStaff.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p>"},{"location":"reference/#kernpy.PositionInStaff.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p>"},{"location":"reference/#kernpy.PositionInStaff.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the PositionInStaff object.</p>"},{"location":"reference/#kernpy.PositionInStaff.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the position in staff.</p>"},{"location":"reference/#kernpy.PositionInStaff.from_encoded","title":"<code>from_encoded(encoded)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from an encoded string.</p> <p>Parameters:</p> Name Type Description Default <code>encoded</code> <code>str</code> <p>The encoded string.</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object.</p>"},{"location":"reference/#kernpy.PositionInStaff.from_line","title":"<code>from_line(line)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from a line number.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line number. line 1 is bottom line, 2 is the 1st line from bottom, 0 is the bottom ledger line</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object. 0 for the bottom line, 2 for the 1st line from bottom, -1 for the bottom ledger line, etc.</p>"},{"location":"reference/#kernpy.PositionInStaff.from_space","title":"<code>from_space(space)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from a space number.</p> <p>Parameters:</p> Name Type Description Default <code>space</code> <code>int</code> <p>The space number. space 1 is bottom space, 2</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object.</p>"},{"location":"reference/#kernpy.PositionInStaff.is_line","title":"<code>is_line()</code>","text":"<p>Returns True if the position is a line, False otherwise. If is not a line, it is a space, and vice versa.</p>"},{"location":"reference/#kernpy.PositionInStaff.line","title":"<code>line()</code>","text":"<p>Returns the line number of the position in staff.</p>"},{"location":"reference/#kernpy.PositionInStaff.move","title":"<code>move(line_space_difference)</code>","text":"<p>Returns a new PositionInStaff object with the position moved by the given number of lines or spaces.</p> <p>Parameters:</p> Name Type Description Default <code>line_space_difference</code> <code>int</code> <p>The number of lines or spaces to move.</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The new PositionInStaff object.</p>"},{"location":"reference/#kernpy.PositionInStaff.position_above","title":"<code>position_above()</code>","text":"<p>Returns the position above the current position.</p>"},{"location":"reference/#kernpy.PositionInStaff.position_below","title":"<code>position_below()</code>","text":"<p>Returns the position below the current position.</p>"},{"location":"reference/#kernpy.PositionInStaff.space","title":"<code>space()</code>","text":"<p>Returns the space number of the position in staff.</p>"},{"location":"reference/#kernpy.RootSpineImporter","title":"<code>RootSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.RootSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.SimpleToken","title":"<code>SimpleToken</code>","text":"<p>               Bases: <code>Token</code></p> <p>SimpleToken class.</p>"},{"location":"reference/#kernpy.SimpleToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>'filter_categories' (Optional[Callable[[TokenCategory], bool]]): It is ignored in this class.</p> <code>{}</code> <p>Returns (str): The encoded token representation.</p>"},{"location":"reference/#kernpy.SpineOperationToken","title":"<code>SpineOperationToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>SpineOperationToken class.</p> <p>This token represents different operations in the Humdrum kern encoding. These are the available operations:     - <code>*-</code>:  spine-path terminator.     - <code>*</code>: null interpretation.     - <code>*+</code>: add spines.     - <code>*^</code>: split spines.     - <code>*x</code>: exchange spines.</p> <p>Attributes:</p> Name Type Description <code>cancelled_at_stage</code> <code>int</code> <p>The stage at which the operation was cancelled. Defaults to None.</p>"},{"location":"reference/#kernpy.SpineOperationToken.is_cancelled_at","title":"<code>is_cancelled_at(stage)</code>","text":"<p>Checks if the operation was cancelled at the given stage.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>int</code> <p>The stage at which the operation was cancelled.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the operation was cancelled at the given stage, False otherwise.</p>"},{"location":"reference/#kernpy.StoreCache","title":"<code>StoreCache</code>","text":"<p>A simple cache that stores the result of a callback function</p>"},{"location":"reference/#kernpy.StoreCache.__init__","title":"<code>__init__()</code>","text":"<p>Constructor</p>"},{"location":"reference/#kernpy.StoreCache.request","title":"<code>request(callback, request)</code>","text":"<p>Request a value from the cache. If the value is not in the cache, it will be calculated by the callback function Args:     callback (function): The callback function that will be called to calculate the value     request (any): The request that will be passed to the callback function</p> <p>Returns (any): The value that was requested</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def add_five(x):\n...     return x + 5\n&gt;&gt;&gt; store_cache = StoreCache()\n&gt;&gt;&gt; store_cache.request(callback, 5)  # Call the callback function\n10\n&gt;&gt;&gt; store_cache.request(callback, 5)  # Return the value from the cache, without calling the callback function\n10\n</code></pre>"},{"location":"reference/#kernpy.Subtoken","title":"<code>Subtoken</code>","text":"<p>Subtoken class. Thhe subtokens are the smallest units of categories. ComplexToken objects are composed of subtokens.</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <p>The complete unprocessed encoding</p> <code>category</code> <p>The subtoken category, one of SubTokenCategory</p>"},{"location":"reference/#kernpy.Subtoken.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two subtokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Subtoken</code> <p>The other subtoken to compare.</p> required <p>Returns (bool): True if the subtokens are equal, False otherwise.</p>"},{"location":"reference/#kernpy.Subtoken.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the subtoken.</p> <p>Returns (int): The hash of the subtoken.</p>"},{"location":"reference/#kernpy.Subtoken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>Subtoken constructor</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>category</code> <code>TokenCategory</code> <p>The subtoken category.                 It should be a child of the main 'TokenCategory' in the hierarchy.</p> required"},{"location":"reference/#kernpy.Subtoken.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two subtokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Subtoken</code> <p>The other subtoken to compare.</p> required <p>Returns (bool): True if the subtokens are different, False otherwise.</p>"},{"location":"reference/#kernpy.Subtoken.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the subtoken.</p> <p>Returns (str): The string representation of the subtoken.</p>"},{"location":"reference/#kernpy.TextSpineImporter","title":"<code>TextSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.TextSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.Token","title":"<code>Token</code>","text":"<p>               Bases: <code>AbstractToken</code>, <code>ABC</code></p> <p>Abstract Token class.</p>"},{"location":"reference/#kernpy.TokenCategory","title":"<code>TokenCategory</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Options for the category of a token.</p> <p>This is used to determine what kind of token should be exported.</p> <p>The categories are sorted the specific order they are compared to sorthem. But hierarchical order must be defined in other data structures.</p>"},{"location":"reference/#kernpy.TokenCategory.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two TokenCategory. Args:     other (TokenCategory): The other category to compare.</p> <p>Returns (bool): True if this category is lower than the other, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.CORE\nTrue\n&gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.STRUCTURAL\nFalse\n&gt;&gt;&gt; TokenCategory.CORE &lt; TokenCategory.STRUCTURAL\nFalse\n&gt;&gt;&gt; sorted([TokenCategory.STRUCTURAL, TokenCategory.CORE])\n[TokenCategory.STRUCTURAL, TokenCategory.CORE]\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory.__str__","title":"<code>__str__()</code>","text":"<p>Get the string representation of the category.</p> <p>Returns (str): The string representation of the category.</p>"},{"location":"reference/#kernpy.TokenCategory.children","title":"<code>children(target)</code>  <code>classmethod</code>","text":"<p>Get the children of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of child categories of the target category.</p>"},{"location":"reference/#kernpy.TokenCategory.is_child","title":"<code>is_child(*, child, parent)</code>  <code>classmethod</code>","text":"<p>Check if the child category is a child of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>TokenCategory</code> <p>The child category.</p> required <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns (bool): True if the child category is a child of the parent category, False otherwise.</p>"},{"location":"reference/#kernpy.TokenCategory.leaves","title":"<code>leaves(target)</code>  <code>classmethod</code>","text":"<p>Get the leaves of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of leaf categories of the target category.</p>"},{"location":"reference/#kernpy.TokenCategory.match","title":"<code>match(target, *, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Check if the target category matches the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (bool): True if the target category matches the include and exclude sets, False otherwise.</p>"},{"location":"reference/#kernpy.TokenCategory.nodes","title":"<code>nodes(target)</code>  <code>classmethod</code>","text":"<p>Get the nodes of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of node categories of the target category.</p>"},{"location":"reference/#kernpy.TokenCategory.tree","title":"<code>tree()</code>  <code>classmethod</code>","text":"<p>Return a string representation of the category hierarchy Returns (str): The string representation of the category hierarchy</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; print(kp.TokenCategory.tree())\n.\n\u251c\u2500\u2500 TokenCategory.STRUCTURAL\n\u251c\u2500\u2500 TokenCategory.CORE\n\u2502   \u251c\u2500\u2500 TokenCategory.NOTE_REST\n\u2502   \u2502   \u251c\u2500\u2500 TokenCategory.DURATION\n\u2502   \u2502   \u251c\u2500\u2500 TokenCategory.NOTE\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.PITCH\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.DECORATION\n\u2502   \u2502   \u2514\u2500\u2500 TokenCategory.REST\n\u2502   \u251c\u2500\u2500 TokenCategory.CHORD\n\u2502   \u2514\u2500\u2500 TokenCategory.EMPTY\n\u251c\u2500\u2500 TokenCategory.SIGNATURES\n\u2502   \u251c\u2500\u2500 TokenCategory.CLEF\n\u2502   \u251c\u2500\u2500 TokenCategory.TIME_SIGNATURE\n\u2502   \u251c\u2500\u2500 TokenCategory.METER_SYMBOL\n\u2502   \u2514\u2500\u2500 TokenCategory.KEY_SIGNATURE\n\u251c\u2500\u2500 TokenCategory.ENGRAVED_SYMBOLS\n\u251c\u2500\u2500 TokenCategory.OTHER_CONTEXTUAL\n\u251c\u2500\u2500 TokenCategory.BARLINES\n\u251c\u2500\u2500 TokenCategory.COMMENTS\n\u2502   \u251c\u2500\u2500 TokenCategory.FIELD_COMMENTS\n\u2502   \u2514\u2500\u2500 TokenCategory.LINE_COMMENTS\n\u251c\u2500\u2500 TokenCategory.DYNAMICS\n\u251c\u2500\u2500 TokenCategory.HARMONY\n\u251c\u2500\u2500 TokenCategory.FINGERING\n\u251c\u2500\u2500 TokenCategory.LYRICS\n\u251c\u2500\u2500 TokenCategory.INSTRUMENTS\n\u251c\u2500\u2500 TokenCategory.BOUNDING_BOXES\n\u2514\u2500\u2500 TokenCategory.OTHER\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory.valid","title":"<code>valid(*, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Get the valid categories based on the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.</p>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper","title":"<code>TokenCategoryHierarchyMapper</code>","text":"<p>Mapping of the TokenCategory hierarchy.</p> <p>This class is used to define the hierarchy of the TokenCategory. Useful related methods are provided.</p>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.all","title":"<code>all()</code>  <code>classmethod</code>","text":"<p>Get all categories in the hierarchy.</p> <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>Set[TokenCategory]: The set of all categories in the hierarchy.</p>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.children","title":"<code>children(parent)</code>  <code>classmethod</code>","text":"<p>Get the direct children of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>Set[TokenCategory]: The list of children categories of the parent category.</p>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.is_child","title":"<code>is_child(parent, child)</code>  <code>classmethod</code>","text":"<p>Recursively check if <code>child</code> is in the subtree of <code>parent</code>. If <code>parent</code> is the same as <code>child</code>, return True.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <code>child</code> <code>TokenCategory</code> <p>The category to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>child</code> is a descendant of <code>parent</code>, False otherwise.</p>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.leaves","title":"<code>leaves(target)</code>  <code>classmethod</code>","text":"<p>Get the leaves of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of leaf categories of the target category.</p>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.match","title":"<code>match(category, *, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Check if the category matches the include and exclude sets.     If include is None, all categories are included.             If exclude is None, no categories are excluded.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>TokenCategory</code> <p>The category to check.</p> required <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (bool): True if the category matches the include and exclude sets, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.REST})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.NOTE})\nFalse\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.DURATION, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\nFalse\n</code></pre>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.nodes","title":"<code>nodes(parent)</code>  <code>classmethod</code>","text":"<p>Get the all nodes of the subtree of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>List[TokenCategory]: The list of nodes of the subtree of the parent category.</p>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.tree","title":"<code>tree()</code>  <code>classmethod</code>","text":"<p>Return a string representation of the category hierarchy, formatted similar to the output of the Unix 'tree' command.</p> Example output <p>. \u251c\u2500\u2500 STRUCTURAL \u251c\u2500\u2500 CORE \u2502   \u251c\u2500\u2500 NOTE_REST \u2502   \u2502   \u251c\u2500\u2500 DURATION \u2502   \u2502   \u251c\u2500\u2500 NOTE \u2502   \u2502   \u2502   \u251c\u2500\u2500 PITCH \u2502   \u2502   \u2502   \u2514\u2500\u2500 DECORATION \u2502   \u2502   \u2514\u2500\u2500 REST \u2502   \u251c\u2500\u2500 CHORD \u2502   \u2514\u2500\u2500 EMPTY \u251c\u2500\u2500 SIGNATURES \u2502   \u251c\u2500\u2500 CLEF \u2502   \u251c\u2500\u2500 TIME_SIGNATURE \u2502   \u251c\u2500\u2500 METER_SYMBOL \u2502   \u2514\u2500\u2500 KEY_SIGNATURE \u251c\u2500\u2500 ENGRAVED_SYMBOLS \u251c\u2500\u2500 OTHER_CONTEXTUAL \u251c\u2500\u2500 BARLINES \u251c\u2500\u2500 COMMENTS \u2502   \u251c\u2500\u2500 FIELD_COMMENTS \u2502   \u2514\u2500\u2500 LINE_COMMENTS \u251c\u2500\u2500 DYNAMICS \u251c\u2500\u2500 HARMONY ...</p>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.valid","title":"<code>valid(include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Get the valid categories based on the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.</p>"},{"location":"reference/#kernpy.Tokenizer","title":"<code>Tokenizer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Tokenizer interface. All tokenizers must implement this interface.</p> <p>Tokenizers are responsible for converting a token into a string representation.</p>"},{"location":"reference/#kernpy.Tokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new Tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None, an exception will be raised.</p> required"},{"location":"reference/#kernpy.Tokenizer.tokenize","title":"<code>tokenize(token)</code>  <code>abstractmethod</code>","text":"<p>Tokenize a token into a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>Token to be tokenized.</p> required <p>Returns (str): Tokenized string representation.</p>"},{"location":"reference/#kernpy.agnostic_distance","title":"<code>agnostic_distance(first_pitch, second_pitch)</code>","text":"<p>Calculate the distance in semitones between two pitches.</p> <p>Parameters:</p> Name Type Description Default <code>first_pitch</code> <code>AgnosticPitch</code> <p>The first pitch to compare.</p> required <code>second_pitch</code> <code>AgnosticPitch</code> <p>The second pitch to compare.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The distance in semitones between the two pitches.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('E4'))\n4\n&gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('B3'))\n-1\n</code></pre>"},{"location":"reference/#kernpy.concat","title":"<code>concat(contents, *, separator='\\n')</code>","text":"<pre><code>Concatenate multiple **kern fragments into a single Document object.      All the fragments should be presented in order. Each fragment does not need to be a complete **kern file. \nWarnings:\n    Processing a large number of files in a row may take some time.\n     This method performs as many `kp.read` operations as there are fragments to concatenate.\nArgs:\n    contents (Sequence[str]): List of **kern strings\n    separator (Optional[str]): Separator string to separate the **kern fragments. Default is '\n</code></pre> <p>' (newline).</p> <pre><code>Returns (Tuple[Document, List[Tuple[int, int]]]): Document object and       and a List of Pairs (Tuple[int, int]) representing the measure fragment indexes of the concatenated document.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; contents = ['**kern\n</code></pre> <p>4e 4f 4g - ', '4a 4b 4c - = ', '4d 4e 4f *- ']         &gt;&gt;&gt; document, indexes = kp.concat(contents)         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; document, indexes = kp.concat(contents, separator=' ')         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; document, indexes = kp.concat(contents, separator='')         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; for start, end in indexes:         &gt;&gt;&gt;     print(kp.dumps(document, from_measure=start, to_measure=end)))</p>"},{"location":"reference/#kernpy.create","title":"<code>create(content, strict=False)</code>","text":"<pre><code>Create a Document object from a string encoded in Humdrum **kern format.\n\nArgs:\n    content: String encoded in Humdrum **kern format\n    strict: If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.\n\nReturns (Document, list): Document object and list of error messages. Empty list if no errors.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; document, errors = kp.create('**kern\n</code></pre> <p>4e 4f 4g - ')         &gt;&gt;&gt; if len(errors) &gt; 0:         &gt;&gt;&gt;     print(errors)         ['Error: Invalid kern spine: 1', 'Error: Invalid *kern spine: 2']</p>"},{"location":"reference/#kernpy.distance","title":"<code>distance(first_encoding, second_encoding, *, first_format=NotationEncoding.HUMDRUM.value, second_format=NotationEncoding.HUMDRUM.value)</code>","text":"<p>Calculate the distance in semitones between two pitches.</p> <p>Parameters:</p> Name Type Description Default <code>first_encoding</code> <code>str</code> <p>The first pitch to compare.</p> required <code>second_encoding</code> <code>str</code> <p>The second pitch to compare.</p> required <code>first_format</code> <code>str</code> <p>The encoding format of the first pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>second_format</code> <code>str</code> <p>The encoding format of the second pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The distance in semitones between the two pitches.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; distance('C4', 'E4')\n4\n&gt;&gt;&gt; distance('C4', 'B3')\n-1\n</code></pre>"},{"location":"reference/#kernpy.download_polish_scores","title":"<code>download_polish_scores(input_directory, output_directory, remove_empty_directories=True, kern_spines_filter=2, exporter_kern_type='ekern')</code>","text":"<p>Process the files in the input_directory and save the results in the output_directory. http requests are made to download the images.</p> <p>Parameters:</p> Name Type Description Default <code>input_directory</code> <code>str</code> <p>directory where the input files are found</p> required <code>output_directory</code> <code>str</code> <p>directory where the output files are saved</p> required <code>remove_empty_directories</code> <code>Optional[bool]</code> <p>remove empty directories when finish processing the files</p> <code>True</code> <code>kern_spines_filter</code> <code>Optional[int]</code> <p>Only process files with the number of **kern spines specified.            Use it to export 2-voice files. Default is 2.            Use None to process all files.</p> <code>2</code> <code>exporter_kern_type</code> <code>Optional[str]</code> <p>the type of kern exporter. It can be 'krn' or 'ekrn'</p> <code>'ekern'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern')\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern', remove_empty_directories=False)\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern', kern_spines_filter=2, remove_empty_directories=False)\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern', kern_spines_filter=None, remove_empty_directories=False)\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern', exporter_kern_type='krn', remove_empty_directories=True)\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern', exporter_kern_type='ekrn', remove_empty_directories=True, kern_spines_filter=2)\nNone\n</code></pre>"},{"location":"reference/#kernpy.dump","title":"<code>dump(document, fp, *, spine_types=None, include=None, exclude=None, from_measure=None, to_measure=None, tokenizer=None, instruments=None, show_measure_numbers=None, spine_ids=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>The Document object to write to the file.</p> required <code>fp</code> <code>Union[str, Path]</code> <p>The file path to write the Document object.</p> required <code>spine_types</code> <code>Iterable</code> <p>kern, mens, etc...</p> <code>None</code> <code>include</code> <code>Iterable</code> <p>The token categories to include in the exported file. When None, all the token categories will be exported.</p> <code>None</code> <code>exclude</code> <code>Iterable</code> <p>The token categories to exclude from the exported file. When None, no token categories will be excluded.</p> <code>None</code> <code>from_measure</code> <code>int</code> <p>The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1</p> <code>None</code> <code>to_measure</code> <code>int</code> <p>The measure to end exporting. When None, the exporter will end at the end of the file.</p> <code>None</code> <code>tokenizer</code> <code>KernTypeExporter</code> <p>The type of the **kern file to export.</p> <code>None</code> <code>instruments</code> <code>Iterable</code> <p>The instruments to export. If None, all the instruments will be exported.</p> <code>None</code> <code>show_measure_numbers</code> <code>Bool</code> <p>Show the measure numbers in the exported file.</p> <code>None</code> <code>spine_ids</code> <code>Iterable</code> <p>The ids of the spines to export. When None, all the spines will be exported.             Spines ids start from 0, and they are increased by 1 for each spine to the right.</p> <code>None</code> <p>Returns (None): None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the document could not be exported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.load('BWV565.krn')\n&gt;&gt;&gt; kp.dump(document, 'BWV565_normalized.krn')\nNone\n&gt;&gt;&gt; # File 'BWV565_normalized.krn' will be created with the normalized **kern representation.\n</code></pre>"},{"location":"reference/#kernpy.dumps","title":"<code>dumps(document, *, spine_types=None, include=None, exclude=None, from_measure=None, to_measure=None, tokenizer=None, instruments=None, show_measure_numbers=None, spine_ids=None)</code>","text":"<pre><code>Args:\n    document (Document): The Document object to write to the file.\n    fp (Union[str, Path]): The file path to write the Document object.\n    spine_types (Iterable): **kern, **mens, etc...\n    include (Iterable): The token categories to include in the exported file. When None, all the token categories will be exported.\n    exclude (Iterable): The token categories to exclude from the exported file. When None, no token categories will be excluded.\n    from_measure (int): The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1\n    to_measure (int): The measure to end exporting. When None, the exporter will end at the end of the file.\n    tokenizer (KernTypeExporter): The type of the **kern file to export.\n    instruments (Iterable): The instruments to export. If None, all the instruments will be exported.\n    show_measure_numbers (Bool): Show the measure numbers in the exported file.\n    spine_ids (Iterable): The ids of the spines to export. When None, all the spines will be exported.             Spines ids start from 0, and they are increased by 1 for each spine to the right.\n\n\nReturns (None): None\n\nRaises:\n    ValueError: If the document could not be exported.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; document, errors = kp.load('score.krn')\n    &gt;&gt;&gt; kp.dumps(document)\n    '**kern\n</code></pre> <p>clefG2 =1 4c 4d 4e 4f -'</p>"},{"location":"reference/#kernpy.ekern_to_krn","title":"<code>ekern_to_krn(input_file, output_file)</code>","text":"<p>Convert one .ekrn file to .krn file.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Filepath to the input **ekern</p> required <code>output_file</code> <code>str</code> <p>Filepath to the output **kern</p> required <p>Returns:     None</p> Example"},{"location":"reference/#kernpy.ekern_to_krn--convert-ekrn-to-krn","title":"Convert .ekrn to .krn","text":"<p>ekern_to_krn('path/to/file.ekrn', 'path/to/file.krn')</p>"},{"location":"reference/#kernpy.ekern_to_krn--convert-a-list-of-ekrn-files-to-krn-files","title":"Convert a list of .ekrn files to .krn files","text":"<pre><code>ekrn_files = your_modue.get_files()\n\n# Use the wrapper to avoid stopping the process if an error occurs\ndef ekern_to_krn_wrapper(ekern_file, kern_file):\n    try:\n        ekern_to_krn(ekrn_files, output_folder)\n    except Exception as e:\n        print(f'Error:{e}')\n\n# Convert all the files\nfor ekern_file in ekrn_files:\n    output_file = ekern_file.replace('.ekrn', '.krn')\n    ekern_to_krn_wrapper(ekern_file, output_file)\n</code></pre>"},{"location":"reference/#kernpy.export","title":"<code>export(document, options)</code>","text":"<p>Export a Document object to a string.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to export</p> required <code>options</code> <code>ExportOptions</code> <p>Export options</p> required <p>Returns: Exported string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; options = kp.ExportOptions()\n&gt;&gt;&gt; content = kp.export(document, options)\n</code></pre>"},{"location":"reference/#kernpy.get_kern_from_ekern","title":"<code>get_kern_from_ekern(ekern_content)</code>","text":"<p>Read the content of a ekern file and return the kern content.</p> <p>Parameters:</p> Name Type Description Default <code>ekern_content</code> <code>str</code> <p>The content of the **ekern file.</p> required <p>Returns:     The content of the **kern file.</p> Example <pre><code># Read **ekern file\nekern_file = 'path/to/file.ekrn'\nwith open(ekern_file, 'r') as file:\n    ekern_content = file.read()\n\n# Get **kern content\nkern_content = get_kern_from_ekern(ekern_content)\nwith open('path/to/file.krn', 'w') as file:\n    file.write(kern_content)\n\n</code></pre>"},{"location":"reference/#kernpy.get_spine_types","title":"<code>get_spine_types(document, spine_types=None)</code>","text":"<p>Get the spines of a Document object.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to get spines from</p> required <code>spine_types</code> <code>Optional[Sequence[str]]</code> <p>List of spine types to get. If None, all spines are returned.</p> <code>None</code> <p>Returns (List[str]): List of spines</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n&gt;&gt;&gt; kp.get_spine_types(document)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern'])\n['**kern', '**kern', '**kern', '**kern']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root'])\n['**kern', '**kern', '**kern', '**kern', '**root']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root', '**harm'])\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, [])\n[]\n</code></pre>"},{"location":"reference/#kernpy.graph","title":"<code>graph(document, fp)</code>","text":"<p>Create a graph representation of a Document object using Graphviz. Save the graph as a .dot file or indicate the     output file path or stream. If the output file path is None, the function will return the graphviz content as a        string to the standard output.</p> <p>Use the Graphviz software to convert the .dot file to an image.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>The Document object to export as a graphviz file.</p> required <code>fp</code> <code>Optional[Union[str, Path]]</code> <p>The file path to write the graphviz file. If None, the function will return the            graphviz content as a string to the standard output.</p> required <p>Returns (None): None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.load('score.krn')\n&gt;&gt;&gt; kp.graph(document, 'score.dot')\nNone\n&gt;&gt;&gt; # File 'score.dot' will be created with the graphviz representation of the Document object.\n&gt;&gt;&gt; kp.graph(document, None)\n'digraph G { ... }'\n</code></pre>"},{"location":"reference/#kernpy.kern_to_ekern","title":"<code>kern_to_ekern(input_file, output_file)</code>","text":"<p>Convert one .krn file to .ekrn file</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Filepath to the input **kern</p> required <code>output_file</code> <code>str</code> <p>Filepath to the output **ekern</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example"},{"location":"reference/#kernpy.kern_to_ekern--convert-krn-to-ekrn","title":"Convert .krn to .ekrn","text":"<p>kern_to_ekern('path/to/file.krn', 'path/to/file.ekrn')</p>"},{"location":"reference/#kernpy.kern_to_ekern--convert-a-list-of-krn-files-to-ekrn-files","title":"Convert a list of .krn files to .ekrn files","text":"<pre><code>krn_files = your_module.get_files()\n\n# Use the wrapper to avoid stopping the process if an error occurs\ndef kern_to_ekern_wrapper(krn_file, ekern_file):\n    try:\n        kern_to_ekern(krn_file, ekern_file)\n    except Exception as e:\n        print(f'Error:{e}')\n\n# Convert all the files\nfor krn_file in krn_files:\n    output_file = krn_file.replace('.krn', '.ekrn')\n    kern_to_ekern_wrapper(krn_file, output_file)\n</code></pre>"},{"location":"reference/#kernpy.load","title":"<code>load(fp, *, raise_on_errors=False, **kwargs)</code>","text":"<p>Load a Document object from a Humdrum **kern file-like object.</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Union[str, Path]</code> <p>A path-like object representing a **kern file.</p> required <code>raise_on_errors</code> <code>Optional[bool]</code> <p>If True, raise an exception if any grammar error is detected            during parsing.</p> <code>False</code> <p>Returns ((Document, List[str])): A tuple containing the Document object and a list of messages representing         grammar errors detected during parsing. If the list is empty,        the parsing did not detect any errors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Humdrum **kern representation could not be parsed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.load('BWV565.krn')\n&gt;&gt;&gt; if len(errors) &gt; 0:\n&gt;&gt;&gt;     print(f\"Grammar didn't recognize the following errors: {errors}\")\n['Error: Invalid **kern spine: 1', 'Error: Invalid **kern spine: 2']\n&gt;&gt;&gt;     # Anyway, we can use the Document\n&gt;&gt;&gt;     print(document)\n&gt;&gt;&gt; else:\n&gt;&gt;&gt;     print(document)\n&lt;kernpy.core.document.Document object at 0x7f8b3b7b3d90&gt;\n</code></pre>"},{"location":"reference/#kernpy.loads","title":"<code>loads(s, *, raise_on_errors=False, **kwargs)</code>","text":"<pre><code>Load a Document object from a string encoded in Humdrum **kern.\n\nArgs:\n    s (str): A string containing a **kern file.\n    raise_on_errors (Optional[bool], optional): If True, raise an exception if any grammar error is detected            during parsing.\n\nReturns ((Document, List[str])): A tuple containing the Document object and a list of messages representing         grammar errors detected during parsing. If the list is empty,        the parsing did not detect any errors.\n\nRaises:\n    ValueError: If the Humdrum **kern representation could not be parsed.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; document, errors = kp.loads('**kern\n</code></pre> <p>clefG2 =1 4c 4d 4e 4f ')         &gt;&gt;&gt; if len(errors) &gt; 0:         &gt;&gt;&gt;     print(f\"Grammar didn't recognize the following errors: {errors}\")         ['Error: Invalid *kern spine: 1']         &gt;&gt;&gt;     # Anyway, we can use the Document         &gt;&gt;&gt;     print(document)         &gt;&gt;&gt; else:         &gt;&gt;&gt;     print(document)"},{"location":"reference/#kernpy.merge","title":"<code>merge(contents, *, raise_on_errors=False)</code>","text":"<pre><code>Merge multiple **kern fragments into a single **kern string.      All the fragments should be presented in order. Each fragment does not need to be a complete **kern file. \nWarnings:\n    Processing a large number of files in a row may take some time.\n     This method performs as many `kp.read` operations as there are fragments to concatenate.\nArgs:\n    contents (Sequence[str]): List of **kern strings\n    raise_on_errors (Optional[bool], optional): If True, raise an exception if any grammar error is detected            during parsing.\n\nReturns (Tuple[Document, List[Tuple[int, int]]]): Document object and       and a List of Pairs (Tuple[int, int]) representing the measure fragment indexes of the concatenated document.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; contents = ['**kern\n</code></pre> <p>4e 4f 4g - -', 'kern 4a 4b 4c - = -', 'kern 4d 4e 4f - -']         &gt;&gt;&gt; document, indexes = kp.concat(contents)         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; document, indexes = kp.concat(contents, separator=' ')         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; document, indexes = kp.concat(contents, separator='')         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; for start, end in indexes:         &gt;&gt;&gt;     print(kp.dumps(document, from_measure=start, to_measure=end)))</p>"},{"location":"reference/#kernpy.read","title":"<code>read(path, strict=False)</code>","text":"<p>Read a Humdrum **kern file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>File path to read</p> required <code>strict</code> <code>Optional[bool]</code> <p>If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.</p> <code>False</code> <p>Returns (Document, List[str]): Document object and list of error messages. Empty list if no errors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n</code></pre> <pre><code>&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; if len(errors) &gt; 0:\n&gt;&gt;&gt;     print(errors)\n['Error: Invalid **kern spine: 1', 'Error: Invalid **kern spine: 2']\n</code></pre>"},{"location":"reference/#kernpy.spine_types","title":"<code>spine_types(document, headers=None)</code>","text":"<p>Get the spines of a Document object.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to get spines from</p> required <code>headers</code> <code>Optional[Sequence[str]]</code> <p>List of spine types to get. If None, all spines are returned. Using a          header will return all the spines of that type.</p> <code>None</code> <p>Returns (List[str]): List of spines</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n&gt;&gt;&gt; kp.spine_types(document)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.spine_types(document, None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.spine_types(document, headers=None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.spine_types(document, headers=['**kern'])\n['**kern', '**kern', '**kern', '**kern']\n&gt;&gt;&gt; kp.spine_types(document, headers=['**kern', '**root'])\n['**kern', '**kern', '**kern', '**kern', '**root']\n&gt;&gt;&gt; kp.spine_types(document, headers=['**kern', '**root', '**harm'])\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.spine_types(document, headers=[])\n[]\n</code></pre>"},{"location":"reference/#kernpy.store","title":"<code>store(document, path, options)</code>","text":"<p>Store a Document object to a file.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to store</p> required <code>path</code> <code>Union[str, Path]</code> <p>File path to store</p> required <code>options</code> <code>ExportOptions</code> <p>Export options</p> required <p>Returns: None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; options = kp.ExportOptions()\n&gt;&gt;&gt; kp.store(document, 'path/to/store.krn', options)\n</code></pre>"},{"location":"reference/#kernpy.store_graph","title":"<code>store_graph(document, path)</code>","text":"<p>Create a graph representation of a Document object using Graphviz. Save the graph to a file.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to create graph from</p> required <code>path</code> <code>str</code> <p>File path to save the graph</p> required <p>Returns (None): None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; kp.store_graph(document, 'path/to/graph.dot')\n</code></pre>"},{"location":"reference/#kernpy.transpose","title":"<code>transpose(input_encoding, interval, input_format=NotationEncoding.HUMDRUM.value, output_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose a pitch by a given interval.</p> <p>The pitch must be in the American notation.</p> <p>Parameters:</p> Name Type Description Default <code>input_encoding</code> <code>str</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>input_format</code> <code>str</code> <p>The encoding format of the pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>output_format</code> <code>str</code> <p>The encoding format of the transposed pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>str</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', output_format='kern')\n'fff'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\n'fff'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\n'gg'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction=Direction.DOWN.value)\n'gg'\n&gt;&gt;&gt; transpose('ccc#', IntervalsByName['P4'])\n'fff#'\n&gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format='american')\n'Bb4'\n&gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format=NotationEncoding.AMERICAN.value)\n'Bb4'\n&gt;&gt;&gt; transpose('C3', IntervalsByName['P4'], input_format='american', direction='down')\n'G2'\n</code></pre>"},{"location":"reference/#kernpy.transpose_agnostic_to_encoding","title":"<code>transpose_agnostic_to_encoding(agnostic_pitch, interval, output_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose an AgnosticPitch by a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>agnostic_pitch</code> <code>AgnosticPitch</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>output_format</code> <code>Optional[str]</code> <p>The encoding format of the transposed pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>Optional[str]</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns (str):     str: The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'])\n'F4'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\n'G3'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C#', 4), IntervalsByName['P4'])\n'F#4'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\n'Bb4'\n</code></pre>"},{"location":"reference/#kernpy.transpose_agnostics","title":"<code>transpose_agnostics(input_pitch, interval, direction=Direction.UP.value)</code>","text":"<p>Transpose an AgnosticPitch by a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>input_pitch</code> <code>AgnosticPitch</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>direction</code> <code>str</code> <p>The direction of the transposition. 'UP' or 'DOWN'. Default is 'UP'.</p> <code>UP.value</code> Returns <p>AgnosticPitch: The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'])\nAgnosticPitch('F', 4)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\nAgnosticPitch('G', 3)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C#', 4), IntervalsByName['P4'])\nAgnosticPitch('F#', 4)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\nAgnosticPitch('Bb', 4)\n</code></pre>"},{"location":"reference/#kernpy.transpose_encoding_to_agnostic","title":"<code>transpose_encoding_to_agnostic(input_encoding, interval, input_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose a pitch by a given interval.</p> <p>The pitch must be in the American notation.</p> <p>Parameters:</p> Name Type Description Default <code>input_encoding</code> <code>str</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>input_format</code> <code>str</code> <p>The encoding format of the pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>str</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns:</p> Name Type Description <code>AgnosticPitch</code> <code>AgnosticPitch</code> <p>The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern')\nAgnosticPitch('fff', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\nAgnosticPitch('fff', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\nAgnosticPitch('gg', 3)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc#', IntervalsByName['P4'])\nAgnosticPitch('fff#', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('G4', IntervalsByName['m3'], input_format='american')\nAgnosticPitch('Bb4', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('C3', IntervalsByName['P4'], input_format='american', direction='down')\nAgnosticPitch('G2', 2)\n</code></pre>"},{"location":"reference/#modules","title":"Modules","text":"<p>kernpy.core</p> <p>=====</p> <p>This module contains the core functionality of the <code>kernpy</code> package.</p> <p>kernpy.util</p> <p>=====</p> <p>This module contains utility functions for the kernpy package.</p>"},{"location":"reference/#kernpy.core.Intervals","title":"<code>Intervals = {-2: 'dd1', -1: 'd1', 0: 'P1', 1: 'A1', 2: 'AA1', 3: 'dd2', 4: 'd2', 5: 'm2', 6: 'M2', 7: 'A2', 8: 'AA2', 9: 'dd3', 10: 'd3', 11: 'm3', 12: 'M3', 13: 'A3', 14: 'AA3', 15: 'dd4', 16: 'd4', 17: 'P4', 18: 'A4', 19: 'AA4', 21: 'dd5', 22: 'd5', 23: 'P5', 24: 'A5', 25: 'AA5', 26: 'dd6', 27: 'd6', 28: 'm6', 29: 'M6', 30: 'A6', 31: 'AA6', 32: 'dd7', 33: 'd7', 34: 'm7', 35: 'M7', 36: 'A7', 37: 'AA7', 40: 'octave'}</code>  <code>module-attribute</code>","text":"<p>Base-40 interval classes (d=diminished, m=minor, M=major, P=perfect, A=augmented)</p>"},{"location":"reference/#kernpy.core.AbstractToken","title":"<code>AbstractToken</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class representing a token.</p> <p>This class serves as a blueprint for creating various types of tokens, which are categorized based on their TokenCategory.</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> <code>category</code> <code>TokenCategory</code> <p>The category of the token.</p> <code>hidden</code> <code>bool</code> <p>A flag indicating whether the token is hidden. Defaults to False.</p>"},{"location":"reference/#kernpy.core.AbstractToken.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two tokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>AbstractToken</code> <p>The other token to compare.</p> required <p>Returns (bool): True if the tokens are equal, False otherwise.</p>"},{"location":"reference/#kernpy.core.AbstractToken.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the token.</p> <p>Returns (int): The hash of the token.</p>"},{"location":"reference/#kernpy.core.AbstractToken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>AbstractToken constructor</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>category</code> <code>TokenCategory</code> <p>The category of the token.</p> required"},{"location":"reference/#kernpy.core.AbstractToken.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two tokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>AbstractToken</code> <p>The other token to compare.</p> required <p>Returns (bool): True if the tokens are different, False otherwise.</p>"},{"location":"reference/#kernpy.core.AbstractToken.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the token.</p> <p>Returns (str): The string representation of the token without processing.</p>"},{"location":"reference/#kernpy.core.AbstractToken.export","title":"<code>export(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded token representation, potentially filtered if a filter_categories function is provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token = AbstractToken('*clefF4', TokenCategory.SIGNATURES)\n&gt;&gt;&gt; token.export()\n'*clefF4'\n&gt;&gt;&gt; token.export(filter_categories=lambda cat: cat in {TokenCategory.SIGNATURES, TokenCategory.SIGNATURES.DURATION})\n'*clefF4'\n</code></pre>"},{"location":"reference/#kernpy.core.AgnosticPitch","title":"<code>AgnosticPitch</code>","text":"<p>Represents a pitch in a generic way, independent of the notation system used.</p>"},{"location":"reference/#kernpy.core.AgnosticPitch.__init__","title":"<code>__init__(name, octave)</code>","text":"<p>Initialize the AgnosticPitch object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the pitch (e.g., 'C', 'D#', 'Bb').</p> required <code>octave</code> <code>int</code> <p>The octave of the pitch (e.g., 4 for middle C).</p> required"},{"location":"reference/#kernpy.core.Alteration","title":"<code>Alteration</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for the alteration of a pitch.</p>"},{"location":"reference/#kernpy.core.BarToken","title":"<code>BarToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>BarToken class.</p>"},{"location":"reference/#kernpy.core.BekernTokenizer","title":"<code>BekernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>BekernTokenizer converts a Token into a bekern (Basic Extended **kern) string representation. This format use a '@' separator for the     main tokens but discards all the decorations tokens.</p>"},{"location":"reference/#kernpy.core.BekernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new BekernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required"},{"location":"reference/#kernpy.core.BekernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a bekern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): bekern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; BekernTokenizer().tokenize(token)\n'2@.@bb@-'\n</code></pre>"},{"location":"reference/#kernpy.core.BkernTokenizer","title":"<code>BkernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>BkernTokenizer converts a Token into a bkern (Basic kern) string representation. This format use     the main tokens but not the decorations tokens. This format is a lightweight version of the classic Humdrum kern format.</p>"},{"location":"reference/#kernpy.core.BkernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new BkernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required"},{"location":"reference/#kernpy.core.BkernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a bkern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): bkern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; BkernTokenizer().tokenize(token)\n'2.bb-'\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBox","title":"<code>BoundingBox</code>","text":"<p>BoundingBox class.</p> <p>It contains the coordinates of the score bounding box. Useful for full-page tasks.</p> <p>Attributes:</p> Name Type Description <code>from_x</code> <code>int</code> <p>The x coordinate of the top left corner</p> <code>from_y</code> <code>int</code> <p>The y coordinate of the top left corner</p> <code>to_x</code> <code>int</code> <p>The x coordinate of the bottom right corner</p> <code>to_y</code> <code>int</code> <p>The y coordinate of the bottom right corner</p>"},{"location":"reference/#kernpy.core.BoundingBox.__init__","title":"<code>__init__(x, y, w, h)</code>","text":"<p>BoundingBox constructor.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x coordinate of the top left corner</p> required <code>y</code> <code>int</code> <p>The y coordinate of the top left corner</p> required <code>w</code> <code>int</code> <p>The width</p> required <code>h</code> <code>int</code> <p>The height</p> required"},{"location":"reference/#kernpy.core.BoundingBox.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the bounding box</p> <p>Returns (str): The string representation of the bounding box</p>"},{"location":"reference/#kernpy.core.BoundingBox.extend","title":"<code>extend(bounding_box)</code>","text":"<p>Extends the bounding box. Modify the current object.</p> <p>Parameters:</p> Name Type Description Default <code>bounding_box</code> <code>BoundingBox</code> <p>The bounding box to extend</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p>"},{"location":"reference/#kernpy.core.BoundingBox.h","title":"<code>h()</code>","text":"<p>Returns the height of the box</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The height of the box</p> <p>return self.to_y - self.from_y</p>"},{"location":"reference/#kernpy.core.BoundingBox.w","title":"<code>w()</code>","text":"<p>Returns the width of the box</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The width of the box</p>"},{"location":"reference/#kernpy.core.BoundingBox.xywh","title":"<code>xywh()</code>","text":"<p>Returns a string representation of the bounding box.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation of the bounding box</p>"},{"location":"reference/#kernpy.core.BoundingBoxMeasures","title":"<code>BoundingBoxMeasures</code>","text":"<p>BoundingBoxMeasures class.</p>"},{"location":"reference/#kernpy.core.BoundingBoxMeasures.__init__","title":"<code>__init__(bounding_box, from_measure, to_measure)</code>","text":"<p>Create an instance of BoundingBoxMeasures.</p> <p>Parameters:</p> Name Type Description Default <code>bounding_box</code> <p>The bounding box object of the node.</p> required <code>from_measure</code> <code>int</code> <p>The first measure of the score in the BoundingBoxMeasures object.</p> required <code>to_measure</code> <code>int</code> <p>The last measure of the score in the BoundingBoxMeasures object.</p> required"},{"location":"reference/#kernpy.core.BoundingBoxToken","title":"<code>BoundingBoxToken</code>","text":"<p>               Bases: <code>Token</code></p> <p>BoundingBoxToken class.</p> <p>It contains the coordinates of the score bounding box. Useful for full-page tasks.</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> <code>page_number</code> <code>int</code> <p>The page number</p> <code>bounding_box</code> <code>BoundingBox</code> <p>The bounding box</p>"},{"location":"reference/#kernpy.core.BoundingBoxToken.__init__","title":"<code>__init__(encoding, page_number, bounding_box)</code>","text":"<p>BoundingBoxToken constructor.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>page_number</code> <code>int</code> <p>The page number</p> required <code>bounding_box</code> <code>BoundingBox</code> <p>The bounding box</p> required"},{"location":"reference/#kernpy.core.C1Clef","title":"<code>C1Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.core.C1Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p>"},{"location":"reference/#kernpy.core.C1Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.core.C2Clef","title":"<code>C2Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.core.C2Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p>"},{"location":"reference/#kernpy.core.C2Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.core.C3Clef","title":"<code>C3Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.core.C3Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p>"},{"location":"reference/#kernpy.core.C3Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.core.C4Clef","title":"<code>C4Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.core.C4Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p>"},{"location":"reference/#kernpy.core.C4Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.core.ChordToken","title":"<code>ChordToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>ChordToken class.</p> <p>It contains a list of compound tokens</p>"},{"location":"reference/#kernpy.core.ChordToken.__init__","title":"<code>__init__(encoding, category, notes_tokens)</code>","text":"<p>ChordToken constructor.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>category</code> <code>TokenCategory</code> <p>The token category, one of TokenCategory</p> required <code>notes_tokens</code> <code>Sequence[Token]</code> <p>The subtokens for the notes. Individual elements of the token, of type token</p> required"},{"location":"reference/#kernpy.core.Clef","title":"<code>Clef</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class representing a clef.</p>"},{"location":"reference/#kernpy.core.Clef.__init__","title":"<code>__init__(diatonic_pitch, on_line)</code>","text":"<p>Initializes the Clef object. Args:     diatonic_pitch (DiatonicPitch): The diatonic pitch of the clef (e.g., 'C', 'G', 'F'). This value is used as a decorator.     on_line (int): The line number on which the clef is placed (1 for bottom line, 2 for 1st line from bottom, etc.). This value is used as a decorator.</p>"},{"location":"reference/#kernpy.core.Clef.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation of the clef.</p>"},{"location":"reference/#kernpy.core.Clef.bottom_line","title":"<code>bottom_line()</code>  <code>abstractmethod</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.core.Clef.name","title":"<code>name()</code>","text":"<p>Returns the name of the clef.</p>"},{"location":"reference/#kernpy.core.Clef.reference_point","title":"<code>reference_point()</code>","text":"<p>Returns the reference point for the clef.</p>"},{"location":"reference/#kernpy.core.ClefToken","title":"<code>ClefToken</code>","text":"<p>               Bases: <code>SignatureToken</code></p> <p>ClefToken class.</p>"},{"location":"reference/#kernpy.core.ComplexToken","title":"<code>ComplexToken</code>","text":"<p>               Bases: <code>Token</code>, <code>ABC</code></p> <p>Abstract ComplexToken class. This abstract class ensures that the subclasses implement the export method using     the 'filter_categories' parameter to filter the subtokens.</p> <p>Passing the argument 'filter_categories' by **kwargs don't break the compatibility with parent classes.</p> <p>Here we're trying to get the Liskov substitution principle done...</p>"},{"location":"reference/#kernpy.core.ComplexToken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>Constructor for the ComplexToken</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>category</code> <code>TokenCategory) </code> <p>The category of the token.</p> required"},{"location":"reference/#kernpy.core.ComplexToken.export","title":"<code>export(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p>"},{"location":"reference/#kernpy.core.CompoundToken","title":"<code>CompoundToken</code>","text":"<p>               Bases: <code>ComplexToken</code></p>"},{"location":"reference/#kernpy.core.CompoundToken.__init__","title":"<code>__init__(encoding, category, subtokens)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>category</code> <code>TokenCategory</code> <p>The token category, one of 'TokenCategory'</p> required <code>subtokens</code> <code>List[Subtoken]</code> <p>The individual elements of the token. Also of type 'TokenCategory' but                 in the hierarchy they must be children of the current token.</p> required"},{"location":"reference/#kernpy.core.CompoundToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p>"},{"location":"reference/#kernpy.core.Document","title":"<code>Document</code>","text":"<p>Document class.</p> <p>This class store the score content using an agnostic tree structure.</p> <p>Attributes:</p> Name Type Description <code>tree</code> <code>MultistageTree</code> <p>The tree structure of the document where all the nodes are stored.             Each stage of the tree corresponds to a row in the Humdrum **kern file encoding.</p> <code>measure_start_tree_stages</code> <code>List[List[Node]]</code> <p>The list of nodes that corresponds to the measures.             Empty list by default. The index of the list is starting from 1. Rows after removing empty lines and line comments</p> <code>page_bounding_boxes</code> <code>Dict[int, BoundingBoxMeasures]</code> <p>The dictionary of page bounding boxes.             - key: page number - value: BoundingBoxMeasures object</p> <code>header_stage</code> <code>int</code> <p>The index of the stage that contains the headers. None by default.</p>"},{"location":"reference/#kernpy.core.Document.__init__","title":"<code>__init__(tree)</code>","text":"<p>Constructor for Document class.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>MultistageTree</code> <p>The tree structure of the document where all the nodes are stored.</p> required"},{"location":"reference/#kernpy.core.Document.__iter__","title":"<code>__iter__()</code>","text":"<p>Get the indexes to export all the document.</p> <p>Returns: An iterator with the indexes to export the document.</p>"},{"location":"reference/#kernpy.core.Document.__next__","title":"<code>__next__()</code>","text":"<p>Get the next index to export the document.</p> <p>Returns: The next index to export the document.</p>"},{"location":"reference/#kernpy.core.Document.add","title":"<code>add(other, *, check_core_spines_only=False)</code>","text":"<p>Concatenate one document to the current document: Modify the current object!</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'Document'</code> <p>The document to concatenate.</p> required <code>check_core_spines_only</code> <code>Optional[bool]</code> <p>If True, only the core spines (kern and mens) are checked. If False, all spines are checked.</p> <code>False</code> <p>Returns ('Document'): The current document (self) with the other document concatenated.</p>"},{"location":"reference/#kernpy.core.Document.append_spines","title":"<code>append_spines(spines)</code>","text":"<pre><code>    Append the spines directly to current document tree.\n\n    Args:\n        spines(list): A list of spines to append.\n\n    Returns: None\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; doc, _ = kp.read('score.krn')\n        &gt;&gt;&gt; spines = [\n        &gt;&gt;&gt; '4e     4f      4g      4a\n</code></pre> <p>4b      4c      4d      4e =       =       =       = ',             &gt;&gt;&gt; '4c     4d      4e      4f 4g      4a      4b      4c =       =       =       = ',            &gt;&gt;&gt; ]            &gt;&gt;&gt; doc.append_spines(spines)            None</p>"},{"location":"reference/#kernpy.core.Document.clone","title":"<code>clone()</code>","text":"<p>Create a deep copy of the Document instance.</p> <p>Returns: A new instance of Document with the tree copied.</p>"},{"location":"reference/#kernpy.core.Document.frequencies","title":"<code>frequencies(token_categories=None)</code>","text":"<p>Frequency of tokens in the document.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>If None, all tokens are considered.</p> <code>None</code> <p>Returns (Dict):     A dictionary with the category and the number of occurrences of each token.</p>"},{"location":"reference/#kernpy.core.Document.get_all_tokens","title":"<code>get_all_tokens(filter_by_categories=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AbstractToken]</code> <p>List[AbstractToken] - A list of all tokens.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n&gt;&gt;&gt; [type(t) for t in tokens]\n[&lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;]\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_all_tokens_encodings","title":"<code>get_all_tokens_encodings(filter_by_categories=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str] - A list of all token encodings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens_encodings()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_first_measure","title":"<code>get_first_measure()</code>","text":"<p>Get the index of the first measure of the document.</p> <p>Returns: (Int) The index of the first measure of the document.</p> <p>Raises: Exception - If the document has no measures.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, err = kp.read('score.krn')\n&gt;&gt;&gt; document.get_first_measure()\n1\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_header_nodes","title":"<code>get_header_nodes()</code>","text":"<p>Get the header nodes of the current document.</p> <p>Returns: List[HeaderToken]: A list with the header nodes of the current document.</p>"},{"location":"reference/#kernpy.core.Document.get_header_stage","title":"<code>get_header_stage()</code>","text":"<p>Get the Node list of the header stage.</p> <p>Returns: (Union[List[Node], List[List[Node]]]) The Node list of the header stage.</p> <p>Raises: Exception - If the document has no header stage.</p>"},{"location":"reference/#kernpy.core.Document.get_leaves","title":"<code>get_leaves()</code>","text":"<p>Get the leaves of the tree.</p> <p>Returns: (List[Node]) The leaves of the tree.</p>"},{"location":"reference/#kernpy.core.Document.get_metacomments","title":"<code>get_metacomments(KeyComment=None, clear=False)</code>","text":"<p>Get all metacomments in the document</p> <p>Parameters:</p> Name Type Description Default <code>KeyComment</code> <code>Optional[str]</code> <p>Filter by a specific metacomment key: e.g. Use 'COM' to get only comments starting with                '!!!COM: '. If None, all metacomments are returned.</p> <code>None</code> <code>clear</code> <code>bool</code> <p>If True, the metacomment key is removed from the comment. E.g. '!!!COM: Coltrane' -&gt; 'Coltrane'.                If False, the metacomment key is kept. E.g. '!!!COM: Coltrane' -&gt; '!!!COM: Coltrane'.                 The clear functionality is equivalent to the following code:</p> <pre><code>comment = '!!!COM: Coltrane'\nclean_comment = comment.replace(f\"!!!{KeyComment}: \", \"\")\n</code></pre> <p>Other formats are not supported.</p> <code>False</code> <p>Returns: A list of metacomments.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_metacomments()\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='COM')\n['!!!COM: Coltrane']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='COM', clear=True)\n['Coltrane']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='non_existing_key')\n[]\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_spine_count","title":"<code>get_spine_count()</code>","text":"<p>Get the number of spines in the document.</p> <p>Returns (int): The number of spines in the document.</p>"},{"location":"reference/#kernpy.core.Document.get_spine_ids","title":"<code>get_spine_ids()</code>","text":"<p>Get the indexes of the current document.</p> <p>Returns List[int]: A list with the indexes of the current document.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_all_spine_indexes()\n[0, 1, 2, 3, 4]\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_unique_token_encodings","title":"<code>get_unique_token_encodings(filter_by_categories=None)</code>","text":"<p>Get unique token encodings.</p> <p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns: List[str] - A list of unique token encodings.</p>"},{"location":"reference/#kernpy.core.Document.get_unique_tokens","title":"<code>get_unique_tokens(filter_by_categories=None)</code>","text":"<p>Get unique tokens.</p> <p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AbstractToken]</code> <p>List[AbstractToken] - A list of unique tokens.</p>"},{"location":"reference/#kernpy.core.Document.get_voices","title":"<code>get_voices(clean=False)</code>","text":"<p>Get the voices of the document.</p> <p>Args     clean (bool): Remove the first '!' from the voice name.</p> <p>Returns: A list of voices.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_voices()\n['!sax', '!piano', '!bass']\n&gt;&gt;&gt; document.get_voices(clean=True)\n['sax', 'piano', 'bass']\n&gt;&gt;&gt; document.get_voices(clean=False)\n['!sax', '!piano', '!bass']\n</code></pre>"},{"location":"reference/#kernpy.core.Document.match","title":"<code>match(a, b, *, check_core_spines_only=False)</code>  <code>classmethod</code>","text":"<p>Match two documents. Two documents match if they have the same spine structure.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Document</code> <p>The first document.</p> required <code>b</code> <code>Document</code> <p>The second document.</p> required <code>check_core_spines_only</code> <code>Optional[bool]</code> <p>If True, only the core spines (kern and mens) are checked. If False, all spines are checked.</p> <code>False</code> <p>Returns: True if the documents match, False otherwise.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.core.Document.measures_count","title":"<code>measures_count()</code>","text":"<p>Get the index of the last measure of the document.</p> <p>Returns: (Int) The index of the last measure of the document.</p> <p>Raises: Exception - If the document has no measures.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document, _ = kernpy.read('score.krn')\n&gt;&gt;&gt; document.measures_count()\n10\n&gt;&gt;&gt; for i in range(document.get_first_measure(), document.measures_count() + 1):\n&gt;&gt;&gt;   options = kernpy.ExportOptions(from_measure=i, to_measure=i+4)\n</code></pre>"},{"location":"reference/#kernpy.core.Document.split","title":"<code>split()</code>","text":"<p>Split the current document into a list of documents, one for each kern spine. Each resulting document will contain one kern spine along with all non-kern spines.</p> <p>Returns:</p> Type Description <code>List['Document']</code> <p>List['Document']: A list of documents, where each document contains one **kern spine</p> <code>List['Document']</code> <p>and all non-kern spines from the original document.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.split()\n[&lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;]\n</code></pre>"},{"location":"reference/#kernpy.core.Document.to_concat","title":"<code>to_concat(first_doc, second_doc, deep_copy=True)</code>  <code>classmethod</code>","text":"<p>Concatenate two documents.</p> <p>Parameters:</p> Name Type Description Default <code>first_doc</code> <code>Document</code> <p>The first document.</p> required <code>second_doc</code> <code>Document</code> <p>The second document.</p> required <code>deep_copy</code> <code>bool</code> <p>If True, the documents are deep copied. If False, the documents are shallow copied.</p> <code>True</code> <p>Returns: A new instance of Document with the documents concatenated.</p>"},{"location":"reference/#kernpy.core.Document.tokens_to_encodings","title":"<code>tokens_to_encodings(tokens)</code>  <code>classmethod</code>","text":"<p>Get the encodings of a list of tokens.</p> The method is equivalent to the following code <p>tokens = kp.get_all_tokens() [token.encoding for token in tokens if token.encoding is not None]</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>Sequence[AbstractToken]</code> <p>list - A list of tokens.</p> required <p>Returns: List[str] - A list of token encodings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n</code></pre>"},{"location":"reference/#kernpy.core.Duration","title":"<code>Duration</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Represents the duration of a note or a rest.</p> <p>The duration is represented using the Humdrum Kern format. The duration is a number that represents the number of units of the duration.</p> <p>The duration of a whole note is 1, half note is 2, quarter note is 4, eighth note is 8, etc.</p> <p>The duration of a note is represented by a number. The duration of a rest is also represented by a number.</p> <p>This class do not limit the duration ranges.</p> <p>In the following example, the duration is represented by the number '2'.</p> <pre><code>**kern\n*clefG2\n2c          // whole note\n4c          // half note\n8c          // quarter note\n16c         // eighth note\n*-\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical","title":"<code>DurationClassical</code>","text":"<p>               Bases: <code>Duration</code></p> <p>Represents the duration in classical notation of a note or a rest.</p>"},{"location":"reference/#kernpy.core.DurationClassical.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool): True if the durations are equal, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration == duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration == duration2\nFalse\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is higher or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt;= duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &gt;= duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt;= duration2\nTrue\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'DurationClassical'</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is higher than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt; duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &gt; duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt; duration2\nFalse\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__init__","title":"<code>__init__(duration)</code>","text":"<p>Create a new Duration object.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>str</code> <p>duration representation in Humdrum Kern format</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(32)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(1)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(0)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(-2)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(3)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(7)\nFalse\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__le__","title":"<code>__le__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this duration is lower or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt;= duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &lt;= duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt;= duration2\nTrue\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is lower than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt; duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &lt; duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt; duration2\nFalse\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if the durations are different, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration != duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration != duration2\nTrue\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.modify","title":"<code>modify(ratio)</code>","text":"<p>Modify the duration of a note or a rest of the current object.</p> <p>Parameters:</p> Name Type Description Default <code>ratio</code> <code>int</code> <p>The factor to modify the duration. The factor must be greater than 0.</p> required <p>Returns (DurationClassical): The new duration object with the modified duration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(2)\n&gt;&gt;&gt; new_duration.duration\n4\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(0)\nTraceback (most recent call last):\n...\nValueError: Invalid factor provided: 0. The factor must be greater than 0.\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(-2)\nTraceback (most recent call last):\n...\nValueError: Invalid factor provided: -2. The factor must be greater than 0.\n</code></pre>"},{"location":"reference/#kernpy.core.DurationMensural","title":"<code>DurationMensural</code>","text":"<p>               Bases: <code>Duration</code></p> <p>Represents the duration in mensural notation of a note or a rest.</p>"},{"location":"reference/#kernpy.core.DynSpineImporter","title":"<code>DynSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.core.DynSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.core.DynamSpineImporter","title":"<code>DynamSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.core.DynamSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.core.EkernTokenizer","title":"<code>EkernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>EkernTokenizer converts a Token into an eKern (Extended **kern) string representation. This format use a '@' separator for the     main tokens and a '\u00b7' separator for the decorations tokens.</p>"},{"location":"reference/#kernpy.core.EkernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new EkernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>List[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required"},{"location":"reference/#kernpy.core.EkernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into an eKern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): eKern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; EkernTokenizer().tokenize(token)\n'2@.@bb@-\u00b7_\u00b7L'\n</code></pre>"},{"location":"reference/#kernpy.core.ErrorListener","title":"<code>ErrorListener</code>","text":"<p>               Bases: <code>ConsoleErrorListener</code></p>"},{"location":"reference/#kernpy.core.ErrorListener.__init__","title":"<code>__init__(*, verbose=False)</code>","text":"<p>ErrorListener constructor. Args:     verbose (bool): If True, the error messages will be printed to the console using             the <code>ConsoleErrorListener</code> interface.</p>"},{"location":"reference/#kernpy.core.ErrorToken","title":"<code>ErrorToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>Used to wrap tokens that have not been parsed.</p>"},{"location":"reference/#kernpy.core.ErrorToken.__init__","title":"<code>__init__(encoding, line, error)</code>","text":"<p>ErrorToken constructor</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>line</code> <code>int</code> <p>The line number of the token in the score.</p> required <code>error</code> <code>str</code> <p>The error message thrown by the parser.</p> required"},{"location":"reference/#kernpy.core.ErrorToken.__str__","title":"<code>__str__()</code>","text":"<p>Information about the error token.</p> <p>Returns (str) The information about the error token.</p>"},{"location":"reference/#kernpy.core.ErrorToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the error token.</p> <p>Returns (str): A string representation of the error token.</p>"},{"location":"reference/#kernpy.core.ExportOptions","title":"<code>ExportOptions</code>","text":"<p><code>ExportOptions</code> class.</p> <p>Store the options to export a **kern file.</p>"},{"location":"reference/#kernpy.core.ExportOptions.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two ExportOptions objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'ExportOptions'</code> <p>The other ExportOptions object to compare.</p> required <p>Returns (bool):     True if the objects are equal, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 == options2\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 == options3\nFalse\n</code></pre>"},{"location":"reference/#kernpy.core.ExportOptions.__init__","title":"<code>__init__(spine_types=None, token_categories=None, from_measure=None, to_measure=None, kern_type=KernTypeExporter.normalizedKern, instruments=None, show_measure_numbers=False, spine_ids=None)</code>","text":"<p>Create a new ExportOptions object.</p> <p>Parameters:</p> Name Type Description Default <code>spine_types</code> <code>Iterable</code> <p>kern, mens, etc...</p> <code>None</code> <code>token_categories</code> <code>Iterable</code> <p>TokenCategory</p> <code>None</code> <code>from_measure</code> <code>int</code> <p>The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1</p> <code>None</code> <code>to_measure</code> <code>int</code> <p>The measure to end exporting. When None, the exporter will end at the end of the file.</p> <code>None</code> <code>kern_type</code> <code>KernTypeExporter</code> <p>The type of the kern file to export.</p> <code>normalizedKern</code> <code>instruments</code> <code>Iterable</code> <p>The instruments to export. When None, all the instruments will be exported.</p> <code>None</code> <code>show_measure_numbers</code> <code>Bool</code> <p>Show the measure numbers in the exported file.</p> <code>False</code> <code>spine_ids</code> <code>Iterable</code> <p>The ids of the spines to export. When None, all the spines will be exported. Spines ids start from 0 and they are increased by 1.</p> <code>None</code> Example <p>import kernpy</p> <p>Create the importer and read the file</p> <p>hi = Importer() document = hi.import_file('file.krn') exporter = Exporter()</p> <p>Export the file with the specified options</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES) exported_data = exporter.export_string(document, options)</p> <p>Export only the lyrics</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LYRICS]) exported_data = exporter.export_string(document, options)</p> <p>Export the comments</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LINE_COMMENTS, TokenCategory.FIELD_COMMENTS]) exported_data = exporter.export_string(document, options)</p> <p>Export using the eKern version</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES, kern_type=KernTypeExporter.eKern) exported_data = exporter.export_string(document, options)</p>"},{"location":"reference/#kernpy.core.ExportOptions.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two ExportOptions objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>ExportOptions</code> <p>The other ExportOptions object to compare.</p> required <p>Returns (bool):     True if the objects are not equal, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 != options2\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 != options3\nTrue\n</code></pre>"},{"location":"reference/#kernpy.core.Exporter","title":"<code>Exporter</code>","text":""},{"location":"reference/#kernpy.core.Exporter.append_row","title":"<code>append_row(document, node, options, row)</code>","text":"<p>Append a row to the row list if the node accomplishes the requirements. Args:     document (Document): The document with the spines.     node (Node): The node to append.     options (ExportOptions): The export options to filter the token.     row (list): The row to append.</p> <p>Returns (bool): True if the row was appended. False if the row was not appended.</p>"},{"location":"reference/#kernpy.core.Exporter.compute_header_type","title":"<code>compute_header_type(node)</code>","text":"<p>Compute the header type of the node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node to compute.</p> required <p>Returns (Optional[Token]): The header type <code>Node</code>object. None if the current node is the header.</p>"},{"location":"reference/#kernpy.core.Exporter.export_options_validator","title":"<code>export_options_validator(document, options)</code>  <code>classmethod</code>","text":"<p>Validate the export options. Raise an exception if the options are invalid.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p><code>Document</code> - The document to export.</p> required <code>options</code> <code>ExportOptions</code> <p><code>ExportOptions</code> - The options to export the document.</p> required <p>Returns: None</p> Example <p>export_options_validator(document, options) ValueError: option from_measure must be &gt;=0 but -1 was found. export_options_validator(document, options2) None</p>"},{"location":"reference/#kernpy.core.Exporter.get_spine_types","title":"<code>get_spine_types(document, spine_types=None)</code>","text":"<p>Get the spine types from the document.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>The document with the spines.</p> required <code>spine_types</code> <code>list</code> <p>The spine types to export. If None, all the spine types will be exported.</p> <code>None</code> <p>Returns: A list with the spine types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exporter = Exporter()\n&gt;&gt;&gt; exporter.get_spine_types(document)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern'])\n['**kern', '**kern', '**kern', '**kern']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root'])\n['**kern', '**kern', '**kern', '**kern', '**root']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root', '**harm'])\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, [])\n[]\n</code></pre>"},{"location":"reference/#kernpy.core.F3Clef","title":"<code>F3Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.core.F3Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the F Clef object.</p>"},{"location":"reference/#kernpy.core.F3Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.core.F4Clef","title":"<code>F4Clef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.core.F4Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the F Clef object.</p>"},{"location":"reference/#kernpy.core.F4Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.core.FieldCommentToken","title":"<code>FieldCommentToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>FieldCommentToken class stores the metacomments of the score. Usually these are comments starting with <code>!!!</code>.</p>"},{"location":"reference/#kernpy.core.FingSpineImporter","title":"<code>FingSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.core.FingSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.core.GClef","title":"<code>GClef</code>","text":"<p>               Bases: <code>Clef</code></p>"},{"location":"reference/#kernpy.core.GClef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the G Clef object.</p>"},{"location":"reference/#kernpy.core.GClef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p>"},{"location":"reference/#kernpy.core.GKernExporter","title":"<code>GKernExporter</code>","text":""},{"location":"reference/#kernpy.core.GKernExporter.agnostic_position","title":"<code>agnostic_position(staff, pitch)</code>","text":"<p>Returns the agnostic position in staff for the given pitch.</p>"},{"location":"reference/#kernpy.core.GKernExporter.export","title":"<code>export(staff, pitch)</code>","text":"<p>Exports the given pitch to a graphic **kern encoding.</p>"},{"location":"reference/#kernpy.core.Generic","title":"<code>Generic</code>","text":"<p>Generic class.</p> <p>This class provides support to the public API for KernPy.</p> <p>The main functions implementation are provided here.</p>"},{"location":"reference/#kernpy.core.Generic.concat","title":"<code>concat(contents, separator=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Sequence[str]</code> required <code>separator</code> <code>Optional[str]</code> <code>None</code> <p>Returns:</p>"},{"location":"reference/#kernpy.core.Generic.create","title":"<code>create(content, strict=False)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> required <code>strict</code> <code>Optional[bool]</code> <code>False</code> <p>Returns:</p>"},{"location":"reference/#kernpy.core.Generic.export","title":"<code>export(document, options)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> required <code>options</code> <code>ExportOptions</code> required <p>Returns:</p>"},{"location":"reference/#kernpy.core.Generic.get_spine_types","title":"<code>get_spine_types(document, spine_types=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> required <code>spine_types</code> <code>Optional[Sequence[str]]</code> <code>None</code> <p>Returns:</p>"},{"location":"reference/#kernpy.core.Generic.merge","title":"<code>merge(contents, strict=False)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Sequence[str]</code> required <code>strict</code> <code>Optional[bool]</code> <code>False</code> <p>Returns:</p>"},{"location":"reference/#kernpy.core.Generic.parse_options_to_ExportOptions","title":"<code>parse_options_to_ExportOptions(**kwargs)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <code>{}</code> <p>Returns:</p>"},{"location":"reference/#kernpy.core.Generic.read","title":"<code>read(path, strict=False)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> required <code>strict</code> <code>Optional[bool]</code> <code>False</code> <p>Returns:</p>"},{"location":"reference/#kernpy.core.Generic.store","title":"<code>store(document, path, options)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> required <code>path</code> <code>Path</code> required <code>options</code> <code>ExportOptions</code> required <p>Returns:</p>"},{"location":"reference/#kernpy.core.Generic.store_graph","title":"<code>store_graph(document, path)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> required <code>path</code> <code>Path</code> required <p>Returns:</p>"},{"location":"reference/#kernpy.core.GraphvizExporter","title":"<code>GraphvizExporter</code>","text":""},{"location":"reference/#kernpy.core.GraphvizExporter.export_to_dot","title":"<code>export_to_dot(tree, filename=None)</code>","text":"<p>Export the given MultistageTree to DOT format.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>MultistageTree</code> <p>The tree to export.</p> required <code>filename</code> <code>Path or None</code> <p>The output file path. If None, prints to stdout.</p> <code>None</code>"},{"location":"reference/#kernpy.core.HarmSpineImporter","title":"<code>HarmSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.core.HarmSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.core.HeaderToken","title":"<code>HeaderToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>HeaderTokens class.</p>"},{"location":"reference/#kernpy.core.HeaderToken.__init__","title":"<code>__init__(encoding, spine_id)</code>","text":"<p>Constructor for the HeaderToken class.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>spine_id</code> <code>int</code> <p>The spine id of the token. The spine id is used to identify the token in the score.                The spine_id starts from 0 and increases by 1 for each new spine like the following example: kern  kern  kern dyn **text 0   1   2   3   4</p> required"},{"location":"reference/#kernpy.core.HeaderTokenGenerator","title":"<code>HeaderTokenGenerator</code>","text":"<p>HeaderTokenGenerator class.</p> <p>This class is used to translate the HeaderTokens to the specific tokenizer format.</p>"},{"location":"reference/#kernpy.core.HeaderTokenGenerator.new","title":"<code>new(*, token, type)</code>  <code>classmethod</code>","text":"<p>Create a new HeaderTokenGenerator object. Only accepts stardized Humdrum **kern encodings. </p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>HeaderToken</code> <p>The HeaderToken to be translated.</p> required <code>type</code> <code>KernTypeExporter</code> <p>The tokenizer to be used.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; header = HeaderToken('**kern', 0)\n&gt;&gt;&gt; header.encoding\n'**kern'\n&gt;&gt;&gt; new_header = HeaderTokenGenerator.new(token=header, type=KernTypeExporter.eKern)\n&gt;&gt;&gt; new_header.encoding\n'**ekern'\n</code></pre>"},{"location":"reference/#kernpy.core.HumdrumPitchImporter","title":"<code>HumdrumPitchImporter</code>","text":"<p>               Bases: <code>PitchImporter</code></p> <p>Represents the pitch in the Humdrum Kern format.</p> <p>The name is represented using the International Standard Organization (ISO) name notation. The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.</p> <p>The Humdrum Kern format uses the following name representation: 'c' = C4 'cc' = C5 'ccc' = C6 'cccc' = C7</p> <p>'C' = C3 'CC' = C2 'CCC' = C1</p> <p>This class do not limit the name ranges.</p> <p>In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.</p> <pre><code>**kern\n*clefG2\n2c          // C4\n2cc         // C5\n2ccc        // C6\n2C          // C3\n2CC         // C2\n2CCC        // C1\n*-\n</code></pre>"},{"location":"reference/#kernpy.core.Importer","title":"<code>Importer</code>","text":"<p>Importer class.</p> <p>Use this class to import the content from a file or a string to a <code>Document</code> object.</p>"},{"location":"reference/#kernpy.core.Importer.__init__","title":"<code>__init__()</code>","text":"<pre><code>    Create an instance of the importer.\n\n    Raises:\n        Exception: If the importer content is not a valid **kern file.\n\n    Examples:\n        # Create the importer\n        &gt;&gt;&gt; importer = Importer()\n\n        # Import the content from a file\n        &gt;&gt;&gt; document = importer.import_file('file.krn')\n\n        # Import the content from a string\n        &gt;&gt;&gt; document = importer.import_string(\"**kern\n</code></pre> <p>clefF4 c4 4d 4e 4f -\")</p>"},{"location":"reference/#kernpy.core.Importer.get_error_messages","title":"<code>get_error_messages()</code>","text":"<p>Get the error messages of the importer.</p> <p>Returns: str - The error messages split by a new line character.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.core.Importer.get_error_messages--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file(Path('file.krn'))\n&gt;&gt;&gt; print(importer.get_error_messages())\n'Error: Invalid token in row 1'\n</code></pre>"},{"location":"reference/#kernpy.core.Importer.has_errors","title":"<code>has_errors()</code>","text":"<p>Check if the importer has any errors.</p> <p>Returns: bool - True if the importer has errors, False otherwise.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.core.Importer.has_errors--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file(Path('file.krn'))    # file.krn has an error\n&gt;&gt;&gt; print(importer.has_errors())\nTrue\n&gt;&gt;&gt; importer.import_file(Path('file2.krn'))   # file2.krn has no errors\n&gt;&gt;&gt; print(importer.has_errors())\nFalse\n</code></pre>"},{"location":"reference/#kernpy.core.Importer.import_file","title":"<code>import_file(file_path)</code>","text":"<p>Import the content from the importer to the file. Args:     file_path: The path to the file.</p> <p>Returns:</p> Type Description <code>Document</code> <p>Document - The document with the imported content.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.core.Importer.import_file--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file('file.krn')\n</code></pre>"},{"location":"reference/#kernpy.core.Importer.import_string","title":"<code>import_string(text)</code>","text":"<pre><code>    Import the content from the content of the score in string format.\n\n    Args:\n        text: The content of the score in string format.\n\n    Returns:\n        Document - The document with the imported content.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_string(\"**kern\n</code></pre> <p>clefF4 c4 4d 4e 4f -\")             # Read the content from a file             &gt;&gt;&gt; with open('file.krn',  'r', newline='', encoding='utf-8', errors='ignore') as f: # We encourage you to use these open file options             &gt;&gt;&gt;     content = f.read()             &gt;&gt;&gt; importer.import_string(content)             &gt;&gt;&gt; document = importer.import_string(content)</p>"},{"location":"reference/#kernpy.core.InstrumentToken","title":"<code>InstrumentToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>InstrumentToken class stores the instruments of the score.</p> <p>These tokens usually look like <code>*I\"Organo</code>.</p>"},{"location":"reference/#kernpy.core.InstrumentToken.__init__","title":"<code>__init__(encoding)</code>","text":"<p>Constructor for the InstrumentToken</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> required"},{"location":"reference/#kernpy.core.KernSpineImporter","title":"<code>KernSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.core.KernSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.core.KernTokenizer","title":"<code>KernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>KernTokenizer converts a Token into a normalized kern string representation.</p>"},{"location":"reference/#kernpy.core.KernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new KernTokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required"},{"location":"reference/#kernpy.core.KernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a normalized kern string representation. This format is the classic Humdrum **kern representation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>Token to be tokenized.</p> required <p>Returns (str): Normalized kern string representation. This is the classic Humdrum **kern representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; KernTokenizer().tokenize(token)\n'2.bb-_L'\n</code></pre>"},{"location":"reference/#kernpy.core.KernTypeExporter","title":"<code>KernTypeExporter</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Options for exporting a kern file.</p> Example <p>import kernpy as kp</p>"},{"location":"reference/#kernpy.core.KernTypeExporter--load-a-file","title":"Load a file","text":"<p>doc, _ = kp.load('path/to/file.krn')</p>"},{"location":"reference/#kernpy.core.KernTypeExporter--save-the-file-using-the-specified-encoding","title":"Save the file using the specified encoding","text":"<p>exported_content = kp.dumps(tokenizer=kp.KernTypeExporter.normalizedKern)</p>"},{"location":"reference/#kernpy.core.KernTypeExporter.prefix","title":"<code>prefix()</code>","text":"<p>Get the prefix of the kern type.</p> <p>Returns (str): Prefix of the kern type.</p>"},{"location":"reference/#kernpy.core.KeySignatureToken","title":"<code>KeySignatureToken</code>","text":"<p>               Bases: <code>SignatureToken</code></p> <p>KeySignatureToken class.</p>"},{"location":"reference/#kernpy.core.KeyToken","title":"<code>KeyToken</code>","text":"<p>               Bases: <code>SignatureToken</code></p> <p>KeyToken class.</p>"},{"location":"reference/#kernpy.core.MHXMToken","title":"<code>MHXMToken</code>","text":"<p>               Bases: <code>Token</code></p> <p>MHXMToken class.</p>"},{"location":"reference/#kernpy.core.MensSpineImporter","title":"<code>MensSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.core.MensSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>MensSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.core.MetacommentToken","title":"<code>MetacommentToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>MetacommentToken class stores the metacomments of the score. Usually these are comments starting with <code>!!</code>.</p>"},{"location":"reference/#kernpy.core.MetacommentToken.__init__","title":"<code>__init__(encoding)</code>","text":"<p>Constructor for the MetacommentToken class.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required"},{"location":"reference/#kernpy.core.MeterSymbolToken","title":"<code>MeterSymbolToken</code>","text":"<p>               Bases: <code>SignatureToken</code></p> <p>MeterSymbolToken class.</p>"},{"location":"reference/#kernpy.core.MultistageTree","title":"<code>MultistageTree</code>","text":"<p>MultistageTree class.</p>"},{"location":"reference/#kernpy.core.MultistageTree.__deepcopy__","title":"<code>__deepcopy__(memo)</code>","text":"<p>Create a deep copy of the MultistageTree object.</p>"},{"location":"reference/#kernpy.core.MultistageTree.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for MultistageTree class.</p> <p>Create an empty Node object to serve as the root,         and start the stages list by placing this root node inside a new list.</p>"},{"location":"reference/#kernpy.core.MultistageTree.add_node","title":"<code>add_node(stage, parent, token, last_spine_operator_node, previous_signature_nodes, header_node=None)</code>","text":"<p>Add a new node to the tree. Args:     stage (int):     parent (Node):     token (Optional[AbstractToken]):     last_spine_operator_node (Optional[Node]):     previous_signature_nodes (Optional[SignatureNodes]):     header_node (Optional[Node]):</p> <p>Returns: Node - The added node object.</p>"},{"location":"reference/#kernpy.core.MultistageTree.dfs","title":"<code>dfs(visit_method)</code>","text":"<p>Depth-first search (DFS)</p> <p>Parameters:</p> Name Type Description Default <code>visit_method</code> <code>TreeTraversalInterface</code> <p>The tree traversal interface.</p> required <p>Returns: None</p>"},{"location":"reference/#kernpy.core.MultistageTree.dfs_iterative","title":"<code>dfs_iterative(visit_method)</code>","text":"<p>Depth-first search (DFS). Iterative version.</p> <p>Parameters:</p> Name Type Description Default <code>visit_method</code> <code>TreeTraversalInterface</code> <p>The tree traversal interface.</p> required <p>Returns: None</p>"},{"location":"reference/#kernpy.core.MxhmSpineImporter","title":"<code>MxhmSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.core.MxhmSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.core.Node","title":"<code>Node</code>","text":"<p>Node class.</p> <p>This class represents a node in a tree. The <code>Node</code> class is responsible for storing the main information of the **kern file.</p> <p>Attributes:</p> Name Type Description <code>id(int)</code> <p>The unique id of the node.</p> <code>token(Optional[AbstractToken])</code> <p>The specific token of the node. The token can be a <code>KeyToken</code>, <code>MeterSymbolToken</code>, etc...</p> <code>parent(Optional['Node'])</code> <p>A reference to the parent <code>Node</code>. If the parent is the root, the parent is None.</p> <code>children(List['Node'])</code> <p>A list of the children <code>Node</code>.</p> <code>stage(int)</code> <p>The stage of the node in the tree. The stage is similar to a row in the **kern file.</p> <code>last_spine_operator_node(Optional['Node'])</code> <p>The last spine operator node.</p> <code>last_signature_nodes(Optional[SignatureNodes])</code> <p>A reference to the last <code>SignatureNodes</code> instance.</p> <code>header_node(Optional['Node'])</code> <p>The header node.</p>"},{"location":"reference/#kernpy.core.Node.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two nodes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>The other node to compare.</p> required <p>Returns: True if the nodes are equal, False otherwise.</p>"},{"location":"reference/#kernpy.core.Node.__hash__","title":"<code>__hash__()</code>","text":"<p>Get the hash of the node.</p> <p>Returns: The hash of the node.</p>"},{"location":"reference/#kernpy.core.Node.__init__","title":"<code>__init__(stage, token, parent, last_spine_operator_node, last_signature_nodes, header_node)</code>","text":"<p>Create an instance of Node.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>int</code> <p>The stage of the node in the tree. The stage is similar to a row in the **kern file.</p> required <code>token</code> <code>Optional[AbstractToken]</code> <p>The specific token of the node. The token can be a <code>KeyToken</code>, <code>MeterSymbolToken</code>, etc...</p> required <code>parent</code> <code>Optional['Node']</code> <p>A reference to the parent <code>Node</code>. If the parent is the root, the parent is None.</p> required <code>last_spine_operator_node</code> <code>Optional['Node']</code> <p>The last spine operator node.</p> required <code>last_signature_nodes</code> <code>Optional[SignatureNodes]</code> <p>A reference to the last <code>SignatureNodes</code> instance.</p> required <code>header_node</code> <code>Optional['Node']</code> <p>The header node.</p> required"},{"location":"reference/#kernpy.core.Node.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two nodes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>The other node to compare.</p> required <p>Returns: True if the nodes are not equal, False otherwise.</p>"},{"location":"reference/#kernpy.core.Node.__str__","title":"<code>__str__()</code>","text":"<p>Get the string representation of the node.</p> <p>Returns: The string representation of the node.</p>"},{"location":"reference/#kernpy.core.Node.count_nodes_by_stage","title":"<code>count_nodes_by_stage()</code>","text":"<p>Count the number of nodes in each stage of the tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(0, None, None, None, None, None)\n&gt;&gt;&gt; ...\n&gt;&gt;&gt; node.count_nodes_by_stage()\n[2, 2, 2, 2, 3, 3, 3, 2]\n</code></pre> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: A list with the number of nodes in each stage of the tree.</p>"},{"location":"reference/#kernpy.core.Node.dfs","title":"<code>dfs(tree_traversal)</code>","text":"<p>Depth-first search (DFS)</p> <p>Parameters:</p> Name Type Description Default <code>tree_traversal</code> <code>TreeTraversalInterface</code> <p>The tree traversal interface. Object used to visit the nodes of the tree.</p> required"},{"location":"reference/#kernpy.core.Node.dfs_iterative","title":"<code>dfs_iterative(tree_traversal)</code>","text":"<p>Depth-first search (DFS). Iterative version.</p> <p>Parameters:</p> Name Type Description Default <code>tree_traversal</code> <code>TreeTraversalInterface</code> <p>The tree traversal interface. Object used to visit the nodes of the tree.</p> required <p>Returns: None</p>"},{"location":"reference/#kernpy.core.NoteRestToken","title":"<code>NoteRestToken</code>","text":"<p>               Bases: <code>ComplexToken</code></p> <p>NoteRestToken class.</p> <p>Attributes:</p> Name Type Description <code>pitch_duration_subtokens</code> <code>list</code> <p>The subtokens for the pitch and duration</p> <code>decoration_subtokens</code> <code>list</code> <p>The subtokens for the decorations</p>"},{"location":"reference/#kernpy.core.NoteRestToken.__init__","title":"<code>__init__(encoding, pitch_duration_subtokens, decoration_subtokens)</code>","text":"<p>NoteRestToken constructor.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>pitch_duration_subtokens</code> <code>List[Subtoken])y</code> <p>The subtokens for the pitch and duration</p> required <code>decoration_subtokens</code> <code>List[Subtoken]</code> <p>The subtokens for the decorations. Individual elements of the token, of type Subtoken</p> required"},{"location":"reference/#kernpy.core.NoteRestToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p>"},{"location":"reference/#kernpy.core.PitchPositionReferenceSystem","title":"<code>PitchPositionReferenceSystem</code>","text":""},{"location":"reference/#kernpy.core.PitchPositionReferenceSystem.__init__","title":"<code>__init__(base_pitch)</code>","text":"<p>Initializes the PitchPositionReferenceSystem object. Args:     base_pitch (AgnosticPitch): The AgnosticPitch in the first line of the Staff.              The AgnosticPitch object that serves as the reference point for the system.</p>"},{"location":"reference/#kernpy.core.PitchPositionReferenceSystem.compute_position","title":"<code>compute_position(pitch)</code>","text":"<p>Computes the position in staff for the given pitch. Args:     pitch (AgnosticPitch): The AgnosticPitch object to compute the position for. Returns:     PositionInStaff: The PositionInStaff object representing the computed position.</p>"},{"location":"reference/#kernpy.core.PitchRest","title":"<code>PitchRest</code>","text":"<p>Represents a name or a rest in a note.</p> <p>The name is represented using the International Standard Organization (ISO) name notation. The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.</p> <p>The Humdrum Kern format uses the following name representation: 'c' = C4 'cc' = C5 'ccc' = C6 'cccc' = C7</p> <p>'C' = C3 'CC' = C2 'CCC' = C1</p> <p>The rests are represented by the letter 'r'. The rests do not have name.</p> <p>This class do not limit the name ranges.</p> <p>In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.</p> <pre><code>**kern\n*clefG2\n2c          // C4\n2cc         // C5\n2ccc        // C6\n2C          // C3\n2CC         // C2\n2CCC        // C1\n*-\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two pitches and rests.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PitchRest</code> <p>The other name to compare</p> required <p>Returns (bool):     True if the pitches are equal, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nTrue\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool):     True if this name is higher or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Compare two pitches.</p> <p>If any of the pitches is a rest, the comparison raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PitchRest</code> <p>The other name to compare</p> required <p>Returns (bool): True if this name is higher than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTraceback (most recent call last):\nValueError: ...\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__init__","title":"<code>__init__(raw_pitch)</code>","text":"<p>Create a new PitchRest object.</p> <p>Parameters:</p> Name Type Description Default <code>raw_pitch</code> <code>str</code> <p>name representation in Humdrum Kern format</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest = PitchRest('DDD')\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__le__","title":"<code>__le__(other)</code>","text":"<p>Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool): True if this name is lower or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two pitches.</p> <p>If any of the pitches is a rest, the comparison raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'PitchRest'</code> <p>The other name to compare</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this name is lower than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two pitches and rests. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool):     True if the pitches are different, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nFalse\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.is_rest","title":"<code>is_rest()</code>","text":"<p>Check if the name is a rest.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the name is a rest, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest.is_rest()\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest.is_rest()\nTrue\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.pitch_comparator","title":"<code>pitch_comparator(pitch_a, pitch_b)</code>  <code>staticmethod</code>","text":"<p>Compare two pitches of the same octave.</p> <p>The lower name is 'a'. So 'a' &lt; 'b' &lt; 'c' &lt; 'd' &lt; 'e' &lt; 'f' &lt; 'g'</p> <p>Parameters:</p> Name Type Description Default <code>pitch_a</code> <code>str</code> <p>One name of 'abcdefg'</p> required <code>pitch_b</code> <code>str</code> <p>Another name of 'abcdefg'</p> required <p>Returns:</p> Type Description <code>int</code> <p>-1 if pitch1 is lower than pitch2</p> <code>int</code> <p>0 if pitch1 is equal to pitch2</p> <code>int</code> <p>1 if pitch1 is higher than pitch2</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PitchRest.pitch_comparator('c', 'c')\n0\n&gt;&gt;&gt; PitchRest.pitch_comparator('c', 'd')\n-1\n&gt;&gt;&gt; PitchRest.pitch_comparator('d', 'c')\n1\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff","title":"<code>PositionInStaff</code>","text":""},{"location":"reference/#kernpy.core.PositionInStaff.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the PositionInStaff object.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.__init__","title":"<code>__init__(line_space)</code>","text":"<p>Initializes the PositionInStaff object.</p> <p>Parameters:</p> Name Type Description Default <code>line_space</code> <code>int</code> <p>0 for bottom line, -1 for space under bottom line, 1 for space above bottom line.              Increments by 1 for each line or space.</p> required"},{"location":"reference/#kernpy.core.PositionInStaff.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the PositionInStaff object.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the position in staff.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.from_encoded","title":"<code>from_encoded(encoded)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from an encoded string.</p> <p>Parameters:</p> Name Type Description Default <code>encoded</code> <code>str</code> <p>The encoded string.</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.from_line","title":"<code>from_line(line)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from a line number.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line number. line 1 is bottom line, 2 is the 1st line from bottom, 0 is the bottom ledger line</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object. 0 for the bottom line, 2 for the 1st line from bottom, -1 for the bottom ledger line, etc.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.from_space","title":"<code>from_space(space)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from a space number.</p> <p>Parameters:</p> Name Type Description Default <code>space</code> <code>int</code> <p>The space number. space 1 is bottom space, 2</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.is_line","title":"<code>is_line()</code>","text":"<p>Returns True if the position is a line, False otherwise. If is not a line, it is a space, and vice versa.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.line","title":"<code>line()</code>","text":"<p>Returns the line number of the position in staff.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.move","title":"<code>move(line_space_difference)</code>","text":"<p>Returns a new PositionInStaff object with the position moved by the given number of lines or spaces.</p> <p>Parameters:</p> Name Type Description Default <code>line_space_difference</code> <code>int</code> <p>The number of lines or spaces to move.</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The new PositionInStaff object.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.position_above","title":"<code>position_above()</code>","text":"<p>Returns the position above the current position.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.position_below","title":"<code>position_below()</code>","text":"<p>Returns the position below the current position.</p>"},{"location":"reference/#kernpy.core.PositionInStaff.space","title":"<code>space()</code>","text":"<p>Returns the space number of the position in staff.</p>"},{"location":"reference/#kernpy.core.RootSpineImporter","title":"<code>RootSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.core.RootSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.core.SignatureNodes","title":"<code>SignatureNodes</code>","text":"<p>SignatureNodes class.</p> <p>This class is used to store the last signature nodes of a tree. It is used to keep track of the last signature nodes.</p> <p>Attributes: nodes (dict): A dictionary that stores the last signature nodes. This way, we can add several tokens without repetitions. - The key is the signature descendant token class (KeyToken, MeterSymbolToken, etc...) - The value = node</p>"},{"location":"reference/#kernpy.core.SignatureNodes.__init__","title":"<code>__init__()</code>","text":"<p>Create an instance of SignatureNodes. Initialize the nodes as an empty dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; signature_nodes = SignatureNodes()\n&gt;&gt;&gt; signature_nodes.nodes\n{}\n</code></pre>"},{"location":"reference/#kernpy.core.SignatureNodes.clone","title":"<code>clone()</code>","text":"<p>Create a deep copy of the SignatureNodes instance. Returns: A new instance of SignatureNodes with nodes copied.</p>"},{"location":"reference/#kernpy.core.SignatureNodes.clone--todo-this-method-is-equivalent-to-the-following-code","title":"TODO: This method is equivalent to the following code:","text":""},{"location":"reference/#kernpy.core.SignatureNodes.clone--from-copy-import-deepcopy","title":"from copy import deepcopy","text":""},{"location":"reference/#kernpy.core.SignatureNodes.clone--signature_nodes_to_copy-signaturenodes","title":"signature_nodes_to_copy = SignatureNodes()","text":""},{"location":"reference/#kernpy.core.SignatureNodes.clone--_1","title":"...","text":""},{"location":"reference/#kernpy.core.SignatureNodes.clone--result-deepcopysignature_nodes_to_copy","title":"result = deepcopy(signature_nodes_to_copy)","text":""},{"location":"reference/#kernpy.core.SignatureNodes.clone--it-should-be-tested","title":"It should be tested.","text":""},{"location":"reference/#kernpy.core.SignatureToken","title":"<code>SignatureToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>SignatureToken class for all signature tokens. It will be overridden by more specific classes.</p>"},{"location":"reference/#kernpy.core.SimpleToken","title":"<code>SimpleToken</code>","text":"<p>               Bases: <code>Token</code></p> <p>SimpleToken class.</p>"},{"location":"reference/#kernpy.core.SimpleToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>'filter_categories' (Optional[Callable[[TokenCategory], bool]]): It is ignored in this class.</p> <code>{}</code> <p>Returns (str): The encoded token representation.</p>"},{"location":"reference/#kernpy.core.SpineImporter","title":"<code>SpineImporter</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/#kernpy.core.SpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>SpineImporter constructor. This class is an abstract base class for importing all kinds of spines.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.core.SpineOperationToken","title":"<code>SpineOperationToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>SpineOperationToken class.</p> <p>This token represents different operations in the Humdrum kern encoding. These are the available operations:     - <code>*-</code>:  spine-path terminator.     - <code>*</code>: null interpretation.     - <code>*+</code>: add spines.     - <code>*^</code>: split spines.     - <code>*x</code>: exchange spines.</p> <p>Attributes:</p> Name Type Description <code>cancelled_at_stage</code> <code>int</code> <p>The stage at which the operation was cancelled. Defaults to None.</p>"},{"location":"reference/#kernpy.core.SpineOperationToken.is_cancelled_at","title":"<code>is_cancelled_at(stage)</code>","text":"<p>Checks if the operation was cancelled at the given stage.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>int</code> <p>The stage at which the operation was cancelled.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the operation was cancelled at the given stage, False otherwise.</p>"},{"location":"reference/#kernpy.core.Staff","title":"<code>Staff</code>","text":""},{"location":"reference/#kernpy.core.Staff.position_in_staff","title":"<code>position_in_staff(*, clef, pitch)</code>","text":"<p>Returns the position in staff for the given clef and pitch.</p>"},{"location":"reference/#kernpy.core.Subtoken","title":"<code>Subtoken</code>","text":"<p>Subtoken class. Thhe subtokens are the smallest units of categories. ComplexToken objects are composed of subtokens.</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <p>The complete unprocessed encoding</p> <code>category</code> <p>The subtoken category, one of SubTokenCategory</p>"},{"location":"reference/#kernpy.core.Subtoken.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two subtokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Subtoken</code> <p>The other subtoken to compare.</p> required <p>Returns (bool): True if the subtokens are equal, False otherwise.</p>"},{"location":"reference/#kernpy.core.Subtoken.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the subtoken.</p> <p>Returns (int): The hash of the subtoken.</p>"},{"location":"reference/#kernpy.core.Subtoken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>Subtoken constructor</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>category</code> <code>TokenCategory</code> <p>The subtoken category.                 It should be a child of the main 'TokenCategory' in the hierarchy.</p> required"},{"location":"reference/#kernpy.core.Subtoken.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two subtokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Subtoken</code> <p>The other subtoken to compare.</p> required <p>Returns (bool): True if the subtokens are different, False otherwise.</p>"},{"location":"reference/#kernpy.core.Subtoken.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the subtoken.</p> <p>Returns (str): The string representation of the subtoken.</p>"},{"location":"reference/#kernpy.core.TextSpineImporter","title":"<code>TextSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p>"},{"location":"reference/#kernpy.core.TextSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code>"},{"location":"reference/#kernpy.core.TimeSignatureToken","title":"<code>TimeSignatureToken</code>","text":"<p>               Bases: <code>SignatureToken</code></p> <p>TimeSignatureToken class.</p>"},{"location":"reference/#kernpy.core.Token","title":"<code>Token</code>","text":"<p>               Bases: <code>AbstractToken</code>, <code>ABC</code></p> <p>Abstract Token class.</p>"},{"location":"reference/#kernpy.core.TokenCategory","title":"<code>TokenCategory</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Options for the category of a token.</p> <p>This is used to determine what kind of token should be exported.</p> <p>The categories are sorted the specific order they are compared to sorthem. But hierarchical order must be defined in other data structures.</p>"},{"location":"reference/#kernpy.core.TokenCategory.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two TokenCategory. Args:     other (TokenCategory): The other category to compare.</p> <p>Returns (bool): True if this category is lower than the other, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.CORE\nTrue\n&gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.STRUCTURAL\nFalse\n&gt;&gt;&gt; TokenCategory.CORE &lt; TokenCategory.STRUCTURAL\nFalse\n&gt;&gt;&gt; sorted([TokenCategory.STRUCTURAL, TokenCategory.CORE])\n[TokenCategory.STRUCTURAL, TokenCategory.CORE]\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory.__str__","title":"<code>__str__()</code>","text":"<p>Get the string representation of the category.</p> <p>Returns (str): The string representation of the category.</p>"},{"location":"reference/#kernpy.core.TokenCategory.children","title":"<code>children(target)</code>  <code>classmethod</code>","text":"<p>Get the children of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of child categories of the target category.</p>"},{"location":"reference/#kernpy.core.TokenCategory.is_child","title":"<code>is_child(*, child, parent)</code>  <code>classmethod</code>","text":"<p>Check if the child category is a child of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>TokenCategory</code> <p>The child category.</p> required <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns (bool): True if the child category is a child of the parent category, False otherwise.</p>"},{"location":"reference/#kernpy.core.TokenCategory.leaves","title":"<code>leaves(target)</code>  <code>classmethod</code>","text":"<p>Get the leaves of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of leaf categories of the target category.</p>"},{"location":"reference/#kernpy.core.TokenCategory.match","title":"<code>match(target, *, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Check if the target category matches the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (bool): True if the target category matches the include and exclude sets, False otherwise.</p>"},{"location":"reference/#kernpy.core.TokenCategory.nodes","title":"<code>nodes(target)</code>  <code>classmethod</code>","text":"<p>Get the nodes of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of node categories of the target category.</p>"},{"location":"reference/#kernpy.core.TokenCategory.tree","title":"<code>tree()</code>  <code>classmethod</code>","text":"<p>Return a string representation of the category hierarchy Returns (str): The string representation of the category hierarchy</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; print(kp.TokenCategory.tree())\n.\n\u251c\u2500\u2500 TokenCategory.STRUCTURAL\n\u251c\u2500\u2500 TokenCategory.CORE\n\u2502   \u251c\u2500\u2500 TokenCategory.NOTE_REST\n\u2502   \u2502   \u251c\u2500\u2500 TokenCategory.DURATION\n\u2502   \u2502   \u251c\u2500\u2500 TokenCategory.NOTE\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.PITCH\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.DECORATION\n\u2502   \u2502   \u2514\u2500\u2500 TokenCategory.REST\n\u2502   \u251c\u2500\u2500 TokenCategory.CHORD\n\u2502   \u2514\u2500\u2500 TokenCategory.EMPTY\n\u251c\u2500\u2500 TokenCategory.SIGNATURES\n\u2502   \u251c\u2500\u2500 TokenCategory.CLEF\n\u2502   \u251c\u2500\u2500 TokenCategory.TIME_SIGNATURE\n\u2502   \u251c\u2500\u2500 TokenCategory.METER_SYMBOL\n\u2502   \u2514\u2500\u2500 TokenCategory.KEY_SIGNATURE\n\u251c\u2500\u2500 TokenCategory.ENGRAVED_SYMBOLS\n\u251c\u2500\u2500 TokenCategory.OTHER_CONTEXTUAL\n\u251c\u2500\u2500 TokenCategory.BARLINES\n\u251c\u2500\u2500 TokenCategory.COMMENTS\n\u2502   \u251c\u2500\u2500 TokenCategory.FIELD_COMMENTS\n\u2502   \u2514\u2500\u2500 TokenCategory.LINE_COMMENTS\n\u251c\u2500\u2500 TokenCategory.DYNAMICS\n\u251c\u2500\u2500 TokenCategory.HARMONY\n\u251c\u2500\u2500 TokenCategory.FINGERING\n\u251c\u2500\u2500 TokenCategory.LYRICS\n\u251c\u2500\u2500 TokenCategory.INSTRUMENTS\n\u251c\u2500\u2500 TokenCategory.BOUNDING_BOXES\n\u2514\u2500\u2500 TokenCategory.OTHER\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory.valid","title":"<code>valid(*, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Get the valid categories based on the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.</p>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper","title":"<code>TokenCategoryHierarchyMapper</code>","text":"<p>Mapping of the TokenCategory hierarchy.</p> <p>This class is used to define the hierarchy of the TokenCategory. Useful related methods are provided.</p>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.all","title":"<code>all()</code>  <code>classmethod</code>","text":"<p>Get all categories in the hierarchy.</p> <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>Set[TokenCategory]: The set of all categories in the hierarchy.</p>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.children","title":"<code>children(parent)</code>  <code>classmethod</code>","text":"<p>Get the direct children of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>Set[TokenCategory]: The list of children categories of the parent category.</p>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.is_child","title":"<code>is_child(parent, child)</code>  <code>classmethod</code>","text":"<p>Recursively check if <code>child</code> is in the subtree of <code>parent</code>. If <code>parent</code> is the same as <code>child</code>, return True.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <code>child</code> <code>TokenCategory</code> <p>The category to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>child</code> is a descendant of <code>parent</code>, False otherwise.</p>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.leaves","title":"<code>leaves(target)</code>  <code>classmethod</code>","text":"<p>Get the leaves of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of leaf categories of the target category.</p>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.match","title":"<code>match(category, *, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Check if the category matches the include and exclude sets.     If include is None, all categories are included.             If exclude is None, no categories are excluded.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>TokenCategory</code> <p>The category to check.</p> required <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (bool): True if the category matches the include and exclude sets, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.REST})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.NOTE})\nFalse\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.DURATION, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\nFalse\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.nodes","title":"<code>nodes(parent)</code>  <code>classmethod</code>","text":"<p>Get the all nodes of the subtree of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>List[TokenCategory]: The list of nodes of the subtree of the parent category.</p>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.tree","title":"<code>tree()</code>  <code>classmethod</code>","text":"<p>Return a string representation of the category hierarchy, formatted similar to the output of the Unix 'tree' command.</p> Example output <p>. \u251c\u2500\u2500 STRUCTURAL \u251c\u2500\u2500 CORE \u2502   \u251c\u2500\u2500 NOTE_REST \u2502   \u2502   \u251c\u2500\u2500 DURATION \u2502   \u2502   \u251c\u2500\u2500 NOTE \u2502   \u2502   \u2502   \u251c\u2500\u2500 PITCH \u2502   \u2502   \u2502   \u2514\u2500\u2500 DECORATION \u2502   \u2502   \u2514\u2500\u2500 REST \u2502   \u251c\u2500\u2500 CHORD \u2502   \u2514\u2500\u2500 EMPTY \u251c\u2500\u2500 SIGNATURES \u2502   \u251c\u2500\u2500 CLEF \u2502   \u251c\u2500\u2500 TIME_SIGNATURE \u2502   \u251c\u2500\u2500 METER_SYMBOL \u2502   \u2514\u2500\u2500 KEY_SIGNATURE \u251c\u2500\u2500 ENGRAVED_SYMBOLS \u251c\u2500\u2500 OTHER_CONTEXTUAL \u251c\u2500\u2500 BARLINES \u251c\u2500\u2500 COMMENTS \u2502   \u251c\u2500\u2500 FIELD_COMMENTS \u2502   \u2514\u2500\u2500 LINE_COMMENTS \u251c\u2500\u2500 DYNAMICS \u251c\u2500\u2500 HARMONY ...</p>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.valid","title":"<code>valid(include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Get the valid categories based on the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.</p>"},{"location":"reference/#kernpy.core.Tokenizer","title":"<code>Tokenizer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Tokenizer interface. All tokenizers must implement this interface.</p> <p>Tokenizers are responsible for converting a token into a string representation.</p>"},{"location":"reference/#kernpy.core.Tokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new Tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None, an exception will be raised.</p> required"},{"location":"reference/#kernpy.core.Tokenizer.tokenize","title":"<code>tokenize(token)</code>  <code>abstractmethod</code>","text":"<p>Tokenize a token into a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>Token to be tokenized.</p> required <p>Returns (str): Tokenized string representation.</p>"},{"location":"reference/#kernpy.core.TokensTraversal","title":"<code>TokensTraversal</code>","text":"<p>               Bases: <code>TreeTraversalInterface</code></p>"},{"location":"reference/#kernpy.core.TokensTraversal.__init__","title":"<code>__init__(non_repeated, filter_by_categories)</code>","text":"<p>Create an instance of <code>TokensTraversal</code>. Args:     non_repeated: If True, only unique tokens are returned. If False, all tokens are returned.     filter_by_categories: A list of categories to filter the tokens. If None, all tokens are returned.</p>"},{"location":"reference/#kernpy.core.TraversalFactory","title":"<code>TraversalFactory</code>","text":""},{"location":"reference/#kernpy.core.TraversalFactory.create","title":"<code>create(traversal_type, non_repeated, filter_by_categories)</code>  <code>classmethod</code>","text":"<p>Create an instance of <code>TreeTraversalInterface</code> based on the <code>traversal_type</code>. Args:     non_repeated:     filter_by_categories:     traversal_type: The type of traversal to use. Possible values are:         - \"metacomments\"         - \"tokens\"</p> <p>Returns: An instance of <code>TreeTraversalInterface</code>.</p>"},{"location":"reference/#kernpy.core.TreeTraversalInterface","title":"<code>TreeTraversalInterface</code>","text":"<p>               Bases: <code>ABC</code></p> <p>TreeTraversalInterface class.</p> <p>This class is used to traverse the tree. The <code>TreeTraversalInterface</code> class is responsible for implementing the <code>visit</code> method.</p>"},{"location":"reference/#kernpy.core.agnostic_distance","title":"<code>agnostic_distance(first_pitch, second_pitch)</code>","text":"<p>Calculate the distance in semitones between two pitches.</p> <p>Parameters:</p> Name Type Description Default <code>first_pitch</code> <code>AgnosticPitch</code> <p>The first pitch to compare.</p> required <code>second_pitch</code> <code>AgnosticPitch</code> <p>The second pitch to compare.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The distance in semitones between the two pitches.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('E4'))\n4\n&gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('B3'))\n-1\n</code></pre>"},{"location":"reference/#kernpy.core.create","title":"<code>create(content, strict=False)</code>","text":"<pre><code>Create a Document object from a string encoded in Humdrum **kern format.\n\nArgs:\n    content: String encoded in Humdrum **kern format\n    strict: If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.\n\nReturns (Document, list): Document object and list of error messages. Empty list if no errors.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; document, errors = kp.create('**kern\n</code></pre> <p>4e 4f 4g - ')         &gt;&gt;&gt; if len(errors) &gt; 0:         &gt;&gt;&gt;     print(errors)         ['Error: Invalid kern spine: 1', 'Error: Invalid *kern spine: 2']</p>"},{"location":"reference/#kernpy.core.deprecated","title":"<code>deprecated(reason)</code>","text":"<p>Decorator to mark a function or class as deprecated.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>The reason why the function/class is deprecated.</p> required Example <p>@deprecated(\"Use new_function instead.\") def old_function():     pass</p>"},{"location":"reference/#kernpy.core.distance","title":"<code>distance(first_encoding, second_encoding, *, first_format=NotationEncoding.HUMDRUM.value, second_format=NotationEncoding.HUMDRUM.value)</code>","text":"<p>Calculate the distance in semitones between two pitches.</p> <p>Parameters:</p> Name Type Description Default <code>first_encoding</code> <code>str</code> <p>The first pitch to compare.</p> required <code>second_encoding</code> <code>str</code> <p>The second pitch to compare.</p> required <code>first_format</code> <code>str</code> <p>The encoding format of the first pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>second_format</code> <code>str</code> <p>The encoding format of the second pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The distance in semitones between the two pitches.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; distance('C4', 'E4')\n4\n&gt;&gt;&gt; distance('C4', 'B3')\n-1\n</code></pre>"},{"location":"reference/#kernpy.core.ekern_to_krn","title":"<code>ekern_to_krn(input_file, output_file)</code>","text":"<p>Convert one .ekrn file to .krn file.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Filepath to the input **ekern</p> required <code>output_file</code> <code>str</code> <p>Filepath to the output **kern</p> required <p>Returns:     None</p> Example"},{"location":"reference/#kernpy.core.ekern_to_krn--convert-ekrn-to-krn","title":"Convert .ekrn to .krn","text":"<p>ekern_to_krn('path/to/file.ekrn', 'path/to/file.krn')</p>"},{"location":"reference/#kernpy.core.ekern_to_krn--convert-a-list-of-ekrn-files-to-krn-files","title":"Convert a list of .ekrn files to .krn files","text":"<pre><code>ekrn_files = your_modue.get_files()\n\n# Use the wrapper to avoid stopping the process if an error occurs\ndef ekern_to_krn_wrapper(ekern_file, kern_file):\n    try:\n        ekern_to_krn(ekrn_files, output_folder)\n    except Exception as e:\n        print(f'Error:{e}')\n\n# Convert all the files\nfor ekern_file in ekrn_files:\n    output_file = ekern_file.replace('.ekrn', '.krn')\n    ekern_to_krn_wrapper(ekern_file, output_file)\n</code></pre>"},{"location":"reference/#kernpy.core.export","title":"<code>export(document, options)</code>","text":"<p>Export a Document object to a string.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to export</p> required <code>options</code> <code>ExportOptions</code> <p>Export options</p> required <p>Returns: Exported string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; options = kp.ExportOptions()\n&gt;&gt;&gt; content = kp.export(document, options)\n</code></pre>"},{"location":"reference/#kernpy.core.get_kern_from_ekern","title":"<code>get_kern_from_ekern(ekern_content)</code>","text":"<p>Read the content of a ekern file and return the kern content.</p> <p>Parameters:</p> Name Type Description Default <code>ekern_content</code> <code>str</code> <p>The content of the **ekern file.</p> required <p>Returns:     The content of the **kern file.</p> Example <pre><code># Read **ekern file\nekern_file = 'path/to/file.ekrn'\nwith open(ekern_file, 'r') as file:\n    ekern_content = file.read()\n\n# Get **kern content\nkern_content = get_kern_from_ekern(ekern_content)\nwith open('path/to/file.krn', 'w') as file:\n    file.write(kern_content)\n\n</code></pre>"},{"location":"reference/#kernpy.core.get_spine_types","title":"<code>get_spine_types(document, spine_types=None)</code>","text":"<p>Get the spines of a Document object.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to get spines from</p> required <code>spine_types</code> <code>Optional[Sequence[str]]</code> <p>List of spine types to get. If None, all spines are returned.</p> <code>None</code> <p>Returns (List[str]): List of spines</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n&gt;&gt;&gt; kp.get_spine_types(document)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern'])\n['**kern', '**kern', '**kern', '**kern']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root'])\n['**kern', '**kern', '**kern', '**kern', '**root']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root', '**harm'])\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, [])\n[]\n</code></pre>"},{"location":"reference/#kernpy.core.kern_to_ekern","title":"<code>kern_to_ekern(input_file, output_file)</code>","text":"<p>Convert one .krn file to .ekrn file</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Filepath to the input **kern</p> required <code>output_file</code> <code>str</code> <p>Filepath to the output **ekern</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example"},{"location":"reference/#kernpy.core.kern_to_ekern--convert-krn-to-ekrn","title":"Convert .krn to .ekrn","text":"<p>kern_to_ekern('path/to/file.krn', 'path/to/file.ekrn')</p>"},{"location":"reference/#kernpy.core.kern_to_ekern--convert-a-list-of-krn-files-to-ekrn-files","title":"Convert a list of .krn files to .ekrn files","text":"<pre><code>krn_files = your_module.get_files()\n\n# Use the wrapper to avoid stopping the process if an error occurs\ndef kern_to_ekern_wrapper(krn_file, ekern_file):\n    try:\n        kern_to_ekern(krn_file, ekern_file)\n    except Exception as e:\n        print(f'Error:{e}')\n\n# Convert all the files\nfor krn_file in krn_files:\n    output_file = krn_file.replace('.krn', '.ekrn')\n    kern_to_ekern_wrapper(krn_file, output_file)\n</code></pre>"},{"location":"reference/#kernpy.core.read","title":"<code>read(path, strict=False)</code>","text":"<p>Read a Humdrum **kern file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>File path to read</p> required <code>strict</code> <code>Optional[bool]</code> <p>If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.</p> <code>False</code> <p>Returns (Document, List[str]): Document object and list of error messages. Empty list if no errors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n</code></pre> <pre><code>&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; if len(errors) &gt; 0:\n&gt;&gt;&gt;     print(errors)\n['Error: Invalid **kern spine: 1', 'Error: Invalid **kern spine: 2']\n</code></pre>"},{"location":"reference/#kernpy.core.store","title":"<code>store(document, path, options)</code>","text":"<p>Store a Document object to a file.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to store</p> required <code>path</code> <code>Union[str, Path]</code> <p>File path to store</p> required <code>options</code> <code>ExportOptions</code> <p>Export options</p> required <p>Returns: None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; options = kp.ExportOptions()\n&gt;&gt;&gt; kp.store(document, 'path/to/store.krn', options)\n</code></pre>"},{"location":"reference/#kernpy.core.store_graph","title":"<code>store_graph(document, path)</code>","text":"<p>Create a graph representation of a Document object using Graphviz. Save the graph to a file.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to create graph from</p> required <code>path</code> <code>str</code> <p>File path to save the graph</p> required <p>Returns (None): None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; kp.store_graph(document, 'path/to/graph.dot')\n</code></pre>"},{"location":"reference/#kernpy.core.transpose","title":"<code>transpose(input_encoding, interval, input_format=NotationEncoding.HUMDRUM.value, output_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose a pitch by a given interval.</p> <p>The pitch must be in the American notation.</p> <p>Parameters:</p> Name Type Description Default <code>input_encoding</code> <code>str</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>input_format</code> <code>str</code> <p>The encoding format of the pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>output_format</code> <code>str</code> <p>The encoding format of the transposed pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>str</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', output_format='kern')\n'fff'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\n'fff'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\n'gg'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction=Direction.DOWN.value)\n'gg'\n&gt;&gt;&gt; transpose('ccc#', IntervalsByName['P4'])\n'fff#'\n&gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format='american')\n'Bb4'\n&gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format=NotationEncoding.AMERICAN.value)\n'Bb4'\n&gt;&gt;&gt; transpose('C3', IntervalsByName['P4'], input_format='american', direction='down')\n'G2'\n</code></pre>"},{"location":"reference/#kernpy.core.transpose_agnostic_to_encoding","title":"<code>transpose_agnostic_to_encoding(agnostic_pitch, interval, output_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose an AgnosticPitch by a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>agnostic_pitch</code> <code>AgnosticPitch</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>output_format</code> <code>Optional[str]</code> <p>The encoding format of the transposed pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>Optional[str]</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns (str):     str: The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'])\n'F4'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\n'G3'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C#', 4), IntervalsByName['P4'])\n'F#4'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\n'Bb4'\n</code></pre>"},{"location":"reference/#kernpy.core.transpose_agnostics","title":"<code>transpose_agnostics(input_pitch, interval, direction=Direction.UP.value)</code>","text":"<p>Transpose an AgnosticPitch by a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>input_pitch</code> <code>AgnosticPitch</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>direction</code> <code>str</code> <p>The direction of the transposition. 'UP' or 'DOWN'. Default is 'UP'.</p> <code>UP.value</code> Returns <p>AgnosticPitch: The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'])\nAgnosticPitch('F', 4)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\nAgnosticPitch('G', 3)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C#', 4), IntervalsByName['P4'])\nAgnosticPitch('F#', 4)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\nAgnosticPitch('Bb', 4)\n</code></pre>"},{"location":"reference/#kernpy.core.transpose_encoding_to_agnostic","title":"<code>transpose_encoding_to_agnostic(input_encoding, interval, input_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose a pitch by a given interval.</p> <p>The pitch must be in the American notation.</p> <p>Parameters:</p> Name Type Description Default <code>input_encoding</code> <code>str</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>input_format</code> <code>str</code> <p>The encoding format of the pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>str</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns:</p> Name Type Description <code>AgnosticPitch</code> <code>AgnosticPitch</code> <p>The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern')\nAgnosticPitch('fff', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\nAgnosticPitch('fff', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\nAgnosticPitch('gg', 3)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc#', IntervalsByName['P4'])\nAgnosticPitch('fff#', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('G4', IntervalsByName['m3'], input_format='american')\nAgnosticPitch('Bb4', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('C3', IntervalsByName['P4'], input_format='american', direction='down')\nAgnosticPitch('G2', 2)\n</code></pre>"},{"location":"reference/#kernpy.util.StoreCache","title":"<code>StoreCache</code>","text":"<p>A simple cache that stores the result of a callback function</p>"},{"location":"reference/#kernpy.util.StoreCache.__init__","title":"<code>__init__()</code>","text":"<p>Constructor</p>"},{"location":"reference/#kernpy.util.StoreCache.request","title":"<code>request(callback, request)</code>","text":"<p>Request a value from the cache. If the value is not in the cache, it will be calculated by the callback function Args:     callback (function): The callback function that will be called to calculate the value     request (any): The request that will be passed to the callback function</p> <p>Returns (any): The value that was requested</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def add_five(x):\n...     return x + 5\n&gt;&gt;&gt; store_cache = StoreCache()\n&gt;&gt;&gt; store_cache.request(callback, 5)  # Call the callback function\n10\n&gt;&gt;&gt; store_cache.request(callback, 5)  # Return the value from the cache, without calling the callback function\n10\n</code></pre>"},{"location":"get-started/tutorial/","title":"Tutorial: Learning <code>kernpy</code> in 5 minutes.","text":"<p>This is a short introduction to <code>kernpy</code>. It will guide you through the main concepts and show you how to use the package in a few minutes.</p> <p>When using <code>kernpy</code>, you should be familiar with the Humdrum **kern encodings. You can easily find information in:</p> <ul> <li>Verovio Humdrum Viewer</li> <li>Verovio Humdrum Viewer Documentation</li> </ul>"},{"location":"get-started/tutorial/#running-the-code","title":"Running the code","text":"<p><code>kernpy</code> is able to be run as a normal snippet of code or as a module by command line interface.</p>"},{"location":"get-started/tutorial/#we-will-import-kernpy-as-the-following-way","title":"We will import <code>kernpy</code> as the following way:","text":"<pre><code>import kernpy as kp\n</code></pre>"},{"location":"get-started/tutorial/#what-is-humdrum-kern","title":"What is Humdrum **kern?","text":"<p>First of all, let's see what a Humdrum **kern file looks like:</p> <pre><code>**kern  **text  **kern  **dynam **text\n*clefG2 *   *clefG2 *   *\n*M4/4   *   *   *   *\n=1  =1  =1  =1  =1\n4g  kern    4c  p   kern-\n4f  kern    4d  &lt;   -py\n4g  kern    4e  (   mo-\n4c  kern-   4f  (   -du-\n.   .   .   [   .\n=2  =2  =2  =2  =2\n2c  -py 2g  f   -le\n.   .   .   &gt;   .\n4B  kern    4f  )   is\n4A  kern-   4d  )   the\n=   =   =   =   =\n1G  -py 1c  ]   best\n==  ==  ==  ==  ==\n*-  *-  *-  *-  *-\n</code></pre> <p></p>"},{"location":"get-started/tutorial/#lets-code","title":"Let's code!","text":""},{"location":"get-started/tutorial/#basic-usage","title":"Basic Usage","text":"<p>Load a <code>**kern</code>/<code>**mens</code> file into a <code>kp.Document</code>.</p> <pre><code>import kernpy as kp\n\n# Read a **kern file\ndocument, errors = kp.load(\"path/to/file.krn\")\n</code></pre> <p>Load a <code>**kern</code>/<code>**mens</code> from a string into a <code>kp.Document</code>.</p> <pre><code>import kernpy as kp\n\ndocument, errors = kp.loads(\"**kern\\n*clefC3\\n*k[b-e-a-]\\n*M3/4\\n4e-\\n4g\\n4c\\n=1\\n4r\\n2cc;\\n==\\n*-\")\n</code></pre> <p>Create a new standardized file from a <code>kp.Document</code>.</p> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile.krn\")\n</code></pre> <p>Save the document in a string from a <code>kp.Document</code>.</p> <pre><code>import kernpy as kp\n\ncontent = kp.dumps(document)\n````\n\n### Exploring different options when creating new files\n\nOnly use the specified spines in `spine_types`.\n```python\nimport kernpy as kp\n\nkp.dump(document, \"newfile_core.krn\",\n        spine_types=['**kern'])\nkp.dump(document, \"newfile_lyrics.krn\",\n        spine_types=['**text])\nkp.dump(document, \"newfile_core_and_lyrics.krn\",\n        spine_types=['*+text'])\n</code></pre> <ul> <li>Use <code>include</code> for selecting the kern semantic categories to use**. The output only contains what is passed. By default, all the categories are included.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_only_clefs.krn\",\n        include={kp.TokenCategory.CLEF})\nkp.dump(document, \"newfile_only_durations_and_bounding_boxes.krn\",\n        include={kp.TokenCategory.DURATION, kp.TokenCategory.BOUNDING_BOXES})\n</code></pre> <ul> <li>Use <code>exclude</code> for selecting the kern semantic categories to not use**. The output contains everything except what is passed. By default, any category is excluded.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_without_pitches.krn\",\n        exclude={kp.TokenCategory.PITCH})\nkp.dump(document, \"newfile_without_durations_or_rests.krn\",\n        exclude={kp.TokenCategory.BARLINES, kp.TokenCategory.REST})\n</code></pre> <ul> <li>Use <code>include</code> and <code>exclude</code> together to select the kern semantic categories to use**. The output combines both.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_custom.krn\",\n        include=kp.BEKERN_CATEGORIES,  # Preloaded set of simple categories\n        exclude={kp.TokenCategory.PITCH})\n</code></pre> <ul> <li>Use <code>tokenizer</code> to select how the categories are split. By default, the <code>normalizedKern</code> tokenizer is used.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_normalized.krn\",\n        tokenizer=kp.KernTypeExporter.normalizedKern)  # Default tokenizer\n</code></pre> <p>Select the proper Humdrum **kern tokenizer:</p> <p><code>kernpy</code> provides different tokenizers to export the content each symbol in different formats.</p> Encoding Tokenized Description kern 2.bb-_L Traditional Humdrum **kern encoding ekern 2@.@bb@-\u00b7_\u00b7L Extended Humdrum **kern encoding <p>Use the <code>KernTypeExporter</code> enum class to select the tokenizer:</p> <pre><code>import kernpy as kp\n\ndoc, _ = kp.load('resource_dir/legacy/chor048.krn') \n\nkern_content = kp.dumps(doc, tokenizer=kp.KernTypeExporter.normalizedKern)\nekern_content = kp.dumps(doc, tokenizer=kp.KernTypeExporter.eKern)\n</code></pre> <ul> <li>Use <code>from_measure</code> and <code>to_measure</code> to select the measures to export. By default, all the measures are exported.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_1_to_10.krn\",\n        from_measure=1,  # First from measure 1\n        to_measure=10)   # Last measure exported\n</code></pre> <ul> <li>Use <code>spine_ids</code> to select the spines to export. By default, all the spines are exported.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_1_and_2.krn\",\n        spine_ids=[0, 1])  # Export only the first and the second spine\n</code></pre> <ul> <li>Use <code>show_measure_numbers</code> to select if the measure numbers are shown. By default, the measure numbers are shown.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_no_measure_numbers.krn\",\n        show_measure_numbers=False)  # Do not show measure numbers\n</code></pre> <ul> <li>Use all the options at the same time.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile.krn\",\n        spine_types=['**kern'],                         # Export only the **kern spines\n        include=kp.BEKERN_CATEGORIES,                   # Token categories to include\n        exclude={kp.TokenCategory.PITCH},               # Token categories to exclude\n        tokenizer=kp.KernTypeExporter.eKern,            # Kern encoding\n        from_measure=1,                                 # First from measure 1\n        to_measure=10,                                  # Last measure exported\n        spine_ids=[0, 1],                               # Export only the first and the second spine\n        show_measure_numbers=False,                     # Do not show measure numbers\n        )\n</code></pre>"},{"location":"get-started/tutorial/#exploring-kernpy-utilities","title":"Exploring <code>kernpy</code> utilities.","text":"<ul> <li>Spines analysis   Retrieve all the spine types of the document.</li> </ul> <pre><code>import kernpy as kp\n\nkp.spine_types(document)\n# ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n\nkp.spine_types(document, spine_types=None)\n# ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n\nkp.spine_types(document, spine_types=['**kern'])\n# ['**kern', '**kern', '**kern', '**kern']\n</code></pre> <ul> <li>Get specific **kern spines.</li> </ul> <pre><code>import kernpy as kp\n\ndef how_many_instrumental_spines(document):\n    print(kp.spine_types(document, ['**kern']))\n    return len(kp.spine_types(document, ['**kern']))\n# ['**kern', '**kern', '**kern', '**kern']\n# 4\n\ndef has_voice(document):\n    return len(kp.spine_types(document, ['**text'])) &gt; 0\n# True\n</code></pre>"},{"location":"get-started/tutorial/#how-many-measures-are-there-in-the-document-which-measures-do-you-want-to-export","title":"How many measures are there in the document? Which measures do you want to export?","text":"<p>After reading the score into the <code>Document</code> object. You can get some useful data:</p> <pre><code>first_measure: int = document.get_first_measure()\nlast_measure: int = document.measures_count()\n</code></pre> <p>Iterate over all the measures of the document.</p> <pre><code>import kernpy as kp\n\ndoc, _ = kp.load('resource_dir/legacy/chor048.krn')  # 10 measures score\nfor i in range(doc.get_first_measure(), doc.measures_count(), 1):  # from 1 to 11, step 1\n    # Export only the i-th measure (1 long measure scores)\n    content_ith_measure = kp.dumps(doc, from_measure=i, to_measure=i)\n\n    # Export the i-th measure and the next 4 measures (5 long measure scores)\n    if i + 4 &lt;= doc.measures_count():\n        content_longer = kp.dumps(doc, from_measure=i, to_measure=i + 4)\n    ...\n</code></pre> <p>It is easier to iterate over all the measures using the <code>for measure in doc</code>: loop (using the <code>__ iter__</code> method):</p> <pre><code>import kernpy as kp\n\nfor measure in doc:\n    content = kp.dumps(doc, from_measure=measure, to_measure=measure)\n    ...\n</code></pre> <p>Exploring the page bounding boxes.</p> <pre><code>import kernpy as kp\n\n# Iterate over the pages using the bounding boxes\ndoc, _ = kp.load('kern_having_bounding_boxes.krn')\n\n# Inspect the bounding boxes\nprint(doc.page_bounding_boxes)\ndef are_there_bounding_boxes(doc):\n    return len(doc.get_all_tokens(filter_by_categories=[kp.TokenCategory.BOUNDING_BOXES])) &gt; 0\n# True\n\n# Iterate over the pages\nfor page_label, bounding_box_measure in doc.page_bounding_boxes.items():\n    print(f\"Page: {page_label}\"\n          f\"Bounding box: {bounding_box_measure}\"\n          f\"from_measure: {bounding_box_measure.from_measure}\"\n          f\"to_measure+1: {bounding_box_measure.to_measure}\")  # TODO: Check bounds\n    kp.dump(doc, f\"foo_{page_label}.ekrn\",\n            spine_types=['**kern'],\n            token_categories=kp.BEKERN_CATEGORIES,\n            tokenizer=kp.KernTypeExporter.eKern,\n            from_measure=bounding_box_measure.from_measure,\n            to_measure=bounding_box_measure.to_measure - 1  # TODO: Check bounds            \n            )\n</code></pre>"},{"location":"get-started/tutorial/#merge-different-full-kern-scores","title":"Merge different full kern scores","text":"<pre><code>import kernpy as kp\n# NOT AVAILABLE YET!!!\n# Pay attention to `kp.merge` too.\n\n# Concat two valid documents\nscore_a = '**kern\\n*clefG2\\n=1\\n4c\\n4d\\n4e\\n4f\\n*-\\n'\nscore_b = '**kern\\n*clefG2\\n=1\\n4a\\n4c\\n4d\\n4c\\n*-\\n'\nconcatenated = kp.merge([score_a, score_b])\n</code></pre>"},{"location":"get-started/tutorial/#concatenate-sorted-fragments-of-the-same-score","title":"Concatenate sorted fragments of the same score","text":"<pre><code>import kernpy as kp\n\nfragment_a = '**kern\\n*clefG2\\n=1\\n4c\\n4d\\n4e\\n4f\\n*-\\n'\nfragment_b = '=2\\n4a\\n4c\\n4d\\n4c\\n*-\\n=3\\n4a\\n4c\\n4d\\n4c\\n*-\\n'\nfragment_c = '=4\\n4a\\n4c\\n4d\\n4c\\n*-\\n=5\\n4a\\n4c\\n4d\\n4c\\n*-\\n'\nfragment_d = '=6\\n4a\\n4c\\n4d\\n4c\\n*-\\n=7\\n4a\\n4c\\n4d\\n4c\\n*-\\n==*-'\nfragments = [fragment_a, fragment_b, fragment_c, fragment_d]\n\ndoc_merged, indexes = kp.concat(fragments)\nfor index_pair in indexes:\n    from_measure, to_measure = index_pair\n    print(f'From measure: {from_measure}, To measure: {to_measure}')\n    print(kp.dumps(doc_merged, from_measure=from_measure, to_measure=to_measure))\n\n# Sometimes is useful having a different separator between the fragments rather than the default one (newline)...\ndoc_merged, indexes = kp.concat(fragments, separator='')\n</code></pre>"},{"location":"get-started/tutorial/#inspect-the-document-class-functions","title":"Inspect the <code>Document</code> class functions","text":"<pre><code>import kernpy as kp\ndoc, _ = kp.load('resource_dir/legacy/chor048.krn')  # 10 measures score\n\nfrequencies = doc.frequencies()  # All the token categories\nfiltered_frequencies = doc.frequencies(filter_by_categories=[kp.TokenCategory.SIGNATURES])\nfrequencies['*k[f#c#]']\n# {\n#   'occurrences': 4,\n#   'category': SIGNATURES,\n# }\n\n# Get all the tokens in the document\nall_tokens: [kp.Token] = doc.get_all_tokens()\nall_tokens_encodings: [str] = doc.get_all_tokens_encodings()\n\n# Get the unique tokens in the document (vocabulary)\nunique_tokens: [kp.Token] = doc.get_unique_tokens()\nunique_token_encodings: [str] = doc.get_unique_token_encodings()\n\n# Get the line comments in the document\ndocument.get_metacomments()\n# ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\ndocument.get_metacomments(KeyComment='COM')\n# ['!!!COM: Coltrane']\ndocument.get_metacomments(KeyComment='COM', clear=True)\n# ['Coltrane']\ndocument.get_metacomments(KeyComment='non_existing_key')\n# []\n</code></pre>"},{"location":"get-started/tutorial/#next-steps","title":"Next steps","text":"<p>Congratulations! You have learned the basics of <code>kernpy</code>. Now you can start using the package in your projects.</p> <p>Go to the API reference to learn more about the <code>kernpy</code> API.</p>"}]}