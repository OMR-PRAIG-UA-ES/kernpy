{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kernpy Docs","text":"kernpy documentation <p>Date:  \u00a0|\u00a0 Version: 0.1.2</p> <p>Download documentation: Zipped HTML</p>"},{"location":"#useful-links","title":"Useful links:","text":"<p>Installation \u00a0|\u00a0 Source Repository \u00a0|\u00a0 Project Website (PRAIG)</p> <p><code>kernpy</code> is a python package that provides utilities for working with kern and mens data.</p>"},{"location":"#contents","title":"ContentsGetting startedHow-To guideAPI referenceAbout","text":"<p>New to <code>kernpy</code>? Check out the getting started guides. They contain an introduction to <code>kernpy</code>'s main concepts and links to additional tutorials.</p> To the getting started guides <p>The How-To guides provide in-depth information on how to perform specific tasks with <code>kernpy</code> step-by-step.</p> To the How-To guides <p>The API reference contains a detailed description of the <code>kernpy</code> API. It describes how the methods work and which parameters can be used.</p> To the API reference <p>Find out more about the <code>kernpy</code> project, including the team, how to contribute, and the license.</p> To the About page <p>Next</p> <p>Getting Started</p> <p>Previous</p> <p>Getting Started</p> <p></p> <p>Quickly find what you are looking for depending on your use case by looking at the different pages.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>University of Alicante.</p>"},{"location":"about/","title":"Who are we?","text":"<p>We are a research group <code>Pattern Recognition and Artificial Intelligence Group</code> affiliated with the University of Alicante. </p> <p>To learn more about our work, please visit our website.</p>"},{"location":"get-started/","title":"Getting started","text":""},{"location":"get-started/#installation","title":"Installation","text":"<p>Instructions for installing <code>kernpy</code> are provided below.</p>"},{"location":"get-started/#install-kernpy-using-pip","title":"Install <code>kernpy</code> using <code>pip</code>","text":"<pre><code>pip install kernpy\n</code></pre>"},{"location":"get-started/#install-the-last-version-from-the-repository","title":"Install the last version from the repository","text":"<pre><code>pip install git+https://github.com/OMR-PRAIG-UA-ES/kernpy.git \n</code></pre>"},{"location":"get-started/#install-a-specific-version-from-the-repository","title":"Install a specific version from the repository","text":"<pre><code>pip install git+https://github.com/OMR-PRAIG-UA-ES/kernpy.git@&lt;commit-tag&gt;\n</code></pre>"},{"location":"get-started/#next-steps","title":"Next steps","text":"<ul> <li>Tutorial     Learn how to use <code>kernpy</code> in a few minutes.</li> </ul>"},{"location":"how-to-guides/","title":"Guides: learn what you can do with <code>kernpy</code>","text":"<p>This section contains a series of guides that will help you get started with <code>kernpy</code> and learn how to use it to perform different tasks.</p> <ul> <li>Get started</li> </ul>"},{"location":"reference/","title":"API Reference","text":"<p>Here you can find the API reference for the <code>kernpy</code> package. The reference contains a detailed description of the <code>kernpy</code> API. The reference describes how the methods work and which parameters can be used. </p> <p>Find the basics of the <code>kernpy</code> package in the Tutorial.</p>"},{"location":"reference/#kernpy--kernpy","title":"kernpy","text":"<p>=====</p> <p>Python Humdrum kern and mens utilities package.</p> <p>Execute the following command to run kernpy as a module:</p> <pre><code>python -m kernpy --help\npython -m kernpy &lt;command&gt; &lt;options&gt;\n</code></pre> <p>Run <code>kernpy</code> from your script:</p> <pre><code>import kernpy\n\nhelp(kernpy)\n</code></pre> <p>While the package is not published in <code>pip</code>, the <code>kernpy</code> module must be in the root directory.</p>"},{"location":"reference/#kernpy--kern2ekern-convertir-un-solo-archivo-krn-a-ekern","title":"\ud83c\udfaf kern2ekern: Convertir un solo archivo .krn a .ekern:","text":"<pre><code>python -m kernpy --kern2ekern --input_path &lt;input_file&gt;  &lt;v | --verbose [0-2]&gt;\n</code></pre> <p>The command has the following arguments: * input_path: Ruta del archivo .krn a convertir. * output_path: Ruta del archivo .ekern a generar (opcional). Si no se especifica, se generar\u00e1 en la misma ubicaci\u00f3n. * -r: Recursivo (opcional). * --verbose[0-2]: Nivel de verbosidad (opcional).</p> <p>\ud83d\udccc Basic usage running kernpy as a module:</p> <pre><code>python -m kernpy --input_path /my/path/to/file.krn # New ekern generated in /my/path/to/file.ekern\n</code></pre> <p>\ud83d\udccc Generate an ekrn file in specific location running kernpy as a module:</p> <pre><code>python -m kernpy --input_path /my/path/to/file.krn --output_path /new/output.ekern\n</code></pre> <p>\ud83d\udccc Converting all the .krn files in a directory to .ekern files running kernpy as a module: * Every .krn file in the directory will be converted to .ekern in the same location. * Using, at least, one additional directory level is required.</p> <pre><code>root\n\u251c\u2500 kern-folder\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2.krn\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 3.krn\n\u251c\u2500\u2500 more-kerns\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n</code></pre> <p>Run:</p> <pre><code>python -m kernpy --input_path /my/path/to/directory/ -r\n</code></pre> <p>\u270f\ufe0f This function is also available as a python function:</p> <pre><code># converter.py\nfrom kernpy import kern_to_ekern\n\nkern_to_ekern('/my/path/to/input.krn', '/to/my/output.ekrn')\n\n# Many files\nfiles = ['file1.krn', 'file2.krn', 'file3.krn']\n[kern_to_ekern(f) for f in files]\n\n# This function raises an exception if the conversion fails.\n# Handle the errors using try-except statement if many files are going to be converted in series.\n</code></pre>"},{"location":"reference/#kernpy--ekern2kern-convertir-un-solo-archivo-ekern-a-krn","title":"\ud83c\udfaf ekern2kern: Convertir un solo archivo .ekern a .krn:","text":"<pre><code>python -m kernpy --ekern2kern --input_path &lt;input_file&gt;  &lt;--verbose [0-2]&gt;\n</code></pre> <p>The command has the following arguments: * input_path: Ruta del archivo .ekern a convertir. * output_path: Ruta del archivo .krn a generar (opcional). Si no se especifica, se generar\u00e1 en la misma ubicaci\u00f3n. * -r: Recursivo (opcional). * --verbose[0-2]: Nivel de verbosidad (opcional).</p> <ul> <li>Basic usage running kernpy as a module:</li> </ul> <pre><code>python -m kernpy --input_path /my/path/to/file.ekern # New krn generated in /my/path/to/file.krn\n</code></pre> <p>\ud83d\udccc Generate a krn file in specific location running kernpy as a module:</p> <pre><code>python -m kernpy --input_path /my/path/to/file.ekern --output_path /new/output.krn\n</code></pre> <p>\ud83d\udccc Converting all the .ekern files in a directory to .krn files running kernpy as a module:</p> <ul> <li>Every .ekrn file in the directory will be converted to .krn in the same location.</li> <li>Using, at least, one additional directory level is required.</li> </ul> <pre><code>root\n\u251c\u2500 ekern-folder\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.ekrn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2.ekrn\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 3.ekrn\n\u251c\u2500\u2500 more-ekerns\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.ekrn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n</code></pre> <p>Run:</p> <pre><code>python -m kernpy --input_path /my/path/to/directory/ -r\n</code></pre> <p>\u270f\ufe0f This function is also available as a python function:</p> <pre><code># converter.py\nfrom kernpy import ekern_to_krn\n\n# Only one file\nekern_to_krn('/my/path/to/input.ekrn', '/to/my/output.krn')\n\n# Many files\nfiles = ['file1.ekrn', 'file2.ekrn', 'file3.ekrn']\n[ekern_to_krn(f) for f in files]\n\n# This function raises an exception if the conversion fails.\n# Handle the errors using try-except statement if many files are going to be converted in series.\n</code></pre>"},{"location":"reference/#kernpy--create-fragments","title":"\ud83c\udfaf create fragments","text":"<p>Generate new valid kern files from an original kern file. Every new fragment will be a subset of the original file.</p> <p>Explore the documentation website for more information about the parameters.</p> <p>Use: - create_fragments_from_kern to generate using always the same measure length. - create_fragments_from_directory to generate using a Gaussian distribution for the measure length. Static measure is also available if the standard deviation is set to 0.</p> <p>\ud83d\udccc Create new scores from one original kern directory running kernpy as a module:</p> <pre><code>python -m kernpy --generate_fragments --input_directory /from/my/kerns --output_directory /to/my/fragments --log_file log.csv  --verbose 2 --mean 4.2 --std_dev 1.5 --offset 1 --num_processes 12\n</code></pre> <p>\u270f\ufe0f Create new scores from one original kern file:</p> <pre><code># generator.py\nfrom kernpy import create_fragments_from_kern\n\n# View docs:\nhelp(create_fragments_from_kern)\n\ncreate_fragments_from_kern('/my/path/to/input.krn', '/to/my/output_dir/',\n                           measure_length=4, offset=1,\n                           log_file='/dev/null')\n</code></pre> <p>\u270f\ufe0f Create new scores from one original kern directory: - Using, at least, one additional directory level is required.</p> <pre><code>root\n\u251c\u2500 kern-folder\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 2.krn\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 3.krn\n\u251c\u2500\u2500 more-kerns\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 1.krn\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n</code></pre> <p>Run:</p> <pre><code># generator.py\nfrom kernpy import create_fragments_from_directory\n\n# View docs:\nhelp(create_fragments_from_directory)\n\ncreate_fragments_from_directory('/my/path/to/input_dir/', '/to/my/output_dir/',\n                                mean=4.1, std_dev=0.2, offset=2,\n                                log_file='/logs/fragments.csv',\n                                num_processes=12)\n</code></pre>"},{"location":"reference/#kernpy.Intervals","title":"<code>Intervals = {-2: 'dd1', -1: 'd1', 0: 'P1', 1: 'A1', 2: 'AA1', 3: 'dd2', 4: 'd2', 5: 'm2', 6: 'M2', 7: 'A2', 8: 'AA2', 9: 'dd3', 10: 'd3', 11: 'm3', 12: 'M3', 13: 'A3', 14: 'AA3', 15: 'dd4', 16: 'd4', 17: 'P4', 18: 'A4', 19: 'AA4', 21: 'dd5', 22: 'd5', 23: 'P5', 24: 'A5', 25: 'AA5', 26: 'dd6', 27: 'd6', 28: 'm6', 29: 'M6', 30: 'A6', 31: 'AA6', 32: 'dd7', 33: 'd7', 34: 'm7', 35: 'M7', 36: 'A7', 37: 'AA7', 40: 'octave'}</code>  <code>module-attribute</code>","text":"<p>Base-40 interval classes (d=diminished, m=minor, M=major, P=perfect, A=augmented)</p>"},{"location":"reference/#kernpy.AbstractToken","title":"<code>AbstractToken</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class representing a token.</p> <p>This class serves as a blueprint for creating various types of tokens, which are categorized based on their TokenCategory.</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> <code>category</code> <code>TokenCategory</code> <p>The category of the token.</p> <code>hidden</code> <code>bool</code> <p>A flag indicating whether the token is hidden. Defaults to False.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class AbstractToken(ABC):\n    \"\"\"\n    An abstract base class representing a token.\n\n    This class serves as a blueprint for creating various types of tokens, which are\n    categorized based on their TokenCategory.\n\n    Attributes:\n        encoding (str): The original representation of the token.\n        category (TokenCategory): The category of the token.\n        hidden (bool): A flag indicating whether the token is hidden. Defaults to False.\n    \"\"\"\n\n    def __init__(self, encoding: str, category: TokenCategory):\n        \"\"\"\n        AbstractToken constructor\n\n        Args:\n            encoding (str): The original representation of the token.\n            category (TokenCategory): The category of the token.\n        \"\"\"\n        self.encoding = encoding\n        self.category = category\n        self.hidden = False\n\n    @abstractmethod\n    def export(self, **kwargs) -&gt; str:\n        \"\"\"\n        Exports the token.\n\n        Keyword Arguments:\n            filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n                indicating whether the token should be included in the export. If provided, only tokens for which the\n                function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n        Returns:\n            str: The encoded token representation, potentially filtered if a filter_categories function is provided.\n\n        Examples:\n            &gt;&gt;&gt; token = AbstractToken('*clefF4', TokenCategory.SIGNATURES)\n            &gt;&gt;&gt; token.export()\n            '*clefF4'\n            &gt;&gt;&gt; token.export(filter_categories=lambda cat: cat in {TokenCategory.SIGNATURES, TokenCategory.SIGNATURES.DURATION})\n            '*clefF4'\n        \"\"\"\n        pass\n\n\n    def __str__(self):\n        \"\"\"\n        Returns the string representation of the token.\n\n        Returns (str): The string representation of the token without processing.\n        \"\"\"\n        return self.export()\n\n    def __eq__(self, other):\n        \"\"\"\n        Compare two tokens.\n\n        Args:\n            other (AbstractToken): The other token to compare.\n        Returns (bool): True if the tokens are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, AbstractToken):\n            return False\n        return self.encoding == other.encoding and self.category == other.category\n\n    def __ne__(self, other):\n        \"\"\"\n        Compare two tokens.\n\n        Args:\n            other (AbstractToken): The other token to compare.\n        Returns (bool): True if the tokens are different, False otherwise.\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        \"\"\"\n        Returns the hash of the token.\n\n        Returns (int): The hash of the token.\n        \"\"\"\n        return hash((self.export(), self.category))\n</code></pre>"},{"location":"reference/#kernpy.AbstractToken.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two tokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>AbstractToken</code> <p>The other token to compare.</p> required <p>Returns (bool): True if the tokens are equal, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compare two tokens.\n\n    Args:\n        other (AbstractToken): The other token to compare.\n    Returns (bool): True if the tokens are equal, False otherwise.\n    \"\"\"\n    if not isinstance(other, AbstractToken):\n        return False\n    return self.encoding == other.encoding and self.category == other.category\n</code></pre>"},{"location":"reference/#kernpy.AbstractToken.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the token.</p> <p>Returns (int): The hash of the token.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Returns the hash of the token.\n\n    Returns (int): The hash of the token.\n    \"\"\"\n    return hash((self.export(), self.category))\n</code></pre>"},{"location":"reference/#kernpy.AbstractToken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>AbstractToken constructor</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>category</code> <code>TokenCategory</code> <p>The category of the token.</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding: str, category: TokenCategory):\n    \"\"\"\n    AbstractToken constructor\n\n    Args:\n        encoding (str): The original representation of the token.\n        category (TokenCategory): The category of the token.\n    \"\"\"\n    self.encoding = encoding\n    self.category = category\n    self.hidden = False\n</code></pre>"},{"location":"reference/#kernpy.AbstractToken.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two tokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>AbstractToken</code> <p>The other token to compare.</p> required <p>Returns (bool): True if the tokens are different, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ne__(self, other):\n    \"\"\"\n    Compare two tokens.\n\n    Args:\n        other (AbstractToken): The other token to compare.\n    Returns (bool): True if the tokens are different, False otherwise.\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.AbstractToken.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the token.</p> <p>Returns (str): The string representation of the token without processing.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Returns the string representation of the token.\n\n    Returns (str): The string representation of the token without processing.\n    \"\"\"\n    return self.export()\n</code></pre>"},{"location":"reference/#kernpy.AbstractToken.export","title":"<code>export(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded token representation, potentially filtered if a filter_categories function is provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token = AbstractToken('*clefF4', TokenCategory.SIGNATURES)\n&gt;&gt;&gt; token.export()\n'*clefF4'\n&gt;&gt;&gt; token.export(filter_categories=lambda cat: cat in {TokenCategory.SIGNATURES, TokenCategory.SIGNATURES.DURATION})\n'*clefF4'\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@abstractmethod\ndef export(self, **kwargs) -&gt; str:\n    \"\"\"\n    Exports the token.\n\n    Keyword Arguments:\n        filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n            indicating whether the token should be included in the export. If provided, only tokens for which the\n            function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n    Returns:\n        str: The encoded token representation, potentially filtered if a filter_categories function is provided.\n\n    Examples:\n        &gt;&gt;&gt; token = AbstractToken('*clefF4', TokenCategory.SIGNATURES)\n        &gt;&gt;&gt; token.export()\n        '*clefF4'\n        &gt;&gt;&gt; token.export(filter_categories=lambda cat: cat in {TokenCategory.SIGNATURES, TokenCategory.SIGNATURES.DURATION})\n        '*clefF4'\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#kernpy.AgnosticPitch","title":"<code>AgnosticPitch</code>","text":"<p>Represents a pitch in a generic way, independent of the notation system used.</p> Source code in <code>kernpy/core/pitch_models.py</code> <pre><code>class AgnosticPitch:\n    \"\"\"\n    Represents a pitch in a generic way, independent of the notation system used.\n    \"\"\"\n\n    ASCENDANT_ACCIDENTAL_ALTERATION = '+'\n    DESCENDENT_ACCIDENTAL_ALTERATION = '-'\n    ACCIDENTAL_ALTERATIONS = {\n        ASCENDANT_ACCIDENTAL_ALTERATION,\n        DESCENDENT_ACCIDENTAL_ALTERATION\n    }\n\n\n    def __init__(self, name: str, octave: int):\n        \"\"\"\n        Initialize the AgnosticPitch object.\n\n        Args:\n            name (str): The name of the pitch (e.g., 'C', 'D#', 'Bb').\n            octave (int): The octave of the pitch (e.g., 4 for middle C).\n        \"\"\"\n        self.name = name\n        self.octave = octave\n\n    @property\n    def name(self):\n        return self.__name\n\n    @name.setter\n    def name(self, name):\n        accidentals = ''.join([c for c in name if c in ['-', '+']])\n        name = name.upper()\n        name = name.replace('#', '+').replace('b', '-')\n\n        check_name = name.replace('+', '').replace('-', '')\n        if check_name not in pitches:\n            raise ValueError(f\"Invalid pitch: {name}\")\n        if len(accidentals) &gt; 3:\n            raise ValueError(f\"Invalid pitch: {name}. Maximum of 3 accidentals allowed. \")\n        self.__name = name\n\n    @property\n    def octave(self):\n        return self.__octave\n\n    @octave.setter\n    def octave(self, octave):\n        if not isinstance(octave, int):\n            raise ValueError(f\"Invalid octave: {octave}\")\n        self.__octave = octave\n\n    def get_chroma(self):\n        return 40 * self.octave + Chromas[self.name]\n\n    @classmethod\n    def to_transposed(cls, agnostic_pitch: 'AgnosticPitch', raw_interval, direction: str = Direction.UP.value) -&gt; 'AgnosticPitch':\n        delta = raw_interval if direction == Direction.UP.value else - raw_interval\n        chroma = agnostic_pitch.get_chroma() + delta\n        name = ChromasByValue[chroma % 40]\n        octave = chroma // 40\n        return AgnosticPitch(name, octave)\n\n    @classmethod\n    def get_chroma_from_interval(cls, pitch_a: 'AgnosticPitch', pitch_b: 'AgnosticPitch'):\n        return pitch_b.get_chroma() - pitch_a.get_chroma()\n\n    def __str__(self):\n        return f\"&lt;{self.name}, {self.octave}&gt;\"\n\n    def __repr__(self):\n        return f\"{self.__name}(name={self.name}, octave={self.octave})\"\n\n    def __eq__(self, other):\n        if not isinstance(other, AgnosticPitch):\n            return False\n        return self.name == other.name and self.octave == other.octave\n\n    def __ne__(self, other):\n        if not isinstance(other, AgnosticPitch):\n            return True\n        return self.name != other.name or self.octave != other.octave\n\n    def __hash__(self):\n        return hash((self.name, self.octave))\n\n    def __lt__(self, other):\n        if not isinstance(other, AgnosticPitch):\n            return NotImplemented\n        if self.octave == other.octave:\n            return Chromas[self.name] &lt; Chromas[other.name]\n        return self.octave &lt; other.octave\n\n    def __gt__(self, other):\n        if not isinstance(other, AgnosticPitch):\n            return NotImplemented\n        if self.octave == other.octave:\n            return Chromas[self.name] &gt; Chromas[other.name]\n        return self.octave &gt; other.octave\n</code></pre>"},{"location":"reference/#kernpy.AgnosticPitch.__init__","title":"<code>__init__(name, octave)</code>","text":"<p>Initialize the AgnosticPitch object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the pitch (e.g., 'C', 'D#', 'Bb').</p> required <code>octave</code> <code>int</code> <p>The octave of the pitch (e.g., 4 for middle C).</p> required Source code in <code>kernpy/core/pitch_models.py</code> <pre><code>def __init__(self, name: str, octave: int):\n    \"\"\"\n    Initialize the AgnosticPitch object.\n\n    Args:\n        name (str): The name of the pitch (e.g., 'C', 'D#', 'Bb').\n        octave (int): The octave of the pitch (e.g., 4 for middle C).\n    \"\"\"\n    self.name = name\n    self.octave = octave\n</code></pre>"},{"location":"reference/#kernpy.BasicSpineImporter","title":"<code>BasicSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/basic_spine_importer.py</code> <pre><code>class BasicSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()  # TODO: Create a custom functional listener for BasicSpineImporter\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.BARLINES,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if not any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.OTHER)\n\n        return token\n</code></pre>"},{"location":"reference/#kernpy.BasicSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/basic_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.BekernTokenizer","title":"<code>BekernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>BekernTokenizer converts a Token into a bekern (Basic Extended **kern) string representation. This format use a '@' separator for the     main tokens but discards all the decorations tokens.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class BekernTokenizer(Tokenizer):\n    \"\"\"\n    BekernTokenizer converts a Token into a bekern (Basic Extended **kern) string representation. This format use a '@' separator for the \\\n    main tokens but discards all the decorations tokens.\n    \"\"\"\n\n    def __init__(self, *, token_categories: Set['TokenCategory']):\n        \"\"\"\n        Create a new BekernTokenizer\n\n        Args:\n            token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n        \"\"\"\n        super().__init__(token_categories=token_categories)\n\n    def tokenize(self, token: Token) -&gt; str:\n        \"\"\"\n        Tokenize a token into a bekern string representation.\n        Args:\n            token (Token): Token to be tokenized.\n\n        Returns (str): bekern string representation.\n\n        Examples:\n            &gt;&gt;&gt; token.encoding\n            '2@.@bb@-\u00b7_\u00b7L'\n            &gt;&gt;&gt; BekernTokenizer().tokenize(token)\n            '2@.@bb@-'\n        \"\"\"\n        ekern_content = token.export(filter_categories=lambda cat: cat in self.token_categories)\n\n        if DECORATION_SEPARATOR not in ekern_content:\n            return ekern_content\n\n        reduced_content = ekern_content.split(DECORATION_SEPARATOR)[0]\n        if reduced_content.endswith(TOKEN_SEPARATOR):\n            reduced_content = reduced_content[:-1]\n\n        return reduced_content\n</code></pre>"},{"location":"reference/#kernpy.BekernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new BekernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def __init__(self, *, token_categories: Set['TokenCategory']):\n    \"\"\"\n    Create a new BekernTokenizer\n\n    Args:\n        token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n    \"\"\"\n    super().__init__(token_categories=token_categories)\n</code></pre>"},{"location":"reference/#kernpy.BekernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a bekern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): bekern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; BekernTokenizer().tokenize(token)\n'2@.@bb@-'\n</code></pre> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def tokenize(self, token: Token) -&gt; str:\n    \"\"\"\n    Tokenize a token into a bekern string representation.\n    Args:\n        token (Token): Token to be tokenized.\n\n    Returns (str): bekern string representation.\n\n    Examples:\n        &gt;&gt;&gt; token.encoding\n        '2@.@bb@-\u00b7_\u00b7L'\n        &gt;&gt;&gt; BekernTokenizer().tokenize(token)\n        '2@.@bb@-'\n    \"\"\"\n    ekern_content = token.export(filter_categories=lambda cat: cat in self.token_categories)\n\n    if DECORATION_SEPARATOR not in ekern_content:\n        return ekern_content\n\n    reduced_content = ekern_content.split(DECORATION_SEPARATOR)[0]\n    if reduced_content.endswith(TOKEN_SEPARATOR):\n        reduced_content = reduced_content[:-1]\n\n    return reduced_content\n</code></pre>"},{"location":"reference/#kernpy.BkernTokenizer","title":"<code>BkernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>BkernTokenizer converts a Token into a bkern (Basic kern) string representation. This format use     the main tokens but not the decorations tokens. This format is a lightweight version of the classic Humdrum kern format.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class BkernTokenizer(Tokenizer):\n    \"\"\"\n    BkernTokenizer converts a Token into a bkern (Basic **kern) string representation. This format use \\\n    the main tokens but not the decorations tokens. This format is a lightweight version of the classic\n    Humdrum **kern format.\n    \"\"\"\n\n    def __init__(self, *, token_categories: Set['TokenCategory']):\n        \"\"\"\n        Create a new BkernTokenizer\n\n        Args:\n            token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n        \"\"\"\n        super().__init__(token_categories=token_categories)\n\n\n    def tokenize(self, token: Token) -&gt; str:\n        \"\"\"\n        Tokenize a token into a bkern string representation.\n        Args:\n            token (Token): Token to be tokenized.\n\n        Returns (str): bkern string representation.\n\n        Examples:\n            &gt;&gt;&gt; token.encoding\n            '2@.@bb@-\u00b7_\u00b7L'\n            &gt;&gt;&gt; BkernTokenizer().tokenize(token)\n            '2.bb-'\n        \"\"\"\n        return BekernTokenizer(token_categories=self.token_categories).tokenize(token).replace(TOKEN_SEPARATOR, '')\n</code></pre>"},{"location":"reference/#kernpy.BkernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new BkernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def __init__(self, *, token_categories: Set['TokenCategory']):\n    \"\"\"\n    Create a new BkernTokenizer\n\n    Args:\n        token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n    \"\"\"\n    super().__init__(token_categories=token_categories)\n</code></pre>"},{"location":"reference/#kernpy.BkernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a bkern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): bkern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; BkernTokenizer().tokenize(token)\n'2.bb-'\n</code></pre> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def tokenize(self, token: Token) -&gt; str:\n    \"\"\"\n    Tokenize a token into a bkern string representation.\n    Args:\n        token (Token): Token to be tokenized.\n\n    Returns (str): bkern string representation.\n\n    Examples:\n        &gt;&gt;&gt; token.encoding\n        '2@.@bb@-\u00b7_\u00b7L'\n        &gt;&gt;&gt; BkernTokenizer().tokenize(token)\n        '2.bb-'\n    \"\"\"\n    return BekernTokenizer(token_categories=self.token_categories).tokenize(token).replace(TOKEN_SEPARATOR, '')\n</code></pre>"},{"location":"reference/#kernpy.C1Clef","title":"<code>C1Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class C1Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the C Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('C'), 1)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('C', 3)\n</code></pre>"},{"location":"reference/#kernpy.C1Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the C Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('C'), 1)\n</code></pre>"},{"location":"reference/#kernpy.C1Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('C', 3)\n</code></pre>"},{"location":"reference/#kernpy.C2Clef","title":"<code>C2Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class C2Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the C Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('A'), 2)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('A', 2)\n</code></pre>"},{"location":"reference/#kernpy.C2Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the C Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('A'), 2)\n</code></pre>"},{"location":"reference/#kernpy.C2Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('A', 2)\n</code></pre>"},{"location":"reference/#kernpy.C3Clef","title":"<code>C3Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class C3Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the C Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('C'), 3)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('B', 2)\n</code></pre>"},{"location":"reference/#kernpy.C3Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the C Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('C'), 3)\n</code></pre>"},{"location":"reference/#kernpy.C3Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('B', 2)\n</code></pre>"},{"location":"reference/#kernpy.C4Clef","title":"<code>C4Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class C4Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the C Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('C'), 4)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('D', 2)\n</code></pre>"},{"location":"reference/#kernpy.C4Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the C Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('C'), 4)\n</code></pre>"},{"location":"reference/#kernpy.C4Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('D', 2)\n</code></pre>"},{"location":"reference/#kernpy.Clef","title":"<code>Clef</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class representing a clef.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class Clef(ABC):\n    \"\"\"\n    Abstract class representing a clef.\n    \"\"\"\n\n    def __init__(self, diatonic_pitch: DiatonicPitch, on_line: int):\n        \"\"\"\n        Initializes the Clef object.\n        Args:\n            diatonic_pitch (DiatonicPitch): The diatonic pitch of the clef (e.g., 'C', 'G', 'F'). This value is used as a decorator.\n            on_line (int): The line number on which the clef is placed (1 for bottom line, 2 for 1st line from bottom, etc.). This value is used as a decorator.\n        \"\"\"\n        self.diatonic_pitch = diatonic_pitch\n        self.on_line = on_line\n\n    @abstractmethod\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        ...\n\n    def name(self):\n        \"\"\"\n        Returns the name of the clef.\n        \"\"\"\n        return f\"{self.diatonic_pitch} on line {self.on_line}\"\n\n    def reference_point(self) -&gt; PitchPositionReferenceSystem:\n        \"\"\"\n        Returns the reference point for the clef.\n        \"\"\"\n        return PitchPositionReferenceSystem(self.bottom_line())\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns:\n            str: The string representation of the clef.\n        \"\"\"\n        return f'{self.diatonic_pitch.encoding.upper()} on the {self.on_line}{self._ordinal_suffix(self.on_line)} line'\n\n    @staticmethod\n    def _ordinal_suffix(number: int) -&gt; str:\n        \"\"\"\n        Returns the ordinal suffix for a given integer (e.g. 'st', 'nd', 'rd', 'th').\n\n        Args:\n            number (int): The number to get the suffix for.\n\n        Returns:\n            str: The ordinal suffix.\n        \"\"\"\n        # 11, 12, 13 always take \u201cth\u201d\n        if 11 &lt;= (number % 100) &lt;= 13:\n            return 'th'\n        # otherwise use last digit\n        last = number % 10\n        if last == 1:\n            return 'st'\n        elif last == 2:\n            return 'nd'\n        elif last == 3:\n            return 'rd'\n        else:\n            return 'th'\n</code></pre>"},{"location":"reference/#kernpy.Clef.__init__","title":"<code>__init__(diatonic_pitch, on_line)</code>","text":"<p>Initializes the Clef object. Args:     diatonic_pitch (DiatonicPitch): The diatonic pitch of the clef (e.g., 'C', 'G', 'F'). This value is used as a decorator.     on_line (int): The line number on which the clef is placed (1 for bottom line, 2 for 1st line from bottom, etc.). This value is used as a decorator.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self, diatonic_pitch: DiatonicPitch, on_line: int):\n    \"\"\"\n    Initializes the Clef object.\n    Args:\n        diatonic_pitch (DiatonicPitch): The diatonic pitch of the clef (e.g., 'C', 'G', 'F'). This value is used as a decorator.\n        on_line (int): The line number on which the clef is placed (1 for bottom line, 2 for 1st line from bottom, etc.). This value is used as a decorator.\n    \"\"\"\n    self.diatonic_pitch = diatonic_pitch\n    self.on_line = on_line\n</code></pre>"},{"location":"reference/#kernpy.Clef.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation of the clef.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns:\n        str: The string representation of the clef.\n    \"\"\"\n    return f'{self.diatonic_pitch.encoding.upper()} on the {self.on_line}{self._ordinal_suffix(self.on_line)} line'\n</code></pre>"},{"location":"reference/#kernpy.Clef.bottom_line","title":"<code>bottom_line()</code>  <code>abstractmethod</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>@abstractmethod\ndef bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/#kernpy.Clef.name","title":"<code>name()</code>","text":"<p>Returns the name of the clef.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def name(self):\n    \"\"\"\n    Returns the name of the clef.\n    \"\"\"\n    return f\"{self.diatonic_pitch} on line {self.on_line}\"\n</code></pre>"},{"location":"reference/#kernpy.Clef.reference_point","title":"<code>reference_point()</code>","text":"<p>Returns the reference point for the clef.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def reference_point(self) -&gt; PitchPositionReferenceSystem:\n    \"\"\"\n    Returns the reference point for the clef.\n    \"\"\"\n    return PitchPositionReferenceSystem(self.bottom_line())\n</code></pre>"},{"location":"reference/#kernpy.ClefFactory","title":"<code>ClefFactory</code>","text":"Source code in <code>kernpy/core/gkern.py</code> <pre><code>class ClefFactory:\n    CLEF_NAMES = { 'G', 'F', 'C' }\n    @classmethod\n    def create_clef(cls, encoding: str) -&gt; Clef:\n        \"\"\"\n        Creates a Clef object based on the given token.\n\n        Clefs are encoded in interpretation tokens that start with a single * followed by the string clef and then the shape and line position of the clef. For example, a treble clef is *clefG2, with G meaning a G-clef, and 2 meaning that the clef is centered on the second line up from the bottom of the staff. The bass clef is *clefF4 since it is an F-clef on the fourth line of the staff.\n        A vocal tenor clef is represented by *clefGv2, where the v means the music should be played an octave lower than the regular clef\u2019s sounding pitches. Try creating a vocal tenor clef in the above interactive example. The v operator also works on the other clefs (but these sorts of clefs are very rare). Another rare clef is *clefG^2 which is the opposite of *clefGv2, where the music is written an octave lower than actually sounding pitch for the normal form of the clef. You can also try to create exotic two-octave clefs by doubling the ^^ and vv markers.\n\n        Args:\n            encoding (str): The encoding of the clef token.\n\n        Returns:\n\n        \"\"\"\n        encoding = encoding.replace('*clef', '')\n\n        # at this point the encoding is like G2, F4,... or Gv2, F^4,... or G^^2, Fvv4,... or G^^...^^2, Fvvv4,...\n        name = list(filter(lambda x: x in cls.CLEF_NAMES, encoding))[0]\n        line = int(list(filter(lambda x: x.isdigit(), encoding))[0])\n        decorators = ''.join(filter(lambda x: x in ['^', 'v'], encoding))\n\n        if name not in cls.CLEF_NAMES:\n            raise ValueError(f\"Invalid clef name: {name}. Expected one of {cls.CLEF_NAMES}.\")\n\n        if name == 'G':\n            return GClef()\n        elif name == 'F':\n            if line == 3:\n                return F3Clef()\n            elif line == 4:\n                return F4Clef()\n            else:\n                raise ValueError(f\"Invalid F clef line: {line}. Expected 3 or 4.\")\n        elif name == 'C':\n            if line == 1:\n                return C1Clef()\n            elif line == 2:\n                return C2Clef()\n            elif line == 3:\n                return C3Clef()\n            elif line == 4:\n                return C4Clef()\n            else:\n                raise ValueError(f\"Invalid C clef line: {line}. Expected 1, 2, 3 or 4.\")\n        else:\n            raise ValueError(f\"Invalid clef name: {name}. Expected one of {cls.CLEF_NAMES}.\")\n</code></pre>"},{"location":"reference/#kernpy.ClefFactory.create_clef","title":"<code>create_clef(encoding)</code>  <code>classmethod</code>","text":"<p>Creates a Clef object based on the given token.</p> <p>Clefs are encoded in interpretation tokens that start with a single * followed by the string clef and then the shape and line position of the clef. For example, a treble clef is clefG2, with G meaning a G-clef, and 2 meaning that the clef is centered on the second line up from the bottom of the staff. The bass clef is clefF4 since it is an F-clef on the fourth line of the staff. A vocal tenor clef is represented by clefGv2, where the v means the music should be played an octave lower than the regular clef\u2019s sounding pitches. Try creating a vocal tenor clef in the above interactive example. The v operator also works on the other clefs (but these sorts of clefs are very rare). Another rare clef is clefG^2 which is the opposite of *clefGv2, where the music is written an octave lower than actually sounding pitch for the normal form of the clef. You can also try to create exotic two-octave clefs by doubling the ^^ and vv markers.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The encoding of the clef token.</p> required <p>Returns:</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>@classmethod\ndef create_clef(cls, encoding: str) -&gt; Clef:\n    \"\"\"\n    Creates a Clef object based on the given token.\n\n    Clefs are encoded in interpretation tokens that start with a single * followed by the string clef and then the shape and line position of the clef. For example, a treble clef is *clefG2, with G meaning a G-clef, and 2 meaning that the clef is centered on the second line up from the bottom of the staff. The bass clef is *clefF4 since it is an F-clef on the fourth line of the staff.\n    A vocal tenor clef is represented by *clefGv2, where the v means the music should be played an octave lower than the regular clef\u2019s sounding pitches. Try creating a vocal tenor clef in the above interactive example. The v operator also works on the other clefs (but these sorts of clefs are very rare). Another rare clef is *clefG^2 which is the opposite of *clefGv2, where the music is written an octave lower than actually sounding pitch for the normal form of the clef. You can also try to create exotic two-octave clefs by doubling the ^^ and vv markers.\n\n    Args:\n        encoding (str): The encoding of the clef token.\n\n    Returns:\n\n    \"\"\"\n    encoding = encoding.replace('*clef', '')\n\n    # at this point the encoding is like G2, F4,... or Gv2, F^4,... or G^^2, Fvv4,... or G^^...^^2, Fvvv4,...\n    name = list(filter(lambda x: x in cls.CLEF_NAMES, encoding))[0]\n    line = int(list(filter(lambda x: x.isdigit(), encoding))[0])\n    decorators = ''.join(filter(lambda x: x in ['^', 'v'], encoding))\n\n    if name not in cls.CLEF_NAMES:\n        raise ValueError(f\"Invalid clef name: {name}. Expected one of {cls.CLEF_NAMES}.\")\n\n    if name == 'G':\n        return GClef()\n    elif name == 'F':\n        if line == 3:\n            return F3Clef()\n        elif line == 4:\n            return F4Clef()\n        else:\n            raise ValueError(f\"Invalid F clef line: {line}. Expected 3 or 4.\")\n    elif name == 'C':\n        if line == 1:\n            return C1Clef()\n        elif line == 2:\n            return C2Clef()\n        elif line == 3:\n            return C3Clef()\n        elif line == 4:\n            return C4Clef()\n        else:\n            raise ValueError(f\"Invalid C clef line: {line}. Expected 1, 2, 3 or 4.\")\n    else:\n        raise ValueError(f\"Invalid clef name: {name}. Expected one of {cls.CLEF_NAMES}.\")\n</code></pre>"},{"location":"reference/#kernpy.ComplexToken","title":"<code>ComplexToken</code>","text":"<p>               Bases: <code>Token</code>, <code>ABC</code></p> <p>Abstract ComplexToken class. This abstract class ensures that the subclasses implement the export method using     the 'filter_categories' parameter to filter the subtokens.</p> <p>Passing the argument 'filter_categories' by **kwargs don't break the compatibility with parent classes.</p> <p>Here we're trying to get the Liskov substitution principle done...</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class ComplexToken(Token, ABC):\n    \"\"\"\n    Abstract ComplexToken class. This abstract class ensures that the subclasses implement the export method using\\\n     the 'filter_categories' parameter to filter the subtokens.\n\n     Passing the argument 'filter_categories' by **kwargs don't break the compatibility with parent classes.\n\n     Here we're trying to get the Liskov substitution principle done...\n    \"\"\"\n    def __init__(self, encoding: str, category: TokenCategory):\n        \"\"\"\n        Constructor for the ComplexToken\n\n        Args:\n            encoding (str): The original representation of the token.\n            category (TokenCategory) : The category of the token.\n        \"\"\"\n        super().__init__(encoding, category)\n\n    @abstractmethod\n    def export(self, **kwargs) -&gt; str:\n        \"\"\"\n        Exports the token.\n\n        Keyword Arguments:\n            filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n                indicating whether the token should be included in the export. If provided, only tokens for which the\n                function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n        Returns (str): The exported token.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/#kernpy.ComplexToken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>Constructor for the ComplexToken</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>category</code> <code>TokenCategory) </code> <p>The category of the token.</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding: str, category: TokenCategory):\n    \"\"\"\n    Constructor for the ComplexToken\n\n    Args:\n        encoding (str): The original representation of the token.\n        category (TokenCategory) : The category of the token.\n    \"\"\"\n    super().__init__(encoding, category)\n</code></pre>"},{"location":"reference/#kernpy.ComplexToken.export","title":"<code>export(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@abstractmethod\ndef export(self, **kwargs) -&gt; str:\n    \"\"\"\n    Exports the token.\n\n    Keyword Arguments:\n        filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n            indicating whether the token should be included in the export. If provided, only tokens for which the\n            function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n    Returns (str): The exported token.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#kernpy.CompoundToken","title":"<code>CompoundToken</code>","text":"<p>               Bases: <code>ComplexToken</code></p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class CompoundToken(ComplexToken):\n    def __init__(self, encoding: str, category: TokenCategory, subtokens: List[Subtoken]):\n        \"\"\"\n        Args:\n            encoding (str): The complete unprocessed encoding\n            category (TokenCategory): The token category, one of 'TokenCategory'\n            subtokens (List[Subtoken]): The individual elements of the token. Also of type 'TokenCategory' but \\\n                in the hierarchy they must be children of the current token.\n        \"\"\"\n        super().__init__(encoding, category)\n\n        for subtoken in subtokens:\n            if not isinstance(subtoken, Subtoken):\n                raise ValueError(f'All subtokens must be instances of Subtoken. Found {type(subtoken)}')\n\n        self.subtokens = subtokens\n\n    def export(self, **kwargs) -&gt; str:\n        \"\"\"\n        Exports the token.\n\n        Keyword Arguments:\n            filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n                indicating whether the token should be included in the export. If provided, only tokens for which the\n                function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n        Returns (str): The exported token.\n        \"\"\"\n        filter_categories_fn = kwargs.get('filter_categories', None)\n        parts = []\n        for subtoken in self.subtokens:\n            # Only export the subtoken if it passes the filter_categories (if provided)\n            if filter_categories_fn is None or filter_categories_fn(subtoken.category):\n                # parts.append(subtoken.export(**kwargs)) in the future when SubTokens will be Tokens\n                parts.append(subtoken.encoding)\n        return TOKEN_SEPARATOR.join(parts) if len(parts) &gt; 0 else EMPTY_TOKEN\n</code></pre>"},{"location":"reference/#kernpy.CompoundToken.__init__","title":"<code>__init__(encoding, category, subtokens)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>category</code> <code>TokenCategory</code> <p>The token category, one of 'TokenCategory'</p> required <code>subtokens</code> <code>List[Subtoken]</code> <p>The individual elements of the token. Also of type 'TokenCategory' but                 in the hierarchy they must be children of the current token.</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding: str, category: TokenCategory, subtokens: List[Subtoken]):\n    \"\"\"\n    Args:\n        encoding (str): The complete unprocessed encoding\n        category (TokenCategory): The token category, one of 'TokenCategory'\n        subtokens (List[Subtoken]): The individual elements of the token. Also of type 'TokenCategory' but \\\n            in the hierarchy they must be children of the current token.\n    \"\"\"\n    super().__init__(encoding, category)\n\n    for subtoken in subtokens:\n        if not isinstance(subtoken, Subtoken):\n            raise ValueError(f'All subtokens must be instances of Subtoken. Found {type(subtoken)}')\n\n    self.subtokens = subtokens\n</code></pre>"},{"location":"reference/#kernpy.CompoundToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def export(self, **kwargs) -&gt; str:\n    \"\"\"\n    Exports the token.\n\n    Keyword Arguments:\n        filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n            indicating whether the token should be included in the export. If provided, only tokens for which the\n            function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n    Returns (str): The exported token.\n    \"\"\"\n    filter_categories_fn = kwargs.get('filter_categories', None)\n    parts = []\n    for subtoken in self.subtokens:\n        # Only export the subtoken if it passes the filter_categories (if provided)\n        if filter_categories_fn is None or filter_categories_fn(subtoken.category):\n            # parts.append(subtoken.export(**kwargs)) in the future when SubTokens will be Tokens\n            parts.append(subtoken.encoding)\n    return TOKEN_SEPARATOR.join(parts) if len(parts) &gt; 0 else EMPTY_TOKEN\n</code></pre>"},{"location":"reference/#kernpy.Document","title":"<code>Document</code>","text":"<p>Document class.</p> <p>This class store the score content using an agnostic tree structure.</p> <p>Attributes:</p> Name Type Description <code>tree</code> <code>MultistageTree</code> <p>The tree structure of the document where all the nodes are stored.             Each stage of the tree corresponds to a row in the Humdrum **kern file encoding.</p> <code>measure_start_tree_stages</code> <code>List[List[Node]]</code> <p>The list of nodes that corresponds to the measures.             Empty list by default. The index of the list is starting from 1. Rows after removing empty lines and line comments</p> <code>page_bounding_boxes</code> <code>Dict[int, BoundingBoxMeasures]</code> <p>The dictionary of page bounding boxes.             - key: page number - value: BoundingBoxMeasures object</p> <code>header_stage</code> <code>int</code> <p>The index of the stage that contains the headers. None by default.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>class Document:\n    \"\"\"\n    Document class.\n\n    This class store the score content using an agnostic tree structure.\n\n    Attributes:\n        tree (MultistageTree): The tree structure of the document where all the nodes are stored. \\\n            Each stage of the tree corresponds to a row in the Humdrum **kern file encoding.\n        measure_start_tree_stages (List[List[Node]]): The list of nodes that corresponds to the measures. \\\n            Empty list by default.\n            The index of the list is starting from 1. Rows after removing empty lines and line comments\n        page_bounding_boxes (Dict[int, BoundingBoxMeasures]): The dictionary of page bounding boxes. \\\n            - key: page number\n            - value: BoundingBoxMeasures object\n        header_stage (int): The index of the stage that contains the headers. None by default.\n    \"\"\"\n\n    def __init__(self, tree: MultistageTree):\n        \"\"\"\n        Constructor for Document class.\n\n        Args:\n            tree (MultistageTree): The tree structure of the document where all the nodes are stored.\n        \"\"\"\n        self.tree = tree  # TODO: ? Should we use copy.deepcopy() here?\n        self.measure_start_tree_stages = []\n        self.page_bounding_boxes = {}\n        self.header_stage = None\n\n    FIRST_MEASURE = 1\n\n    def get_header_stage(self) -&gt; Union[List[Node], List[List[Node]]]:\n        \"\"\"\n        Get the Node list of the header stage.\n\n        Returns: (Union[List[Node], List[List[Node]]]) The Node list of the header stage.\n\n        Raises: Exception - If the document has no header stage.\n        \"\"\"\n        if self.header_stage:\n            return self.tree.stages[self.header_stage]\n        else:\n            raise Exception('No header stage found')\n\n    def get_leaves(self) -&gt; List[Node]:\n        \"\"\"\n        Get the leaves of the tree.\n\n        Returns: (List[Node]) The leaves of the tree.\n        \"\"\"\n        return self.tree.stages[len(self.tree.stages) - 1]\n\n    def get_spine_count(self) -&gt; int:\n        \"\"\"\n        Get the number of spines in the document.\n\n        Returns (int): The number of spines in the document.\n        \"\"\"\n        return len(self.get_header_stage())  # TODO: test refactor\n\n    def get_first_measure(self) -&gt; int:\n        \"\"\"\n        Get the index of the first measure of the document.\n\n        Returns: (Int) The index of the first measure of the document.\n\n        Raises: Exception - If the document has no measures.\n\n        Examples:\n            &gt;&gt;&gt; import kernpy as kp\n            &gt;&gt;&gt; document, err = kp.read('score.krn')\n            &gt;&gt;&gt; document.get_first_measure()\n            1\n        \"\"\"\n        if len(self.measure_start_tree_stages) == 0:\n            raise Exception('No measures found')\n\n        return self.FIRST_MEASURE\n\n    def measures_count(self) -&gt; int:\n        \"\"\"\n        Get the index of the last measure of the document.\n\n        Returns: (Int) The index of the last measure of the document.\n\n        Raises: Exception - If the document has no measures.\n\n        Examples:\n            &gt;&gt;&gt; document, _ = kernpy.read('score.krn')\n            &gt;&gt;&gt; document.measures_count()\n            10\n            &gt;&gt;&gt; for i in range(document.get_first_measure(), document.measures_count() + 1):\n            &gt;&gt;&gt;   options = kernpy.ExportOptions(from_measure=i, to_measure=i+4)\n        \"\"\"\n        if len(self.measure_start_tree_stages) == 0:\n            raise Exception('No measures found')\n\n        return len(self.measure_start_tree_stages)\n\n    def get_metacomments(self, KeyComment: Optional[str] = None, clear: bool = False) -&gt; List[str]:\n        \"\"\"\n        Get all metacomments in the document\n\n        Args:\n            KeyComment: Filter by a specific metacomment key: e.g. Use 'COM' to get only comments starting with\\\n                '!!!COM: '. If None, all metacomments are returned.\n            clear: If True, the metacomment key is removed from the comment. E.g. '!!!COM: Coltrane' -&gt; 'Coltrane'.\\\n                If False, the metacomment key is kept. E.g. '!!!COM: Coltrane' -&gt; '!!!COM: Coltrane'. \\\n                The clear functionality is equivalent to the following code:\n                ```python\n                comment = '!!!COM: Coltrane'\n                clean_comment = comment.replace(f\"!!!{KeyComment}: \", \"\")\n                ```\n                Other formats are not supported.\n\n        Returns: A list of metacomments.\n\n        Examples:\n            &gt;&gt;&gt; document.get_metacomments()\n            ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n            &gt;&gt;&gt; document.get_metacomments(KeyComment='COM')\n            ['!!!COM: Coltrane']\n            &gt;&gt;&gt; document.get_metacomments(KeyComment='COM', clear=True)\n            ['Coltrane']\n            &gt;&gt;&gt; document.get_metacomments(KeyComment='non_existing_key')\n            []\n        \"\"\"\n        traversal = MetacommentsTraversal()\n        self.tree.dfs_iterative(traversal)\n        result = []\n        for metacomment in traversal.metacomments:\n            if KeyComment is None or metacomment.encoding.startswith(f\"!!!{KeyComment}\"):\n                new_comment = metacomment.encoding\n                if clear:\n                    new_comment = metacomment.encoding.replace(f\"!!!{KeyComment}: \", \"\")\n                result.append(new_comment)\n\n        return result\n\n    @classmethod\n    def tokens_to_encodings(cls, tokens: Sequence[AbstractToken]):\n        \"\"\"\n        Get the encodings of a list of tokens.\n\n        The method is equivalent to the following code:\n            &gt;&gt;&gt; tokens = kp.get_all_tokens()\n            &gt;&gt;&gt; [token.encoding for token in tokens if token.encoding is not None]\n\n        Args:\n            tokens (Sequence[AbstractToken]): list - A list of tokens.\n\n        Returns: List[str] - A list of token encodings.\n\n        Examples:\n            &gt;&gt;&gt; tokens = document.get_all_tokens()\n            &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n            ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n        \"\"\"\n        encodings = [token.encoding for token in tokens if token.encoding is not None]\n        return encodings\n\n    def get_all_tokens(self, filter_by_categories: Optional[Sequence[TokenCategory]] = None) -&gt; List[AbstractToken]:\n        \"\"\"\n        Args:\n            filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n        Returns:\n            List[AbstractToken] - A list of all tokens.\n\n        Examples:\n            &gt;&gt;&gt; tokens = document.get_all_tokens()\n            &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n            &gt;&gt;&gt; [type(t) for t in tokens]\n            [&lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;]\n        \"\"\"\n        computed_categories = TokenCategory.valid(include=filter_by_categories)\n        traversal = TokensTraversal(False, computed_categories)\n        self.tree.dfs_iterative(traversal)\n        return traversal.tokens\n\n    def get_all_tokens_encodings(\n            self,\n            filter_by_categories: Optional[Sequence[TokenCategory]] = None\n    ) -&gt; List[str]:\n        \"\"\"\n        Args:\n            filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n\n        Returns:\n            list[str] - A list of all token encodings.\n\n        Examples:\n            &gt;&gt;&gt; tokens = document.get_all_tokens_encodings()\n            &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n            ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n        \"\"\"\n        tokens = self.get_all_tokens(filter_by_categories)\n        return Document.tokens_to_encodings(tokens)\n\n    def get_unique_tokens(\n            self,\n            filter_by_categories: Optional[Sequence[TokenCategory]] = None\n    ) -&gt; List[AbstractToken]:\n        \"\"\"\n        Get unique tokens.\n\n        Args:\n            filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n        Returns:\n            List[AbstractToken] - A list of unique tokens.\n\n        \"\"\"\n        computed_categories = TokenCategory.valid(include=filter_by_categories)\n        traversal = TokensTraversal(True, computed_categories)\n        self.tree.dfs_iterative(traversal)\n        return traversal.tokens\n\n    def get_unique_token_encodings(\n            self,\n            filter_by_categories: Optional[Sequence[TokenCategory]] = None\n    ) -&gt; List[str]:\n        \"\"\"\n        Get unique token encodings.\n\n        Args:\n            filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n        Returns: List[str] - A list of unique token encodings.\n\n        \"\"\"\n        tokens = self.get_unique_tokens(filter_by_categories)\n        return Document.tokens_to_encodings(tokens)\n\n    def get_voices(self, clean: bool = False):\n        \"\"\"\n        Get the voices of the document.\n\n        Args\n            clean (bool): Remove the first '!' from the voice name.\n\n        Returns: A list of voices.\n\n        Examples:\n            &gt;&gt;&gt; document.get_voices()\n            ['!sax', '!piano', '!bass']\n            &gt;&gt;&gt; document.get_voices(clean=True)\n            ['sax', 'piano', 'bass']\n            &gt;&gt;&gt; document.get_voices(clean=False)\n            ['!sax', '!piano', '!bass']\n        \"\"\"\n        from kernpy.core import TokenCategory\n        voices = self.get_all_tokens(filter_by_categories=[TokenCategory.INSTRUMENTS])\n\n        if clean:\n            voices = [voice[1:] for voice in voices]\n        return voices\n\n    def clone(self):\n        \"\"\"\n        Create a deep copy of the Document instance.\n\n        Returns: A new instance of Document with the tree copied.\n\n        \"\"\"\n        result = Document(copy(self.tree))\n        result.measure_start_tree_stages = copy(self.measure_start_tree_stages)\n        result.page_bounding_boxes = copy(self.page_bounding_boxes)\n        result.header_stage = copy(self.header_stage)\n\n        return result\n\n    def append_spines(self, spines) -&gt; None:\n        \"\"\"\n        Append the spines directly to current document tree.\n\n        Args:\n            spines(list): A list of spines to append.\n\n        Returns: None\n\n        Examples:\n            &gt;&gt;&gt; import kernpy as kp\n            &gt;&gt;&gt; doc, _ = kp.read('score.krn')\n            &gt;&gt;&gt; spines = [\n            &gt;&gt;&gt; '4e\\t4f\\t4g\\t4a\\n4b\\t4c\\t4d\\t4e\\n=\\t=\\t=\\t=\\n',\n            &gt;&gt;&gt; '4c\\t4d\\t4e\\t4f\\n4g\\t4a\\t4b\\t4c\\n=\\t=\\t=\\t=\\n',\n           &gt;&gt;&gt; ]\n           &gt;&gt;&gt; doc.append_spines(spines)\n           None\n        \"\"\"\n        raise NotImplementedError()\n        if len(spines) != self.get_spine_count():\n            raise Exception(f\"Spines count mismatch: {len(spines)} != {self.get_spine_count()}\")\n\n        for spine in spines:\n            return\n\n    def add(self, other: 'Document', *, check_core_spines_only: Optional[bool] = False) -&gt; 'Document':\n        \"\"\"\n        Concatenate one document to the current document: Modify the current object!\n\n        Args:\n            other: The document to concatenate.\n            check_core_spines_only: If True, only the core spines (**kern and **mens) are checked. If False, all spines are checked.\n\n        Returns ('Document'): The current document (self) with the other document concatenated.\n        \"\"\"\n        if not Document.match(self, other, check_core_spines_only=check_core_spines_only):\n            raise Exception(f'Documents are not compatible for addition. '\n                            f'Headers do not match with check_core_spines_only={check_core_spines_only}. '\n                            f'self: {self.get_header_nodes()}, other: {other.get_header_nodes()}. ')\n\n        current_header_nodes = self.get_header_stage()\n        other_header_nodes = other.get_header_stage()\n\n        current_leaf_nodes = self.get_leaves()\n        flatten = lambda lst: [item for sublist in lst for item in sublist]\n        other_first_level_children = [flatten(c.children) for c in other_header_nodes]  # avoid header stage\n\n        for current_leaf, other_first_level_child in zip(current_leaf_nodes, other_first_level_children, strict=False):\n            # Ignore extra spines from other document.\n            # But if there are extra spines in the current document, it will raise an exception.\n            if current_leaf.token.encoding == TERMINATOR:\n                # remove the '*-' token from the current document\n                current_leaf_index = current_leaf.parent.children.index(current_leaf)\n                current_leaf.parent.children.pop(current_leaf_index)\n                current_leaf.parent.children.insert(current_leaf_index, other_first_level_child)\n\n            self.tree.add_node(\n                stage=len(self.tree.stages) - 1,  # TODO: check offset 0, +1, -1 ????\n                parent=current_leaf,\n                token=other_first_level_child.token,\n                last_spine_operator_node=other_first_level_child.last_spine_operator_node,\n                previous_signature_nodes=other_first_level_child.last_signature_nodes,\n                header_node=other_first_level_child.header_node\n            )\n\n        return self\n\n    def get_header_nodes(self) -&gt; List[HeaderToken]:\n        \"\"\"\n        Get the header nodes of the current document.\n\n        Returns: List[HeaderToken]: A list with the header nodes of the current document.\n        \"\"\"\n        return [token for token in self.get_all_tokens(filter_by_categories=None) if isinstance(token, HeaderToken)]\n\n    def get_spine_ids(self) -&gt; List[int]:\n        \"\"\"\n                Get the indexes of the current document.\n\n                Returns List[int]: A list with the indexes of the current document.\n\n                Examples:\n                    &gt;&gt;&gt; document.get_all_spine_indexes()\n                    [0, 1, 2, 3, 4]\n                \"\"\"\n        header_nodes = self.get_header_nodes()\n        return [node.spine_id for node in header_nodes]\n\n    def frequencies(self, token_categories: Optional[Sequence[TokenCategory]] = None) -&gt; Dict:\n        \"\"\"\n        Frequency of tokens in the document.\n\n\n        Args:\n            token_categories (Optional[Sequence[TokenCategory]]): If None, all tokens are considered.\n        Returns (Dict):\n            A dictionary with the category and the number of occurrences of each token.\n\n        \"\"\"\n        tokens = self.get_all_tokens(filter_by_categories=token_categories)\n        frequencies = {}\n        for t in tokens:\n            if t.encoding in frequencies:\n                frequencies[t.encoding]['occurrences'] += 1\n            else:\n                frequencies[t.encoding] = {\n                    'occurrences': 1,\n                    'category': t.category.name,\n                }\n\n        return frequencies\n\n    def split(self) -&gt; List['Document']:\n        \"\"\"\n        Split the current document into a list of documents, one for each **kern spine.\n        Each resulting document will contain one **kern spine along with all non-kern spines.\n\n        Returns:\n            List['Document']: A list of documents, where each document contains one **kern spine\n            and all non-kern spines from the original document.\n\n        Examples:\n            &gt;&gt;&gt; document.split()\n            [&lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;]\n        \"\"\"\n        raise NotImplementedError\n        new_documents = []\n        self_document_copy = deepcopy(self)\n        kern_header_nodes = [node for node in self_document_copy.get_header_nodes() if node.encoding == '**kern']\n        other_header_nodes = [node for node in self_document_copy.get_header_nodes() if node.encoding != '**kern']\n        spine_ids = self_document_copy.get_spine_ids()\n\n        for header_node in kern_header_nodes:\n            if header_node.spine_id not in spine_ids:\n                continue\n\n            spine_ids.remove(header_node.spine_id)\n\n            new_tree = deepcopy(self.tree)\n            prev_node = new_tree.root\n            while not isinstance(prev_node, HeaderToken):\n                prev_node = prev_node.children[0]\n\n            if not prev_node or not isinstance(prev_node, HeaderToken):\n                raise Exception(f'Header node not found: {prev_node} in {header_node}')\n\n            new_children = list(filter(lambda x: x.spine_id == header_node.spine_id, prev_node.children))\n            new_tree.root = new_children\n\n            new_document = Document(new_tree)\n\n            new_documents.append(new_document)\n\n        return new_documents\n\n    @classmethod\n    def to_concat(cls, first_doc: 'Document', second_doc: 'Document', deep_copy: bool = True) -&gt; 'Document':\n        \"\"\"\n        Concatenate two documents.\n\n        Args:\n            first_doc (Document): The first document.\n            second_doc (Document: The second document.\n            deep_copy (bool): If True, the documents are deep copied. If False, the documents are shallow copied.\n\n        Returns: A new instance of Document with the documents concatenated.\n        \"\"\"\n        first_doc = first_doc.clone() if deep_copy else first_doc\n        second_doc = second_doc.clone() if deep_copy else second_doc\n        first_doc.add(second_doc)\n\n        return first_doc\n\n    @classmethod\n    def match(cls, a: 'Document', b: 'Document', *, check_core_spines_only: Optional[bool] = False) -&gt; bool:\n        \"\"\"\n        Match two documents. Two documents match if they have the same spine structure.\n\n        Args:\n            a (Document): The first document.\n            b (Document): The second document.\n            check_core_spines_only (Optional[bool]): If True, only the core spines (**kern and **mens) are checked. If False, all spines are checked.\n\n        Returns: True if the documents match, False otherwise.\n\n        Examples:\n\n        \"\"\"\n        if check_core_spines_only:\n            return [token.encoding for token in a.get_header_nodes() if token.encoding in CORE_HEADERS] \\\n                == [token.encoding for token in b.get_header_nodes() if token.encoding in CORE_HEADERS]\n        else:\n            return [token.encoding for token in a.get_header_nodes()] \\\n                == [token.encoding for token in b.get_header_nodes()]\n\n\n    def to_transposed(self, interval: str, direction: str = Direction.UP.value) -&gt; 'Document':\n        \"\"\"\n        Create a new document with the transposed notes without modifying the original document.\n\n        Args:\n            interval (str): The name of the interval to transpose. It can be 'P4', 'P5', 'M2', etc. Check the \\\n             kp.AVAILABLE_INTERVALS for the available intervals.\n            direction (str): The direction to transpose. It can be 'up' or 'down'.\n\n        Returns:\n\n        \"\"\"\n        if interval not in AVAILABLE_INTERVALS:\n            raise ValueError(\n                f\"Interval {interval!r} is not available. \"\n                f\"Available intervals are: {AVAILABLE_INTERVALS}\"\n            )\n\n        if direction not in (Direction.UP.value, Direction.DOWN.value):\n            raise ValueError(\n                f\"Direction {direction!r} is not available. \"\n                f\"Available directions are: \"\n                f\"{Direction.UP.value!r}, {Direction.DOWN.value!r}\"\n            )\n\n        new_document = self.clone()\n\n        # BFS through the tree\n        root = new_document.tree.root\n        queue = Queue()\n        queue.put(root)\n\n        while not queue.empty():\n            node = queue.get()\n\n            if isinstance(node.token, NoteRestToken):\n                orig_token = node.token\n\n                new_subtokens = []\n                transposed_pitch_encoding = None\n\n                # Transpose each pitch subtoken in the pitch\u2013duration list\n                for subtoken in orig_token.pitch_duration_subtokens:\n                    if subtoken.category == TokenCategory.PITCH:\n                        # transpose() returns a new pitch subtoken\n                        tp = transpose(\n                            input_encoding=subtoken.encoding,\n                            interval=IntervalsByName[interval],\n                            direction=direction,\n                            input_format=NotationEncoding.HUMDRUM.value,\n                            output_format=NotationEncoding.HUMDRUM.value,\n                        )\n                        new_subtokens.append(Subtoken(tp, subtoken.category))\n                        transposed_pitch_encoding = tp\n                    else:\n                        # leave duration subtokens untouched\n                        new_subtokens.append(Subtoken(subtoken.encoding, subtoken.category))\n\n                # Replace the node\u2019s token with a new NoteRestToken\n                node.token = NoteRestToken(\n                    encoding=transposed_pitch_encoding,\n                    pitch_duration_subtokens=new_subtokens,\n                    decoration_subtokens=orig_token.decoration_subtokens,\n                )\n\n            # enqueue children\n            for child in node.children:\n                queue.put(child)\n\n        # Return the transposed clone\n        return new_document\n\n\n    def __iter__(self):\n        \"\"\"\n        Get the indexes to export all the document.\n\n        Returns: An iterator with the indexes to export the document.\n        \"\"\"\n        return iter(range(self.get_first_measure(), self.measures_count() + 1))\n\n    def __next__(self):\n        \"\"\"\n        Get the next index to export the document.\n\n        Returns: The next index to export the document.\n        \"\"\"\n        return next(iter(range(self.get_first_measure(), self.measures_count() + 1)))\n</code></pre>"},{"location":"reference/#kernpy.Document.__init__","title":"<code>__init__(tree)</code>","text":"<p>Constructor for Document class.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>MultistageTree</code> <p>The tree structure of the document where all the nodes are stored.</p> required Source code in <code>kernpy/core/document.py</code> <pre><code>def __init__(self, tree: MultistageTree):\n    \"\"\"\n    Constructor for Document class.\n\n    Args:\n        tree (MultistageTree): The tree structure of the document where all the nodes are stored.\n    \"\"\"\n    self.tree = tree  # TODO: ? Should we use copy.deepcopy() here?\n    self.measure_start_tree_stages = []\n    self.page_bounding_boxes = {}\n    self.header_stage = None\n</code></pre>"},{"location":"reference/#kernpy.Document.__iter__","title":"<code>__iter__()</code>","text":"<p>Get the indexes to export all the document.</p> <p>Returns: An iterator with the indexes to export the document.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def __iter__(self):\n    \"\"\"\n    Get the indexes to export all the document.\n\n    Returns: An iterator with the indexes to export the document.\n    \"\"\"\n    return iter(range(self.get_first_measure(), self.measures_count() + 1))\n</code></pre>"},{"location":"reference/#kernpy.Document.__next__","title":"<code>__next__()</code>","text":"<p>Get the next index to export the document.</p> <p>Returns: The next index to export the document.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def __next__(self):\n    \"\"\"\n    Get the next index to export the document.\n\n    Returns: The next index to export the document.\n    \"\"\"\n    return next(iter(range(self.get_first_measure(), self.measures_count() + 1)))\n</code></pre>"},{"location":"reference/#kernpy.Document.add","title":"<code>add(other, *, check_core_spines_only=False)</code>","text":"<p>Concatenate one document to the current document: Modify the current object!</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'Document'</code> <p>The document to concatenate.</p> required <code>check_core_spines_only</code> <code>Optional[bool]</code> <p>If True, only the core spines (kern and mens) are checked. If False, all spines are checked.</p> <code>False</code> <p>Returns ('Document'): The current document (self) with the other document concatenated.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def add(self, other: 'Document', *, check_core_spines_only: Optional[bool] = False) -&gt; 'Document':\n    \"\"\"\n    Concatenate one document to the current document: Modify the current object!\n\n    Args:\n        other: The document to concatenate.\n        check_core_spines_only: If True, only the core spines (**kern and **mens) are checked. If False, all spines are checked.\n\n    Returns ('Document'): The current document (self) with the other document concatenated.\n    \"\"\"\n    if not Document.match(self, other, check_core_spines_only=check_core_spines_only):\n        raise Exception(f'Documents are not compatible for addition. '\n                        f'Headers do not match with check_core_spines_only={check_core_spines_only}. '\n                        f'self: {self.get_header_nodes()}, other: {other.get_header_nodes()}. ')\n\n    current_header_nodes = self.get_header_stage()\n    other_header_nodes = other.get_header_stage()\n\n    current_leaf_nodes = self.get_leaves()\n    flatten = lambda lst: [item for sublist in lst for item in sublist]\n    other_first_level_children = [flatten(c.children) for c in other_header_nodes]  # avoid header stage\n\n    for current_leaf, other_first_level_child in zip(current_leaf_nodes, other_first_level_children, strict=False):\n        # Ignore extra spines from other document.\n        # But if there are extra spines in the current document, it will raise an exception.\n        if current_leaf.token.encoding == TERMINATOR:\n            # remove the '*-' token from the current document\n            current_leaf_index = current_leaf.parent.children.index(current_leaf)\n            current_leaf.parent.children.pop(current_leaf_index)\n            current_leaf.parent.children.insert(current_leaf_index, other_first_level_child)\n\n        self.tree.add_node(\n            stage=len(self.tree.stages) - 1,  # TODO: check offset 0, +1, -1 ????\n            parent=current_leaf,\n            token=other_first_level_child.token,\n            last_spine_operator_node=other_first_level_child.last_spine_operator_node,\n            previous_signature_nodes=other_first_level_child.last_signature_nodes,\n            header_node=other_first_level_child.header_node\n        )\n\n    return self\n</code></pre>"},{"location":"reference/#kernpy.Document.append_spines","title":"<code>append_spines(spines)</code>","text":"<pre><code>    Append the spines directly to current document tree.\n\n    Args:\n        spines(list): A list of spines to append.\n\n    Returns: None\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; doc, _ = kp.read('score.krn')\n        &gt;&gt;&gt; spines = [\n        &gt;&gt;&gt; '4e     4f      4g      4a\n</code></pre> <p>4b      4c      4d      4e =       =       =       = ',             &gt;&gt;&gt; '4c     4d      4e      4f 4g      4a      4b      4c =       =       =       = ',            &gt;&gt;&gt; ]            &gt;&gt;&gt; doc.append_spines(spines)            None</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def append_spines(self, spines) -&gt; None:\n    \"\"\"\n    Append the spines directly to current document tree.\n\n    Args:\n        spines(list): A list of spines to append.\n\n    Returns: None\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; doc, _ = kp.read('score.krn')\n        &gt;&gt;&gt; spines = [\n        &gt;&gt;&gt; '4e\\t4f\\t4g\\t4a\\n4b\\t4c\\t4d\\t4e\\n=\\t=\\t=\\t=\\n',\n        &gt;&gt;&gt; '4c\\t4d\\t4e\\t4f\\n4g\\t4a\\t4b\\t4c\\n=\\t=\\t=\\t=\\n',\n       &gt;&gt;&gt; ]\n       &gt;&gt;&gt; doc.append_spines(spines)\n       None\n    \"\"\"\n    raise NotImplementedError()\n    if len(spines) != self.get_spine_count():\n        raise Exception(f\"Spines count mismatch: {len(spines)} != {self.get_spine_count()}\")\n\n    for spine in spines:\n        return\n</code></pre>"},{"location":"reference/#kernpy.Document.clone","title":"<code>clone()</code>","text":"<p>Create a deep copy of the Document instance.</p> <p>Returns: A new instance of Document with the tree copied.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def clone(self):\n    \"\"\"\n    Create a deep copy of the Document instance.\n\n    Returns: A new instance of Document with the tree copied.\n\n    \"\"\"\n    result = Document(copy(self.tree))\n    result.measure_start_tree_stages = copy(self.measure_start_tree_stages)\n    result.page_bounding_boxes = copy(self.page_bounding_boxes)\n    result.header_stage = copy(self.header_stage)\n\n    return result\n</code></pre>"},{"location":"reference/#kernpy.Document.frequencies","title":"<code>frequencies(token_categories=None)</code>","text":"<p>Frequency of tokens in the document.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>If None, all tokens are considered.</p> <code>None</code> <p>Returns (Dict):     A dictionary with the category and the number of occurrences of each token.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def frequencies(self, token_categories: Optional[Sequence[TokenCategory]] = None) -&gt; Dict:\n    \"\"\"\n    Frequency of tokens in the document.\n\n\n    Args:\n        token_categories (Optional[Sequence[TokenCategory]]): If None, all tokens are considered.\n    Returns (Dict):\n        A dictionary with the category and the number of occurrences of each token.\n\n    \"\"\"\n    tokens = self.get_all_tokens(filter_by_categories=token_categories)\n    frequencies = {}\n    for t in tokens:\n        if t.encoding in frequencies:\n            frequencies[t.encoding]['occurrences'] += 1\n        else:\n            frequencies[t.encoding] = {\n                'occurrences': 1,\n                'category': t.category.name,\n            }\n\n    return frequencies\n</code></pre>"},{"location":"reference/#kernpy.Document.get_all_tokens","title":"<code>get_all_tokens(filter_by_categories=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AbstractToken]</code> <p>List[AbstractToken] - A list of all tokens.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n&gt;&gt;&gt; [type(t) for t in tokens]\n[&lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;]\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_all_tokens(self, filter_by_categories: Optional[Sequence[TokenCategory]] = None) -&gt; List[AbstractToken]:\n    \"\"\"\n    Args:\n        filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n    Returns:\n        List[AbstractToken] - A list of all tokens.\n\n    Examples:\n        &gt;&gt;&gt; tokens = document.get_all_tokens()\n        &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n        &gt;&gt;&gt; [type(t) for t in tokens]\n        [&lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;]\n    \"\"\"\n    computed_categories = TokenCategory.valid(include=filter_by_categories)\n    traversal = TokensTraversal(False, computed_categories)\n    self.tree.dfs_iterative(traversal)\n    return traversal.tokens\n</code></pre>"},{"location":"reference/#kernpy.Document.get_all_tokens_encodings","title":"<code>get_all_tokens_encodings(filter_by_categories=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str] - A list of all token encodings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens_encodings()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_all_tokens_encodings(\n        self,\n        filter_by_categories: Optional[Sequence[TokenCategory]] = None\n) -&gt; List[str]:\n    \"\"\"\n    Args:\n        filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n\n    Returns:\n        list[str] - A list of all token encodings.\n\n    Examples:\n        &gt;&gt;&gt; tokens = document.get_all_tokens_encodings()\n        &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n        ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n    \"\"\"\n    tokens = self.get_all_tokens(filter_by_categories)\n    return Document.tokens_to_encodings(tokens)\n</code></pre>"},{"location":"reference/#kernpy.Document.get_first_measure","title":"<code>get_first_measure()</code>","text":"<p>Get the index of the first measure of the document.</p> <p>Returns: (Int) The index of the first measure of the document.</p> <p>Raises: Exception - If the document has no measures.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, err = kp.read('score.krn')\n&gt;&gt;&gt; document.get_first_measure()\n1\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_first_measure(self) -&gt; int:\n    \"\"\"\n    Get the index of the first measure of the document.\n\n    Returns: (Int) The index of the first measure of the document.\n\n    Raises: Exception - If the document has no measures.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, err = kp.read('score.krn')\n        &gt;&gt;&gt; document.get_first_measure()\n        1\n    \"\"\"\n    if len(self.measure_start_tree_stages) == 0:\n        raise Exception('No measures found')\n\n    return self.FIRST_MEASURE\n</code></pre>"},{"location":"reference/#kernpy.Document.get_header_nodes","title":"<code>get_header_nodes()</code>","text":"<p>Get the header nodes of the current document.</p> <p>Returns: List[HeaderToken]: A list with the header nodes of the current document.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_header_nodes(self) -&gt; List[HeaderToken]:\n    \"\"\"\n    Get the header nodes of the current document.\n\n    Returns: List[HeaderToken]: A list with the header nodes of the current document.\n    \"\"\"\n    return [token for token in self.get_all_tokens(filter_by_categories=None) if isinstance(token, HeaderToken)]\n</code></pre>"},{"location":"reference/#kernpy.Document.get_header_stage","title":"<code>get_header_stage()</code>","text":"<p>Get the Node list of the header stage.</p> <p>Returns: (Union[List[Node], List[List[Node]]]) The Node list of the header stage.</p> <p>Raises: Exception - If the document has no header stage.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_header_stage(self) -&gt; Union[List[Node], List[List[Node]]]:\n    \"\"\"\n    Get the Node list of the header stage.\n\n    Returns: (Union[List[Node], List[List[Node]]]) The Node list of the header stage.\n\n    Raises: Exception - If the document has no header stage.\n    \"\"\"\n    if self.header_stage:\n        return self.tree.stages[self.header_stage]\n    else:\n        raise Exception('No header stage found')\n</code></pre>"},{"location":"reference/#kernpy.Document.get_leaves","title":"<code>get_leaves()</code>","text":"<p>Get the leaves of the tree.</p> <p>Returns: (List[Node]) The leaves of the tree.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_leaves(self) -&gt; List[Node]:\n    \"\"\"\n    Get the leaves of the tree.\n\n    Returns: (List[Node]) The leaves of the tree.\n    \"\"\"\n    return self.tree.stages[len(self.tree.stages) - 1]\n</code></pre>"},{"location":"reference/#kernpy.Document.get_metacomments","title":"<code>get_metacomments(KeyComment=None, clear=False)</code>","text":"<p>Get all metacomments in the document</p> <p>Parameters:</p> Name Type Description Default <code>KeyComment</code> <code>Optional[str]</code> <p>Filter by a specific metacomment key: e.g. Use 'COM' to get only comments starting with                '!!!COM: '. If None, all metacomments are returned.</p> <code>None</code> <code>clear</code> <code>bool</code> <p>If True, the metacomment key is removed from the comment. E.g. '!!!COM: Coltrane' -&gt; 'Coltrane'.                If False, the metacomment key is kept. E.g. '!!!COM: Coltrane' -&gt; '!!!COM: Coltrane'.                 The clear functionality is equivalent to the following code:</p> <pre><code>comment = '!!!COM: Coltrane'\nclean_comment = comment.replace(f\"!!!{KeyComment}: \", \"\")\n</code></pre> <p>Other formats are not supported.</p> <code>False</code> <p>Returns: A list of metacomments.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_metacomments()\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='COM')\n['!!!COM: Coltrane']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='COM', clear=True)\n['Coltrane']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='non_existing_key')\n[]\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_metacomments(self, KeyComment: Optional[str] = None, clear: bool = False) -&gt; List[str]:\n    \"\"\"\n    Get all metacomments in the document\n\n    Args:\n        KeyComment: Filter by a specific metacomment key: e.g. Use 'COM' to get only comments starting with\\\n            '!!!COM: '. If None, all metacomments are returned.\n        clear: If True, the metacomment key is removed from the comment. E.g. '!!!COM: Coltrane' -&gt; 'Coltrane'.\\\n            If False, the metacomment key is kept. E.g. '!!!COM: Coltrane' -&gt; '!!!COM: Coltrane'. \\\n            The clear functionality is equivalent to the following code:\n            ```python\n            comment = '!!!COM: Coltrane'\n            clean_comment = comment.replace(f\"!!!{KeyComment}: \", \"\")\n            ```\n            Other formats are not supported.\n\n    Returns: A list of metacomments.\n\n    Examples:\n        &gt;&gt;&gt; document.get_metacomments()\n        ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n        &gt;&gt;&gt; document.get_metacomments(KeyComment='COM')\n        ['!!!COM: Coltrane']\n        &gt;&gt;&gt; document.get_metacomments(KeyComment='COM', clear=True)\n        ['Coltrane']\n        &gt;&gt;&gt; document.get_metacomments(KeyComment='non_existing_key')\n        []\n    \"\"\"\n    traversal = MetacommentsTraversal()\n    self.tree.dfs_iterative(traversal)\n    result = []\n    for metacomment in traversal.metacomments:\n        if KeyComment is None or metacomment.encoding.startswith(f\"!!!{KeyComment}\"):\n            new_comment = metacomment.encoding\n            if clear:\n                new_comment = metacomment.encoding.replace(f\"!!!{KeyComment}: \", \"\")\n            result.append(new_comment)\n\n    return result\n</code></pre>"},{"location":"reference/#kernpy.Document.get_spine_count","title":"<code>get_spine_count()</code>","text":"<p>Get the number of spines in the document.</p> <p>Returns (int): The number of spines in the document.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_spine_count(self) -&gt; int:\n    \"\"\"\n    Get the number of spines in the document.\n\n    Returns (int): The number of spines in the document.\n    \"\"\"\n    return len(self.get_header_stage())  # TODO: test refactor\n</code></pre>"},{"location":"reference/#kernpy.Document.get_spine_ids","title":"<code>get_spine_ids()</code>","text":"<p>Get the indexes of the current document.</p> <p>Returns List[int]: A list with the indexes of the current document.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_all_spine_indexes()\n[0, 1, 2, 3, 4]\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_spine_ids(self) -&gt; List[int]:\n    \"\"\"\n            Get the indexes of the current document.\n\n            Returns List[int]: A list with the indexes of the current document.\n\n            Examples:\n                &gt;&gt;&gt; document.get_all_spine_indexes()\n                [0, 1, 2, 3, 4]\n            \"\"\"\n    header_nodes = self.get_header_nodes()\n    return [node.spine_id for node in header_nodes]\n</code></pre>"},{"location":"reference/#kernpy.Document.get_unique_token_encodings","title":"<code>get_unique_token_encodings(filter_by_categories=None)</code>","text":"<p>Get unique token encodings.</p> <p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns: List[str] - A list of unique token encodings.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_unique_token_encodings(\n        self,\n        filter_by_categories: Optional[Sequence[TokenCategory]] = None\n) -&gt; List[str]:\n    \"\"\"\n    Get unique token encodings.\n\n    Args:\n        filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n    Returns: List[str] - A list of unique token encodings.\n\n    \"\"\"\n    tokens = self.get_unique_tokens(filter_by_categories)\n    return Document.tokens_to_encodings(tokens)\n</code></pre>"},{"location":"reference/#kernpy.Document.get_unique_tokens","title":"<code>get_unique_tokens(filter_by_categories=None)</code>","text":"<p>Get unique tokens.</p> <p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AbstractToken]</code> <p>List[AbstractToken] - A list of unique tokens.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_unique_tokens(\n        self,\n        filter_by_categories: Optional[Sequence[TokenCategory]] = None\n) -&gt; List[AbstractToken]:\n    \"\"\"\n    Get unique tokens.\n\n    Args:\n        filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n    Returns:\n        List[AbstractToken] - A list of unique tokens.\n\n    \"\"\"\n    computed_categories = TokenCategory.valid(include=filter_by_categories)\n    traversal = TokensTraversal(True, computed_categories)\n    self.tree.dfs_iterative(traversal)\n    return traversal.tokens\n</code></pre>"},{"location":"reference/#kernpy.Document.get_voices","title":"<code>get_voices(clean=False)</code>","text":"<p>Get the voices of the document.</p> <p>Args     clean (bool): Remove the first '!' from the voice name.</p> <p>Returns: A list of voices.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_voices()\n['!sax', '!piano', '!bass']\n&gt;&gt;&gt; document.get_voices(clean=True)\n['sax', 'piano', 'bass']\n&gt;&gt;&gt; document.get_voices(clean=False)\n['!sax', '!piano', '!bass']\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_voices(self, clean: bool = False):\n    \"\"\"\n    Get the voices of the document.\n\n    Args\n        clean (bool): Remove the first '!' from the voice name.\n\n    Returns: A list of voices.\n\n    Examples:\n        &gt;&gt;&gt; document.get_voices()\n        ['!sax', '!piano', '!bass']\n        &gt;&gt;&gt; document.get_voices(clean=True)\n        ['sax', 'piano', 'bass']\n        &gt;&gt;&gt; document.get_voices(clean=False)\n        ['!sax', '!piano', '!bass']\n    \"\"\"\n    from kernpy.core import TokenCategory\n    voices = self.get_all_tokens(filter_by_categories=[TokenCategory.INSTRUMENTS])\n\n    if clean:\n        voices = [voice[1:] for voice in voices]\n    return voices\n</code></pre>"},{"location":"reference/#kernpy.Document.match","title":"<code>match(a, b, *, check_core_spines_only=False)</code>  <code>classmethod</code>","text":"<p>Match two documents. Two documents match if they have the same spine structure.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Document</code> <p>The first document.</p> required <code>b</code> <code>Document</code> <p>The second document.</p> required <code>check_core_spines_only</code> <code>Optional[bool]</code> <p>If True, only the core spines (kern and mens) are checked. If False, all spines are checked.</p> <code>False</code> <p>Returns: True if the documents match, False otherwise.</p> <p>Examples:</p> Source code in <code>kernpy/core/document.py</code> <pre><code>@classmethod\ndef match(cls, a: 'Document', b: 'Document', *, check_core_spines_only: Optional[bool] = False) -&gt; bool:\n    \"\"\"\n    Match two documents. Two documents match if they have the same spine structure.\n\n    Args:\n        a (Document): The first document.\n        b (Document): The second document.\n        check_core_spines_only (Optional[bool]): If True, only the core spines (**kern and **mens) are checked. If False, all spines are checked.\n\n    Returns: True if the documents match, False otherwise.\n\n    Examples:\n\n    \"\"\"\n    if check_core_spines_only:\n        return [token.encoding for token in a.get_header_nodes() if token.encoding in CORE_HEADERS] \\\n            == [token.encoding for token in b.get_header_nodes() if token.encoding in CORE_HEADERS]\n    else:\n        return [token.encoding for token in a.get_header_nodes()] \\\n            == [token.encoding for token in b.get_header_nodes()]\n</code></pre>"},{"location":"reference/#kernpy.Document.measures_count","title":"<code>measures_count()</code>","text":"<p>Get the index of the last measure of the document.</p> <p>Returns: (Int) The index of the last measure of the document.</p> <p>Raises: Exception - If the document has no measures.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document, _ = kernpy.read('score.krn')\n&gt;&gt;&gt; document.measures_count()\n10\n&gt;&gt;&gt; for i in range(document.get_first_measure(), document.measures_count() + 1):\n&gt;&gt;&gt;   options = kernpy.ExportOptions(from_measure=i, to_measure=i+4)\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def measures_count(self) -&gt; int:\n    \"\"\"\n    Get the index of the last measure of the document.\n\n    Returns: (Int) The index of the last measure of the document.\n\n    Raises: Exception - If the document has no measures.\n\n    Examples:\n        &gt;&gt;&gt; document, _ = kernpy.read('score.krn')\n        &gt;&gt;&gt; document.measures_count()\n        10\n        &gt;&gt;&gt; for i in range(document.get_first_measure(), document.measures_count() + 1):\n        &gt;&gt;&gt;   options = kernpy.ExportOptions(from_measure=i, to_measure=i+4)\n    \"\"\"\n    if len(self.measure_start_tree_stages) == 0:\n        raise Exception('No measures found')\n\n    return len(self.measure_start_tree_stages)\n</code></pre>"},{"location":"reference/#kernpy.Document.split","title":"<code>split()</code>","text":"<p>Split the current document into a list of documents, one for each kern spine. Each resulting document will contain one kern spine along with all non-kern spines.</p> <p>Returns:</p> Type Description <code>List['Document']</code> <p>List['Document']: A list of documents, where each document contains one **kern spine</p> <code>List['Document']</code> <p>and all non-kern spines from the original document.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.split()\n[&lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;]\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def split(self) -&gt; List['Document']:\n    \"\"\"\n    Split the current document into a list of documents, one for each **kern spine.\n    Each resulting document will contain one **kern spine along with all non-kern spines.\n\n    Returns:\n        List['Document']: A list of documents, where each document contains one **kern spine\n        and all non-kern spines from the original document.\n\n    Examples:\n        &gt;&gt;&gt; document.split()\n        [&lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;]\n    \"\"\"\n    raise NotImplementedError\n    new_documents = []\n    self_document_copy = deepcopy(self)\n    kern_header_nodes = [node for node in self_document_copy.get_header_nodes() if node.encoding == '**kern']\n    other_header_nodes = [node for node in self_document_copy.get_header_nodes() if node.encoding != '**kern']\n    spine_ids = self_document_copy.get_spine_ids()\n\n    for header_node in kern_header_nodes:\n        if header_node.spine_id not in spine_ids:\n            continue\n\n        spine_ids.remove(header_node.spine_id)\n\n        new_tree = deepcopy(self.tree)\n        prev_node = new_tree.root\n        while not isinstance(prev_node, HeaderToken):\n            prev_node = prev_node.children[0]\n\n        if not prev_node or not isinstance(prev_node, HeaderToken):\n            raise Exception(f'Header node not found: {prev_node} in {header_node}')\n\n        new_children = list(filter(lambda x: x.spine_id == header_node.spine_id, prev_node.children))\n        new_tree.root = new_children\n\n        new_document = Document(new_tree)\n\n        new_documents.append(new_document)\n\n    return new_documents\n</code></pre>"},{"location":"reference/#kernpy.Document.to_concat","title":"<code>to_concat(first_doc, second_doc, deep_copy=True)</code>  <code>classmethod</code>","text":"<p>Concatenate two documents.</p> <p>Parameters:</p> Name Type Description Default <code>first_doc</code> <code>Document</code> <p>The first document.</p> required <code>second_doc</code> <code>Document</code> <p>The second document.</p> required <code>deep_copy</code> <code>bool</code> <p>If True, the documents are deep copied. If False, the documents are shallow copied.</p> <code>True</code> <p>Returns: A new instance of Document with the documents concatenated.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>@classmethod\ndef to_concat(cls, first_doc: 'Document', second_doc: 'Document', deep_copy: bool = True) -&gt; 'Document':\n    \"\"\"\n    Concatenate two documents.\n\n    Args:\n        first_doc (Document): The first document.\n        second_doc (Document: The second document.\n        deep_copy (bool): If True, the documents are deep copied. If False, the documents are shallow copied.\n\n    Returns: A new instance of Document with the documents concatenated.\n    \"\"\"\n    first_doc = first_doc.clone() if deep_copy else first_doc\n    second_doc = second_doc.clone() if deep_copy else second_doc\n    first_doc.add(second_doc)\n\n    return first_doc\n</code></pre>"},{"location":"reference/#kernpy.Document.to_transposed","title":"<code>to_transposed(interval, direction=Direction.UP.value)</code>","text":"<p>Create a new document with the transposed notes without modifying the original document.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>str</code> <p>The name of the interval to transpose. It can be 'P4', 'P5', 'M2', etc. Check the              kp.AVAILABLE_INTERVALS for the available intervals.</p> required <code>direction</code> <code>str</code> <p>The direction to transpose. It can be 'up' or 'down'.</p> <code>UP.value</code> <p>Returns:</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def to_transposed(self, interval: str, direction: str = Direction.UP.value) -&gt; 'Document':\n    \"\"\"\n    Create a new document with the transposed notes without modifying the original document.\n\n    Args:\n        interval (str): The name of the interval to transpose. It can be 'P4', 'P5', 'M2', etc. Check the \\\n         kp.AVAILABLE_INTERVALS for the available intervals.\n        direction (str): The direction to transpose. It can be 'up' or 'down'.\n\n    Returns:\n\n    \"\"\"\n    if interval not in AVAILABLE_INTERVALS:\n        raise ValueError(\n            f\"Interval {interval!r} is not available. \"\n            f\"Available intervals are: {AVAILABLE_INTERVALS}\"\n        )\n\n    if direction not in (Direction.UP.value, Direction.DOWN.value):\n        raise ValueError(\n            f\"Direction {direction!r} is not available. \"\n            f\"Available directions are: \"\n            f\"{Direction.UP.value!r}, {Direction.DOWN.value!r}\"\n        )\n\n    new_document = self.clone()\n\n    # BFS through the tree\n    root = new_document.tree.root\n    queue = Queue()\n    queue.put(root)\n\n    while not queue.empty():\n        node = queue.get()\n\n        if isinstance(node.token, NoteRestToken):\n            orig_token = node.token\n\n            new_subtokens = []\n            transposed_pitch_encoding = None\n\n            # Transpose each pitch subtoken in the pitch\u2013duration list\n            for subtoken in orig_token.pitch_duration_subtokens:\n                if subtoken.category == TokenCategory.PITCH:\n                    # transpose() returns a new pitch subtoken\n                    tp = transpose(\n                        input_encoding=subtoken.encoding,\n                        interval=IntervalsByName[interval],\n                        direction=direction,\n                        input_format=NotationEncoding.HUMDRUM.value,\n                        output_format=NotationEncoding.HUMDRUM.value,\n                    )\n                    new_subtokens.append(Subtoken(tp, subtoken.category))\n                    transposed_pitch_encoding = tp\n                else:\n                    # leave duration subtokens untouched\n                    new_subtokens.append(Subtoken(subtoken.encoding, subtoken.category))\n\n            # Replace the node\u2019s token with a new NoteRestToken\n            node.token = NoteRestToken(\n                encoding=transposed_pitch_encoding,\n                pitch_duration_subtokens=new_subtokens,\n                decoration_subtokens=orig_token.decoration_subtokens,\n            )\n\n        # enqueue children\n        for child in node.children:\n            queue.put(child)\n\n    # Return the transposed clone\n    return new_document\n</code></pre>"},{"location":"reference/#kernpy.Document.tokens_to_encodings","title":"<code>tokens_to_encodings(tokens)</code>  <code>classmethod</code>","text":"<p>Get the encodings of a list of tokens.</p> The method is equivalent to the following code <p>tokens = kp.get_all_tokens() [token.encoding for token in tokens if token.encoding is not None]</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>Sequence[AbstractToken]</code> <p>list - A list of tokens.</p> required <p>Returns: List[str] - A list of token encodings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>@classmethod\ndef tokens_to_encodings(cls, tokens: Sequence[AbstractToken]):\n    \"\"\"\n    Get the encodings of a list of tokens.\n\n    The method is equivalent to the following code:\n        &gt;&gt;&gt; tokens = kp.get_all_tokens()\n        &gt;&gt;&gt; [token.encoding for token in tokens if token.encoding is not None]\n\n    Args:\n        tokens (Sequence[AbstractToken]): list - A list of tokens.\n\n    Returns: List[str] - A list of token encodings.\n\n    Examples:\n        &gt;&gt;&gt; tokens = document.get_all_tokens()\n        &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n        ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n    \"\"\"\n    encodings = [token.encoding for token in tokens if token.encoding is not None]\n    return encodings\n</code></pre>"},{"location":"reference/#kernpy.Duration","title":"<code>Duration</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Represents the duration of a note or a rest.</p> <p>The duration is represented using the Humdrum Kern format. The duration is a number that represents the number of units of the duration.</p> <p>The duration of a whole note is 1, half note is 2, quarter note is 4, eighth note is 8, etc.</p> <p>The duration of a note is represented by a number. The duration of a rest is also represented by a number.</p> <p>This class do not limit the duration ranges.</p> <p>In the following example, the duration is represented by the number '2'.</p> <pre><code>**kern\n*clefG2\n2c          // whole note\n4c          // half note\n8c          // quarter note\n16c         // eighth note\n*-\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class Duration(ABC):\n    \"\"\"\n    Represents the duration of a note or a rest.\n\n    The duration is represented using the Humdrum Kern format.\n    The duration is a number that represents the number of units of the duration.\n\n    The duration of a whole note is 1, half note is 2, quarter note is 4, eighth note is 8, etc.\n\n    The duration of a note is represented by a number. The duration of a rest is also represented by a number.\n\n    This class do not limit the duration ranges.\n\n    In the following example, the duration is represented by the number '2'.\n    ```\n    **kern\n    *clefG2\n    2c          // whole note\n    4c          // half note\n    8c          // quarter note\n    16c         // eighth note\n    *-\n    ```\n    \"\"\"\n\n    def __init__(self, raw_duration):\n        self.encoding = str(raw_duration)\n\n    @abstractmethod\n    def modify(self, ratio: int):\n        pass\n\n    @abstractmethod\n    def __deepcopy__(self, memo=None):\n        pass\n\n    @abstractmethod\n    def __eq__(self, other):\n        pass\n\n    @abstractmethod\n    def __ne__(self, other):\n        pass\n\n    @abstractmethod\n    def __gt__(self, other):\n        pass\n\n    @abstractmethod\n    def __lt__(self, other):\n        pass\n\n    @abstractmethod\n    def __ge__(self, other):\n        pass\n\n    @abstractmethod\n    def __le__(self, other):\n        pass\n\n    @abstractmethod\n    def __str__(self):\n        pass\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical","title":"<code>DurationClassical</code>","text":"<p>               Bases: <code>Duration</code></p> <p>Represents the duration in classical notation of a note or a rest.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class DurationClassical(Duration):\n    \"\"\"\n    Represents the duration in classical notation of a note or a rest.\n    \"\"\"\n\n    def __init__(self, duration: int):\n        \"\"\"\n        Create a new Duration object.\n\n        Args:\n            duration (str): duration representation in Humdrum Kern format\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            True\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            True\n            &gt;&gt;&gt; duration = DurationClassical(32)\n            True\n            &gt;&gt;&gt; duration = DurationClassical(1)\n            True\n            &gt;&gt;&gt; duration = DurationClassical(0)\n            False\n            &gt;&gt;&gt; duration = DurationClassical(-2)\n            False\n            &gt;&gt;&gt; duration = DurationClassical(3)\n            False\n            &gt;&gt;&gt; duration = DurationClassical(7)\n            False\n        \"\"\"\n        super().__init__(duration)\n        if not DurationClassical.__is_valid_duration(duration):\n            raise ValueError(f'Bad duration: {duration} was provided.')\n\n        self.duration = int(duration)\n\n    def modify(self, ratio: int):\n        \"\"\"\n        Modify the duration of a note or a rest of the current object.\n\n        Args:\n            ratio (int): The factor to modify the duration. The factor must be greater than 0.\n\n        Returns (DurationClassical): The new duration object with the modified duration.\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; new_duration = duration.modify(2)\n            &gt;&gt;&gt; new_duration.duration\n            4\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; new_duration = duration.modify(0)\n            Traceback (most recent call last):\n            ...\n            ValueError: Invalid factor provided: 0. The factor must be greater than 0.\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; new_duration = duration.modify(-2)\n            Traceback (most recent call last):\n            ...\n            ValueError: Invalid factor provided: -2. The factor must be greater than 0.\n        \"\"\"\n        if not isinstance(ratio, int):\n            raise ValueError(f'Invalid factor provided: {ratio}. The factor must be an integer.')\n        if ratio &lt;= 0:\n            raise ValueError(f'Invalid factor provided: {ratio}. The factor must be greater than 0.')\n\n        return copy.deepcopy(DurationClassical(self.duration * ratio))\n\n    def __deepcopy__(self, memo=None):\n        if memo is None:\n            memo = {}\n\n        new_instance = DurationClassical(self.duration)\n        new_instance.duration = self.duration\n        return new_instance\n\n    def __str__(self):\n        return f'{self.duration}'\n\n    def __eq__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other (DurationClassical): The other duration to compare\n\n        Returns (bool): True if the durations are equal, False otherwise\n\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration == duration2\n            True\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration == duration2\n            False\n        \"\"\"\n        if not isinstance(other, DurationClassical):\n            return False\n        return self.duration == other.duration\n\n    def __ne__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other (DurationClassical): The other duration to compare\n\n        Returns (bool):\n            True if the durations are different, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration != duration2\n            False\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration != duration2\n            True\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __gt__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other: The other duration to compare\n\n        Returns (bool):\n            True if this duration is higher than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &gt; duration2\n            False\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration &gt; duration2\n            True\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &gt; duration2\n            False\n        \"\"\"\n        if not isinstance(other, DurationClassical):\n            raise ValueError(f'Invalid comparison: &gt; operator can not be used to compare duration with {type(other)}')\n        return self.duration &gt; other.duration\n\n    def __lt__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other (DurationClassical): The other duration to compare\n\n        Returns (bool):\n            True if this duration is lower than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &lt; duration2\n            True\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration &lt; duration2\n            False\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &lt; duration2\n            False\n        \"\"\"\n        if not isinstance(other, DurationClassical):\n            raise ValueError(f'Invalid comparison: &lt; operator can not be used to compare duration with {type(other)}')\n        return self.duration &lt; other.duration\n\n    def __ge__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other (DurationClassical): The other duration to compare\n\n        Returns (bool):\n            True if this duration is higher or equal than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &gt;= duration2\n            False\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration &gt;= duration2\n            True\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &gt;= duration2\n            True\n        \"\"\"\n        return self.__gt__(other) or self.__eq__(other)\n\n    def __le__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other (DurationClassical): The other duration to compare\n\n        Returns:\n            True if this duration is lower or equal than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &lt;= duration2\n            True\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration &lt;= duration2\n            False\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &lt;= duration2\n            True\n        \"\"\"\n        return self.__lt__(other) or self.__eq__(other)\n\n    @classmethod\n    def __is_valid_duration(cls, duration: int) -&gt; bool:\n        try:\n            duration = int(duration)\n            if duration is None or duration &lt;= 0:\n                return False\n\n            return duration &gt; 0 and (duration % 2 == 0 or duration == 1)\n        except ValueError:\n            return False\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool): True if the durations are equal, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration == duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration == duration2\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __eq__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other (DurationClassical): The other duration to compare\n\n    Returns (bool): True if the durations are equal, False otherwise\n\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration == duration2\n        True\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration == duration2\n        False\n    \"\"\"\n    if not isinstance(other, DurationClassical):\n        return False\n    return self.duration == other.duration\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is higher or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt;= duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &gt;= duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt;= duration2\nTrue\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ge__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other (DurationClassical): The other duration to compare\n\n    Returns (bool):\n        True if this duration is higher or equal than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &gt;= duration2\n        False\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration &gt;= duration2\n        True\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &gt;= duration2\n        True\n    \"\"\"\n    return self.__gt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'DurationClassical'</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is higher than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt; duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &gt; duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt; duration2\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __gt__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other: The other duration to compare\n\n    Returns (bool):\n        True if this duration is higher than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &gt; duration2\n        False\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration &gt; duration2\n        True\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &gt; duration2\n        False\n    \"\"\"\n    if not isinstance(other, DurationClassical):\n        raise ValueError(f'Invalid comparison: &gt; operator can not be used to compare duration with {type(other)}')\n    return self.duration &gt; other.duration\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__init__","title":"<code>__init__(duration)</code>","text":"<p>Create a new Duration object.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>str</code> <p>duration representation in Humdrum Kern format</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(32)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(1)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(0)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(-2)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(3)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(7)\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, duration: int):\n    \"\"\"\n    Create a new Duration object.\n\n    Args:\n        duration (str): duration representation in Humdrum Kern format\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        True\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        True\n        &gt;&gt;&gt; duration = DurationClassical(32)\n        True\n        &gt;&gt;&gt; duration = DurationClassical(1)\n        True\n        &gt;&gt;&gt; duration = DurationClassical(0)\n        False\n        &gt;&gt;&gt; duration = DurationClassical(-2)\n        False\n        &gt;&gt;&gt; duration = DurationClassical(3)\n        False\n        &gt;&gt;&gt; duration = DurationClassical(7)\n        False\n    \"\"\"\n    super().__init__(duration)\n    if not DurationClassical.__is_valid_duration(duration):\n        raise ValueError(f'Bad duration: {duration} was provided.')\n\n    self.duration = int(duration)\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__le__","title":"<code>__le__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this duration is lower or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt;= duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &lt;= duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt;= duration2\nTrue\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __le__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other (DurationClassical): The other duration to compare\n\n    Returns:\n        True if this duration is lower or equal than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &lt;= duration2\n        True\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration &lt;= duration2\n        False\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &lt;= duration2\n        True\n    \"\"\"\n    return self.__lt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is lower than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt; duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &lt; duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt; duration2\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __lt__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other (DurationClassical): The other duration to compare\n\n    Returns (bool):\n        True if this duration is lower than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &lt; duration2\n        True\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration &lt; duration2\n        False\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &lt; duration2\n        False\n    \"\"\"\n    if not isinstance(other, DurationClassical):\n        raise ValueError(f'Invalid comparison: &lt; operator can not be used to compare duration with {type(other)}')\n    return self.duration &lt; other.duration\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if the durations are different, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration != duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration != duration2\nTrue\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ne__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other (DurationClassical): The other duration to compare\n\n    Returns (bool):\n        True if the durations are different, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration != duration2\n        False\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration != duration2\n        True\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.DurationClassical.modify","title":"<code>modify(ratio)</code>","text":"<p>Modify the duration of a note or a rest of the current object.</p> <p>Parameters:</p> Name Type Description Default <code>ratio</code> <code>int</code> <p>The factor to modify the duration. The factor must be greater than 0.</p> required <p>Returns (DurationClassical): The new duration object with the modified duration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(2)\n&gt;&gt;&gt; new_duration.duration\n4\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(0)\nTraceback (most recent call last):\n...\nValueError: Invalid factor provided: 0. The factor must be greater than 0.\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(-2)\nTraceback (most recent call last):\n...\nValueError: Invalid factor provided: -2. The factor must be greater than 0.\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def modify(self, ratio: int):\n    \"\"\"\n    Modify the duration of a note or a rest of the current object.\n\n    Args:\n        ratio (int): The factor to modify the duration. The factor must be greater than 0.\n\n    Returns (DurationClassical): The new duration object with the modified duration.\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; new_duration = duration.modify(2)\n        &gt;&gt;&gt; new_duration.duration\n        4\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; new_duration = duration.modify(0)\n        Traceback (most recent call last):\n        ...\n        ValueError: Invalid factor provided: 0. The factor must be greater than 0.\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; new_duration = duration.modify(-2)\n        Traceback (most recent call last):\n        ...\n        ValueError: Invalid factor provided: -2. The factor must be greater than 0.\n    \"\"\"\n    if not isinstance(ratio, int):\n        raise ValueError(f'Invalid factor provided: {ratio}. The factor must be an integer.')\n    if ratio &lt;= 0:\n        raise ValueError(f'Invalid factor provided: {ratio}. The factor must be greater than 0.')\n\n    return copy.deepcopy(DurationClassical(self.duration * ratio))\n</code></pre>"},{"location":"reference/#kernpy.DurationMensural","title":"<code>DurationMensural</code>","text":"<p>               Bases: <code>Duration</code></p> <p>Represents the duration in mensural notation of a note or a rest.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class DurationMensural(Duration):\n    \"\"\"\n    Represents the duration in mensural notation of a note or a rest.\n    \"\"\"\n\n    def __init__(self, duration):\n        super().__init__(duration)\n        self.duration = duration\n\n    def __eq__(self, other):\n        raise NotImplementedError()\n\n    def modify(self, ratio: int):\n        raise NotImplementedError()\n\n    def __deepcopy__(self, memo=None):\n        raise NotImplementedError()\n\n    def __gt__(self, other):\n        raise NotImplementedError()\n\n    def __lt__(self, other):\n        raise NotImplementedError()\n\n    def __le__(self, other):\n        raise NotImplementedError()\n\n    def __str__(self):\n        raise NotImplementedError()\n\n    def __ge__(self, other):\n        raise NotImplementedError()\n\n    def __ne__(self, other):\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/#kernpy.DynSpineImporter","title":"<code>DynSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/dyn_importer.py</code> <pre><code>class DynSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()\n\n    def import_token(self, encoding: str) -&gt; Token:\n        # TODO: Find out differences between **dyn vs **dynam and change this class. Using the same dor both for now.\n        dynam_importer = DynamSpineImporter()\n        return dynam_importer.import_token(encoding)\n</code></pre>"},{"location":"reference/#kernpy.DynSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/dyn_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.DynamSpineImporter","title":"<code>DynamSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/dynam_spine_importer.py</code> <pre><code>class DynamSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()  # TODO: Create a custom functional listener for DynamSpineImporter\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if not any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.DYNAMICS)\n\n        return token\n</code></pre>"},{"location":"reference/#kernpy.DynamSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/dynam_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.EkernTokenizer","title":"<code>EkernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>EkernTokenizer converts a Token into an eKern (Extended **kern) string representation. This format use a '@' separator for the     main tokens and a '\u00b7' separator for the decorations tokens.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class EkernTokenizer(Tokenizer):\n    \"\"\"\n    EkernTokenizer converts a Token into an eKern (Extended **kern) string representation. This format use a '@' separator for the \\\n    main tokens and a '\u00b7' separator for the decorations tokens.\n    \"\"\"\n\n    def __init__(self, *, token_categories: Set['TokenCategory']):\n        \"\"\"\n        Create a new EkernTokenizer\n\n        Args:\n            token_categories (List[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n        \"\"\"\n        super().__init__(token_categories=token_categories)\n\n    def tokenize(self, token: Token) -&gt; str:\n        \"\"\"\n        Tokenize a token into an eKern string representation.\n        Args:\n            token (Token): Token to be tokenized.\n\n        Returns (str): eKern string representation.\n\n        Examples:\n            &gt;&gt;&gt; token.encoding\n            '2@.@bb@-\u00b7_\u00b7L'\n            &gt;&gt;&gt; EkernTokenizer().tokenize(token)\n            '2@.@bb@-\u00b7_\u00b7L'\n\n        \"\"\"\n        return token.export(filter_categories=lambda cat: cat in self.token_categories)\n</code></pre>"},{"location":"reference/#kernpy.EkernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new EkernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>List[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def __init__(self, *, token_categories: Set['TokenCategory']):\n    \"\"\"\n    Create a new EkernTokenizer\n\n    Args:\n        token_categories (List[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n    \"\"\"\n    super().__init__(token_categories=token_categories)\n</code></pre>"},{"location":"reference/#kernpy.EkernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into an eKern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): eKern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; EkernTokenizer().tokenize(token)\n'2@.@bb@-\u00b7_\u00b7L'\n</code></pre> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def tokenize(self, token: Token) -&gt; str:\n    \"\"\"\n    Tokenize a token into an eKern string representation.\n    Args:\n        token (Token): Token to be tokenized.\n\n    Returns (str): eKern string representation.\n\n    Examples:\n        &gt;&gt;&gt; token.encoding\n        '2@.@bb@-\u00b7_\u00b7L'\n        &gt;&gt;&gt; EkernTokenizer().tokenize(token)\n        '2@.@bb@-\u00b7_\u00b7L'\n\n    \"\"\"\n    return token.export(filter_categories=lambda cat: cat in self.token_categories)\n</code></pre>"},{"location":"reference/#kernpy.Encoding","title":"<code>Encoding</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Options for exporting a kern file.</p> Example <p>import kernpy as kp</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class Encoding(Enum):  # TODO: Eventually, polymorphism will be used to export different types of kern files\n    \"\"\"\n    Options for exporting a kern file.\n\n    Example:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; # Load a file\n        &gt;&gt;&gt; doc, _ = kp.load('path/to/file.krn')\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Save the file using the specified encoding\n        &gt;&gt;&gt; exported_content = kp.dumps(tokenizer=kp.Encoding.normalizedKern)\n    \"\"\"\n    eKern = 'ekern'\n    normalizedKern = 'kern'\n    bKern = 'bkern'\n    bEkern = 'bekern'\n\n    def prefix(self) -&gt; str:\n        \"\"\"\n        Get the prefix of the kern type.\n\n        Returns (str): Prefix of the kern type.\n        \"\"\"\n        if self == Encoding.eKern:\n            return 'e'\n        elif self == Encoding.normalizedKern:\n            return ''\n        elif self == Encoding.bKern:\n            return 'b'\n        elif self == Encoding.bEkern:\n            return 'be'\n        else:\n            raise ValueError(f'Unknown kern type: {self}. '\n                             f'Supported types are: '\n                             f\"{'-'.join([kern_type.name for kern_type in Encoding.__members__.values()])}\")\n</code></pre>"},{"location":"reference/#kernpy.Encoding--load-a-file","title":"Load a file","text":"<p>doc, _ = kp.load('path/to/file.krn')</p>"},{"location":"reference/#kernpy.Encoding--save-the-file-using-the-specified-encoding","title":"Save the file using the specified encoding","text":"<p>exported_content = kp.dumps(tokenizer=kp.Encoding.normalizedKern)</p>"},{"location":"reference/#kernpy.Encoding.prefix","title":"<code>prefix()</code>","text":"<p>Get the prefix of the kern type.</p> <p>Returns (str): Prefix of the kern type.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def prefix(self) -&gt; str:\n    \"\"\"\n    Get the prefix of the kern type.\n\n    Returns (str): Prefix of the kern type.\n    \"\"\"\n    if self == Encoding.eKern:\n        return 'e'\n    elif self == Encoding.normalizedKern:\n        return ''\n    elif self == Encoding.bKern:\n        return 'b'\n    elif self == Encoding.bEkern:\n        return 'be'\n    else:\n        raise ValueError(f'Unknown kern type: {self}. '\n                         f'Supported types are: '\n                         f\"{'-'.join([kern_type.name for kern_type in Encoding.__members__.values()])}\")\n</code></pre>"},{"location":"reference/#kernpy.ExportOptions","title":"<code>ExportOptions</code>","text":"<p><code>ExportOptions</code> class.</p> <p>Store the options to export a **kern file.</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>class ExportOptions:\n    \"\"\"\n    `ExportOptions` class.\n\n    Store the options to export a **kern file.\n    \"\"\"\n\n    def __init__(\n            self,\n            spine_types: [] = None,\n            token_categories: [] = None,\n            from_measure: int = None,\n            to_measure: int = None,\n            kern_type: Encoding = Encoding.normalizedKern,\n            instruments: [] = None,\n            show_measure_numbers: bool = False,\n            spine_ids: [int] = None\n    ):\n        \"\"\"\n        Create a new ExportOptions object.\n\n        Args:\n            spine_types (Iterable): **kern, **mens, etc...\n            token_categories (Iterable): TokenCategory\n            from_measure (int): The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1\n            to_measure (int): The measure to end exporting. When None, the exporter will end at the end of the file.\n            kern_type (Encoding): The type of the kern file to export.\n            instruments (Iterable): The instruments to export. When None, all the instruments will be exported.\n            show_measure_numbers (Bool): Show the measure numbers in the exported file.\n            spine_ids (Iterable): The ids of the spines to export. When None, all the spines will be exported. Spines ids start from 0 and they are increased by 1.\n\n        Example:\n            &gt;&gt;&gt; import kernpy\n\n            Create the importer and read the file\n            &gt;&gt;&gt; hi = Importer()\n            &gt;&gt;&gt; document = hi.import_file('file.krn')\n            &gt;&gt;&gt; exporter = Exporter()\n\n            Export the file with the specified options\n            &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n            Export only the lyrics\n            &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LYRICS])\n            &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n            Export the comments\n            &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LINE_COMMENTS, TokenCategory.FIELD_COMMENTS])\n            &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n            Export using the eKern version\n            &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES, kern_type=Encoding.eKern)\n            &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n        \"\"\"\n        self.spine_types = spine_types if spine_types is not None else deepcopy(HEADERS)\n        self.from_measure = from_measure\n        self.to_measure = to_measure\n        self.token_categories = token_categories if token_categories is not None else [c for c in TokenCategory]\n        self.kern_type = kern_type\n        self.instruments = instruments\n        self.show_measure_numbers = show_measure_numbers\n        self.spine_ids = spine_ids  # When exporting, if spine_ids=None all the spines will be exported.\n\n    def __eq__(self, other: 'ExportOptions') -&gt; bool:\n        \"\"\"\n        Compare two ExportOptions objects.\n\n        Args:\n            other: The other ExportOptions object to compare.\n\n        Returns (bool):\n            True if the objects are equal, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options1 == options2\n            True\n\n            &gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options1 == options3\n            False\n        \"\"\"\n        return self.spine_types == other.spine_types and \\\n            self.token_categories == other.token_categories and \\\n            self.from_measure == other.from_measure and \\\n            self.to_measure == other.to_measure and \\\n            self.kern_type == other.kern_type and \\\n            self.instruments == other.instruments and \\\n            self.show_measure_numbers == other.show_measure_numbers and \\\n            self.spine_ids == other.spine_ids\n\n    def __ne__(self, other: 'ExportOptions') -&gt; bool:\n        \"\"\"\n        Compare two ExportOptions objects.\n\n        Args:\n            other (ExportOptions): The other ExportOptions object to compare.\n\n        Returns (bool):\n            True if the objects are not equal, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options1 != options2\n            False\n\n            &gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options1 != options3\n            True\n        \"\"\"\n        return not self.__eq__(other)\n\n    @classmethod\n    def default(cls):\n        return cls(\n            spine_types=deepcopy(HEADERS),\n            token_categories=[c for c in TokenCategory],\n            from_measure=None,\n            to_measure=None,\n            kern_type=Encoding.normalizedKern,\n            instruments=None,\n            show_measure_numbers=False,\n            spine_ids=None\n        )\n</code></pre>"},{"location":"reference/#kernpy.ExportOptions.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two ExportOptions objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'ExportOptions'</code> <p>The other ExportOptions object to compare.</p> required <p>Returns (bool):     True if the objects are equal, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 == options2\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 == options3\nFalse\n</code></pre> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def __eq__(self, other: 'ExportOptions') -&gt; bool:\n    \"\"\"\n    Compare two ExportOptions objects.\n\n    Args:\n        other: The other ExportOptions object to compare.\n\n    Returns (bool):\n        True if the objects are equal, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options1 == options2\n        True\n\n        &gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options1 == options3\n        False\n    \"\"\"\n    return self.spine_types == other.spine_types and \\\n        self.token_categories == other.token_categories and \\\n        self.from_measure == other.from_measure and \\\n        self.to_measure == other.to_measure and \\\n        self.kern_type == other.kern_type and \\\n        self.instruments == other.instruments and \\\n        self.show_measure_numbers == other.show_measure_numbers and \\\n        self.spine_ids == other.spine_ids\n</code></pre>"},{"location":"reference/#kernpy.ExportOptions.__init__","title":"<code>__init__(spine_types=None, token_categories=None, from_measure=None, to_measure=None, kern_type=Encoding.normalizedKern, instruments=None, show_measure_numbers=False, spine_ids=None)</code>","text":"<p>Create a new ExportOptions object.</p> <p>Parameters:</p> Name Type Description Default <code>spine_types</code> <code>Iterable</code> <p>kern, mens, etc...</p> <code>None</code> <code>token_categories</code> <code>Iterable</code> <p>TokenCategory</p> <code>None</code> <code>from_measure</code> <code>int</code> <p>The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1</p> <code>None</code> <code>to_measure</code> <code>int</code> <p>The measure to end exporting. When None, the exporter will end at the end of the file.</p> <code>None</code> <code>kern_type</code> <code>Encoding</code> <p>The type of the kern file to export.</p> <code>normalizedKern</code> <code>instruments</code> <code>Iterable</code> <p>The instruments to export. When None, all the instruments will be exported.</p> <code>None</code> <code>show_measure_numbers</code> <code>Bool</code> <p>Show the measure numbers in the exported file.</p> <code>False</code> <code>spine_ids</code> <code>Iterable</code> <p>The ids of the spines to export. When None, all the spines will be exported. Spines ids start from 0 and they are increased by 1.</p> <code>None</code> Example <p>import kernpy</p> <p>Create the importer and read the file</p> <p>hi = Importer() document = hi.import_file('file.krn') exporter = Exporter()</p> <p>Export the file with the specified options</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES) exported_data = exporter.export_string(document, options)</p> <p>Export only the lyrics</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LYRICS]) exported_data = exporter.export_string(document, options)</p> <p>Export the comments</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LINE_COMMENTS, TokenCategory.FIELD_COMMENTS]) exported_data = exporter.export_string(document, options)</p> <p>Export using the eKern version</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES, kern_type=Encoding.eKern) exported_data = exporter.export_string(document, options)</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def __init__(\n        self,\n        spine_types: [] = None,\n        token_categories: [] = None,\n        from_measure: int = None,\n        to_measure: int = None,\n        kern_type: Encoding = Encoding.normalizedKern,\n        instruments: [] = None,\n        show_measure_numbers: bool = False,\n        spine_ids: [int] = None\n):\n    \"\"\"\n    Create a new ExportOptions object.\n\n    Args:\n        spine_types (Iterable): **kern, **mens, etc...\n        token_categories (Iterable): TokenCategory\n        from_measure (int): The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1\n        to_measure (int): The measure to end exporting. When None, the exporter will end at the end of the file.\n        kern_type (Encoding): The type of the kern file to export.\n        instruments (Iterable): The instruments to export. When None, all the instruments will be exported.\n        show_measure_numbers (Bool): Show the measure numbers in the exported file.\n        spine_ids (Iterable): The ids of the spines to export. When None, all the spines will be exported. Spines ids start from 0 and they are increased by 1.\n\n    Example:\n        &gt;&gt;&gt; import kernpy\n\n        Create the importer and read the file\n        &gt;&gt;&gt; hi = Importer()\n        &gt;&gt;&gt; document = hi.import_file('file.krn')\n        &gt;&gt;&gt; exporter = Exporter()\n\n        Export the file with the specified options\n        &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n        Export only the lyrics\n        &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LYRICS])\n        &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n        Export the comments\n        &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LINE_COMMENTS, TokenCategory.FIELD_COMMENTS])\n        &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n        Export using the eKern version\n        &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES, kern_type=Encoding.eKern)\n        &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n    \"\"\"\n    self.spine_types = spine_types if spine_types is not None else deepcopy(HEADERS)\n    self.from_measure = from_measure\n    self.to_measure = to_measure\n    self.token_categories = token_categories if token_categories is not None else [c for c in TokenCategory]\n    self.kern_type = kern_type\n    self.instruments = instruments\n    self.show_measure_numbers = show_measure_numbers\n    self.spine_ids = spine_ids  # When exporting, if spine_ids=None all the spines will be exported.\n</code></pre>"},{"location":"reference/#kernpy.ExportOptions.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two ExportOptions objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>ExportOptions</code> <p>The other ExportOptions object to compare.</p> required <p>Returns (bool):     True if the objects are not equal, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 != options2\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 != options3\nTrue\n</code></pre> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def __ne__(self, other: 'ExportOptions') -&gt; bool:\n    \"\"\"\n    Compare two ExportOptions objects.\n\n    Args:\n        other (ExportOptions): The other ExportOptions object to compare.\n\n    Returns (bool):\n        True if the objects are not equal, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options1 != options2\n        False\n\n        &gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options1 != options3\n        True\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.Exporter","title":"<code>Exporter</code>","text":"Source code in <code>kernpy/core/exporter.py</code> <pre><code>class Exporter:\n    def export_string(self, document: Document, options: ExportOptions) -&gt; str:\n        self.export_options_validator(document, options)\n\n        rows = []\n\n        if options.to_measure is not None and options.to_measure &lt; len(document.measure_start_tree_stages):\n\n            if options.to_measure &lt; len(document.measure_start_tree_stages) - 1:\n                to_stage = document.measure_start_tree_stages[\n                    options.to_measure]  # take the barlines from the next coming measure\n            else:\n                to_stage = len(document.tree.stages) - 1  # all stages\n        else:\n            to_stage = len(document.tree.stages) - 1  # all stages\n\n        if options.from_measure:\n            # In case of beginning not from the first measure, we recover the spine creation and the headers\n            # Traversed in reverse order to only include the active spines at the given measure...\n            from_stage = document.measure_start_tree_stages[options.from_measure - 1]\n            next_nodes = document.tree.stages[from_stage]\n            while next_nodes and len(next_nodes) &gt; 0 and next_nodes[0] != document.tree.root:\n                row = []\n                new_next_nodes = []\n                non_place_holder_in_row = False\n                spine_operation_row = False\n                for node in next_nodes:\n                    if isinstance(node.token, SpineOperationToken):\n                        spine_operation_row = True\n                        break\n\n                for node in next_nodes:\n                    content = ''\n                    if isinstance(node.token, HeaderToken) and node.token.encoding in options.spine_types:\n                        content = self.export_token(node.token, options)\n                        non_place_holder_in_row = True\n                    elif spine_operation_row:\n                        # either if it is the split operator that has been cancelled, or the join one\n                        if isinstance(node.token, SpineOperationToken) and (node.token.is_cancelled_at(\n                                from_stage) or node.last_spine_operator_node and node.last_spine_operator_node.token.cancelled_at_stage == node.stage):\n                            content = '*'\n                        else:\n                            content = self.export_token(node.token, options)\n                            non_place_holder_in_row = True\n                    if content:\n                        row.append(content)\n                    new_next_nodes.append(node.parent)\n                next_nodes = new_next_nodes\n                if non_place_holder_in_row:  # if the row contains just place holders due to an ommitted place holder, don't add it\n                    rows.insert(0, row)\n\n            # now, export the signatures\n            node_signatures = None\n            for node in document.tree.stages[from_stage]:\n                node_signature_rows = []\n                for signature_node in node.last_signature_nodes.nodes.values():\n                    if not self.is_signature_cancelled(signature_node, node, from_stage, to_stage):\n                        node_signature_rows.append(self.export_token(signature_node.token, options))\n                if len(node_signature_rows) &gt; 0:\n                    if not node_signatures:\n                        node_signatures = []  # an array for each spine\n                    else:\n                        if len(node_signatures[0]) != len(node_signature_rows):\n                            raise Exception(f'Node signature mismatch: multiple spines with signatures at measure {len(rows)}')  # TODO better message\n                    node_signatures.append(node_signature_rows)\n\n            if node_signatures:\n                for irow in range(len(node_signatures[0])):  # all spines have the same number of rows\n                    row = []\n                    for icol in range(len(node_signatures)):  #len(node_signatures) = number of spines\n                        row.append(node_signatures[icol][irow])\n                    rows.append(row)\n\n        else:\n            from_stage = 0\n            rows = []\n\n        #if not node.token.category == TokenCategory.LINE_COMMENTS and not node.token.category == TokenCategory.FIELD_COMMENTS:\n        for stage in range(from_stage, to_stage + 1):  # to_stage included\n            row = []\n            for node in document.tree.stages[stage]:\n                self.append_row(document=document, node=node, options=options, row=row)\n\n            if len(row) &gt; 0:\n                rows.append(row)\n\n        # now, add the spine terminate row\n        if options.to_measure is not None and len(rows) &gt; 0 and rows[len(rows) - 1][\n            0] != '*-':  # if the terminate is not added yet\n            spine_count = len(rows[len(rows) - 1])\n            row = []\n            for i in range(spine_count):\n                row.append('*-')\n            rows.append(row)\n\n        result = \"\"\n        for row in rows:\n            if not empty_row(row):\n                result += '\\t'.join(row) + '\\n'\n        return result\n\n    def compute_header_type(self, node) -&gt; Optional[HeaderToken]:\n        \"\"\"\n        Compute the header type of the node.\n\n        Args:\n            node (Node): The node to compute.\n\n        Returns (Optional[Token]): The header type `Node`object. None if the current node is the header.\n\n        \"\"\"\n        if isinstance(node.token, HeaderToken):\n            header_type = node.token\n        elif node.header_node:\n            header_type = node.header_node.token\n        else:\n            header_type = None\n        return header_type\n\n    def export_token(self, token: Token, options: ExportOptions) -&gt; str:\n        if isinstance(token, HeaderToken):\n            new_token = HeaderTokenGenerator.new(token=token, type=options.kern_type)\n        else:\n            new_token = token\n        return (TokenizerFactory\n                .create(options.kern_type.value, token_categories=options.token_categories)\n                .tokenize(new_token))\n\n    def append_row(self, document: Document, node, options: ExportOptions, row: list) -&gt; bool:\n        \"\"\"\n        Append a row to the row list if the node accomplishes the requirements.\n        Args:\n            document (Document): The document with the spines.\n            node (Node): The node to append.\n            options (ExportOptions): The export options to filter the token.\n            row (list): The row to append.\n\n        Returns (bool): True if the row was appended. False if the row was not appended.\n        \"\"\"\n        header_type = self.compute_header_type(node)\n\n        if (header_type is not None\n                and header_type.encoding in options.spine_types\n                and not node.token.hidden\n                and (isinstance(node.token, ComplexToken) or node.token.category in options.token_categories)\n                and (options.spine_ids is None or header_type.spine_id in options.spine_ids)\n        # If None, all the spines will be exported. TODO: put all the spines as spine_ids = None\n        ):\n            row.append(self.export_token(node.token, options))\n            return True\n\n        return False\n\n    def get_spine_types(self, document: Document, spine_types: list = None):\n        \"\"\"\n        Get the spine types from the document.\n\n        Args:\n            document (Document): The document with the spines.\n            spine_types (list): The spine types to export. If None, all the spine types will be exported.\n\n        Returns: A list with the spine types.\n\n        Examples:\n            &gt;&gt;&gt; exporter = Exporter()\n            &gt;&gt;&gt; exporter.get_spine_types(document)\n            ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n            &gt;&gt;&gt; exporter.get_spine_types(document, None)\n            ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n            &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern'])\n            ['**kern', '**kern', '**kern', '**kern']\n            &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root'])\n            ['**kern', '**kern', '**kern', '**kern', '**root']\n            &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root', '**harm'])\n            ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n            &gt;&gt;&gt; exporter.get_spine_types(document, [])\n            []\n        \"\"\"\n        if spine_types is not None and len(spine_types) == 0:\n            return []\n\n        options = ExportOptions(spine_types=spine_types, token_categories=[TokenCategory.HEADER])\n        content = self.export_string(document, options)\n\n        # Remove all after the first line: **kern, **mens, etc... are always in the first row\n        lines = content.split('\\n')\n        first_line = lines[0:1]\n        tokens = first_line[0].split('\\t')\n\n        return tokens if tokens not in [[], ['']] else []\n\n\n    @classmethod\n    def export_options_validator(cls, document: Document, options: ExportOptions) -&gt; None:\n        \"\"\"\n        Validate the export options. Raise an exception if the options are invalid.\n\n        Args:\n            document: `Document` - The document to export.\n            options: `ExportOptions` - The options to export the document.\n\n        Returns: None\n\n        Example:\n            &gt;&gt;&gt; export_options_validator(document, options)\n            ValueError: option from_measure must be &gt;=0 but -1 was found.\n            &gt;&gt;&gt; export_options_validator(document, options2)\n            None\n        \"\"\"\n        if options.from_measure is not None and options.from_measure &lt; 0:\n            raise ValueError(f'option from_measure must be &gt;=0 but {options.from_measure} was found. ')\n        if options.to_measure is not None and options.to_measure &gt; len(document.measure_start_tree_stages):\n            # \"TODO: DAVID, check options.to_measure bounds. len(document.measure_start_tree_stages) or len(document.measure_start_tree_stages) - 1\"\n            raise ValueError(\n                f'option to_measure must be &lt;= {len(document.measure_start_tree_stages)} but {options.to_measure} was found. ')\n        if options.to_measure is not None and options.from_measure is not None and options.to_measure &lt; options.from_measure:\n            raise ValueError(\n                f'option to_measure must be &gt;= from_measure but {options.to_measure} &lt; {options.from_measure} was found. ')\n\n    def is_signature_cancelled(self, signature_node, node, from_stage, to_stage) -&gt; bool:\n        if node.token.__class__ == signature_node.token.__class__:\n            return True\n        elif isinstance(node.token, NoteRestToken):\n            return False\n        elif from_stage &lt; to_stage:\n            for child in node.children:\n                if self.is_signature_cancelled(signature_node, child, from_stage + 1, to_stage):\n                    return True\n            return False\n</code></pre>"},{"location":"reference/#kernpy.Exporter.append_row","title":"<code>append_row(document, node, options, row)</code>","text":"<p>Append a row to the row list if the node accomplishes the requirements. Args:     document (Document): The document with the spines.     node (Node): The node to append.     options (ExportOptions): The export options to filter the token.     row (list): The row to append.</p> <p>Returns (bool): True if the row was appended. False if the row was not appended.</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def append_row(self, document: Document, node, options: ExportOptions, row: list) -&gt; bool:\n    \"\"\"\n    Append a row to the row list if the node accomplishes the requirements.\n    Args:\n        document (Document): The document with the spines.\n        node (Node): The node to append.\n        options (ExportOptions): The export options to filter the token.\n        row (list): The row to append.\n\n    Returns (bool): True if the row was appended. False if the row was not appended.\n    \"\"\"\n    header_type = self.compute_header_type(node)\n\n    if (header_type is not None\n            and header_type.encoding in options.spine_types\n            and not node.token.hidden\n            and (isinstance(node.token, ComplexToken) or node.token.category in options.token_categories)\n            and (options.spine_ids is None or header_type.spine_id in options.spine_ids)\n    # If None, all the spines will be exported. TODO: put all the spines as spine_ids = None\n    ):\n        row.append(self.export_token(node.token, options))\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/#kernpy.Exporter.compute_header_type","title":"<code>compute_header_type(node)</code>","text":"<p>Compute the header type of the node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node to compute.</p> required <p>Returns (Optional[Token]): The header type <code>Node</code>object. None if the current node is the header.</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def compute_header_type(self, node) -&gt; Optional[HeaderToken]:\n    \"\"\"\n    Compute the header type of the node.\n\n    Args:\n        node (Node): The node to compute.\n\n    Returns (Optional[Token]): The header type `Node`object. None if the current node is the header.\n\n    \"\"\"\n    if isinstance(node.token, HeaderToken):\n        header_type = node.token\n    elif node.header_node:\n        header_type = node.header_node.token\n    else:\n        header_type = None\n    return header_type\n</code></pre>"},{"location":"reference/#kernpy.Exporter.export_options_validator","title":"<code>export_options_validator(document, options)</code>  <code>classmethod</code>","text":"<p>Validate the export options. Raise an exception if the options are invalid.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p><code>Document</code> - The document to export.</p> required <code>options</code> <code>ExportOptions</code> <p><code>ExportOptions</code> - The options to export the document.</p> required <p>Returns: None</p> Example <p>export_options_validator(document, options) ValueError: option from_measure must be &gt;=0 but -1 was found. export_options_validator(document, options2) None</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>@classmethod\ndef export_options_validator(cls, document: Document, options: ExportOptions) -&gt; None:\n    \"\"\"\n    Validate the export options. Raise an exception if the options are invalid.\n\n    Args:\n        document: `Document` - The document to export.\n        options: `ExportOptions` - The options to export the document.\n\n    Returns: None\n\n    Example:\n        &gt;&gt;&gt; export_options_validator(document, options)\n        ValueError: option from_measure must be &gt;=0 but -1 was found.\n        &gt;&gt;&gt; export_options_validator(document, options2)\n        None\n    \"\"\"\n    if options.from_measure is not None and options.from_measure &lt; 0:\n        raise ValueError(f'option from_measure must be &gt;=0 but {options.from_measure} was found. ')\n    if options.to_measure is not None and options.to_measure &gt; len(document.measure_start_tree_stages):\n        # \"TODO: DAVID, check options.to_measure bounds. len(document.measure_start_tree_stages) or len(document.measure_start_tree_stages) - 1\"\n        raise ValueError(\n            f'option to_measure must be &lt;= {len(document.measure_start_tree_stages)} but {options.to_measure} was found. ')\n    if options.to_measure is not None and options.from_measure is not None and options.to_measure &lt; options.from_measure:\n        raise ValueError(\n            f'option to_measure must be &gt;= from_measure but {options.to_measure} &lt; {options.from_measure} was found. ')\n</code></pre>"},{"location":"reference/#kernpy.Exporter.get_spine_types","title":"<code>get_spine_types(document, spine_types=None)</code>","text":"<p>Get the spine types from the document.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>The document with the spines.</p> required <code>spine_types</code> <code>list</code> <p>The spine types to export. If None, all the spine types will be exported.</p> <code>None</code> <p>Returns: A list with the spine types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exporter = Exporter()\n&gt;&gt;&gt; exporter.get_spine_types(document)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern'])\n['**kern', '**kern', '**kern', '**kern']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root'])\n['**kern', '**kern', '**kern', '**kern', '**root']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root', '**harm'])\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, [])\n[]\n</code></pre> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def get_spine_types(self, document: Document, spine_types: list = None):\n    \"\"\"\n    Get the spine types from the document.\n\n    Args:\n        document (Document): The document with the spines.\n        spine_types (list): The spine types to export. If None, all the spine types will be exported.\n\n    Returns: A list with the spine types.\n\n    Examples:\n        &gt;&gt;&gt; exporter = Exporter()\n        &gt;&gt;&gt; exporter.get_spine_types(document)\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; exporter.get_spine_types(document, None)\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern'])\n        ['**kern', '**kern', '**kern', '**kern']\n        &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root'])\n        ['**kern', '**kern', '**kern', '**kern', '**root']\n        &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root', '**harm'])\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; exporter.get_spine_types(document, [])\n        []\n    \"\"\"\n    if spine_types is not None and len(spine_types) == 0:\n        return []\n\n    options = ExportOptions(spine_types=spine_types, token_categories=[TokenCategory.HEADER])\n    content = self.export_string(document, options)\n\n    # Remove all after the first line: **kern, **mens, etc... are always in the first row\n    lines = content.split('\\n')\n    first_line = lines[0:1]\n    tokens = first_line[0].split('\\t')\n\n    return tokens if tokens not in [[], ['']] else []\n</code></pre>"},{"location":"reference/#kernpy.F3Clef","title":"<code>F3Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class F3Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the F Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('F'), 3)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('B', 3)\n</code></pre>"},{"location":"reference/#kernpy.F3Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the F Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the F Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('F'), 3)\n</code></pre>"},{"location":"reference/#kernpy.F3Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('B', 3)\n</code></pre>"},{"location":"reference/#kernpy.F4Clef","title":"<code>F4Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class F4Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the F Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('F'), 4)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('G', 2)\n</code></pre>"},{"location":"reference/#kernpy.F4Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the F Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the F Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('F'), 4)\n</code></pre>"},{"location":"reference/#kernpy.F4Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('G', 2)\n</code></pre>"},{"location":"reference/#kernpy.FingSpineImporter","title":"<code>FingSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/fing_spine_importer.py</code> <pre><code>class FingSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()\n\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if not any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.FINGERING)\n\n        return token\n</code></pre>"},{"location":"reference/#kernpy.FingSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/fing_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.GClef","title":"<code>GClef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class GClef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the G Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('G'), 2)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('E', 4)\n</code></pre>"},{"location":"reference/#kernpy.GClef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the G Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the G Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('G'), 2)\n</code></pre>"},{"location":"reference/#kernpy.GClef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('E', 4)\n</code></pre>"},{"location":"reference/#kernpy.GraphvizExporter","title":"<code>GraphvizExporter</code>","text":"Source code in <code>kernpy/core/graphviz_exporter.py</code> <pre><code>class GraphvizExporter:\n    def export_token(self, token: Token):\n        if token is None or token.encoding is None:\n            return ''\n        else:\n            return token.encoding.replace('\\\"', '\\\\\"').replace('\\\\', '\\\\\\\\')\n\n    @staticmethod\n    def node_id(node: Node):\n        return f\"node{id(node)}\"\n\n    def export_to_dot(self, tree: MultistageTree, filename: Path = None):\n        \"\"\"\n        Export the given MultistageTree to DOT format.\n\n        Args:\n            tree (MultistageTree): The tree to export.\n            filename (Path or None): The output file path. If None, prints to stdout.\n        \"\"\"\n        file = sys.stdout if filename is None else open(filename, 'w')\n\n        try:\n            file.write('digraph G {\\n')\n            file.write('    node [shape=record];\\n')\n            file.write('    rankdir=TB;\\n')  # Ensure top-to-bottom layout\n\n            # Create subgraphs for each stage\n            for stage_index, stage in enumerate(tree.stages):\n                if stage:\n                    file.write('  {rank=same; ')\n                    for node in stage:\n                        file.write(f'\"{self.node_id(node)}\"; ')\n                    file.write('}\\n')\n\n            # Write nodes and their connections\n            self._write_nodes_iterative(tree.root, file)\n            self._write_edges_iterative(tree.root, file)\n\n            file.write('}\\n')\n\n        finally:\n            if filename is not None:\n                file.close()  # Close only if we explicitly opened a file\n\n    def _write_nodes_iterative(self, root, file):\n        stack = [root]\n\n        while stack:\n            node = stack.pop()\n            header_label = f'header #{node.header_node.id}' if node.header_node else ''\n            last_spine_operator_label = f'last spine op. #{node.last_spine_operator_node.id}' if node.last_spine_operator_node else ''\n            category_name = getattr(getattr(getattr(node, \"token\", None), \"category\", None), \"_name_\", \"Non defined category\")\n\n\n            top_record_label = f'{{ #{node.id}| stage {node.stage} | {header_label} | {last_spine_operator_label} | {category_name} }}'\n            signatures_label = ''\n            if node.last_signature_nodes and node.last_signature_nodes.nodes:\n                for k, v in node.last_signature_nodes.nodes.items():\n                    if signatures_label:\n                        signatures_label += '|'\n                    signatures_label += f'{k} #{v.id}'\n\n            if isinstance(node.token, SpineOperationToken) and node.token.cancelled_at_stage:\n                signatures_label += f'| {{ cancelled at stage {node.token.cancelled_at_stage} }}'\n\n            file.write(f'  \"{self.node_id(node)}\" [label=\"{{ {top_record_label} | {signatures_label} | {self.export_token(node.token)} }}\"];\\n')\n\n            # Add children to the stack to be processed\n            for child in reversed(node.children):\n                stack.append(child)\n\n    def _write_edges_iterative(self, root, file):\n        stack = [root]\n\n        while stack:\n            node = stack.pop()\n            for child in node.children:\n                file.write(f'  \"{self.node_id(node)}\" -&gt; \"{self.node_id(child)}\";\\n')\n                stack.append(child)\n</code></pre>"},{"location":"reference/#kernpy.GraphvizExporter.export_to_dot","title":"<code>export_to_dot(tree, filename=None)</code>","text":"<p>Export the given MultistageTree to DOT format.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>MultistageTree</code> <p>The tree to export.</p> required <code>filename</code> <code>Path or None</code> <p>The output file path. If None, prints to stdout.</p> <code>None</code> Source code in <code>kernpy/core/graphviz_exporter.py</code> <pre><code>def export_to_dot(self, tree: MultistageTree, filename: Path = None):\n    \"\"\"\n    Export the given MultistageTree to DOT format.\n\n    Args:\n        tree (MultistageTree): The tree to export.\n        filename (Path or None): The output file path. If None, prints to stdout.\n    \"\"\"\n    file = sys.stdout if filename is None else open(filename, 'w')\n\n    try:\n        file.write('digraph G {\\n')\n        file.write('    node [shape=record];\\n')\n        file.write('    rankdir=TB;\\n')  # Ensure top-to-bottom layout\n\n        # Create subgraphs for each stage\n        for stage_index, stage in enumerate(tree.stages):\n            if stage:\n                file.write('  {rank=same; ')\n                for node in stage:\n                    file.write(f'\"{self.node_id(node)}\"; ')\n                file.write('}\\n')\n\n        # Write nodes and their connections\n        self._write_nodes_iterative(tree.root, file)\n        self._write_edges_iterative(tree.root, file)\n\n        file.write('}\\n')\n\n    finally:\n        if filename is not None:\n            file.close()  # Close only if we explicitly opened a file\n</code></pre>"},{"location":"reference/#kernpy.HarmSpineImporter","title":"<code>HarmSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/harm_spine_importer.py</code> <pre><code>class HarmSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if not any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.HARMONY)\n\n        return token\n</code></pre>"},{"location":"reference/#kernpy.HarmSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/harm_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.HeaderToken","title":"<code>HeaderToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>HeaderTokens class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class HeaderToken(SimpleToken):\n    \"\"\"\n    HeaderTokens class.\n    \"\"\"\n\n    def __init__(self, encoding, spine_id: int):\n        \"\"\"\n        Constructor for the HeaderToken class.\n\n        Args:\n            encoding (str): The original representation of the token.\n            spine_id (int): The spine id of the token. The spine id is used to identify the token in the score.\\\n                The spine_id starts from 0 and increases by 1 for each new spine like the following example:\n                **kern  **kern  **kern **dyn **text\n                0   1   2   3   4\n        \"\"\"\n        super().__init__(encoding, TokenCategory.HEADER)\n        self.spine_id = spine_id\n\n    def export(self, **kwargs) -&gt; str:\n        return self.encoding\n</code></pre>"},{"location":"reference/#kernpy.HeaderToken.__init__","title":"<code>__init__(encoding, spine_id)</code>","text":"<p>Constructor for the HeaderToken class.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>spine_id</code> <code>int</code> <p>The spine id of the token. The spine id is used to identify the token in the score.                The spine_id starts from 0 and increases by 1 for each new spine like the following example: kern  kern  kern dyn **text 0   1   2   3   4</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding, spine_id: int):\n    \"\"\"\n    Constructor for the HeaderToken class.\n\n    Args:\n        encoding (str): The original representation of the token.\n        spine_id (int): The spine id of the token. The spine id is used to identify the token in the score.\\\n            The spine_id starts from 0 and increases by 1 for each new spine like the following example:\n            **kern  **kern  **kern **dyn **text\n            0   1   2   3   4\n    \"\"\"\n    super().__init__(encoding, TokenCategory.HEADER)\n    self.spine_id = spine_id\n</code></pre>"},{"location":"reference/#kernpy.HeaderTokenGenerator","title":"<code>HeaderTokenGenerator</code>","text":"<p>HeaderTokenGenerator class.</p> <p>This class is used to translate the HeaderTokens to the specific tokenizer format.</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>class HeaderTokenGenerator:\n    \"\"\"\n    HeaderTokenGenerator class.\n\n    This class is used to translate the HeaderTokens to the specific tokenizer format.\n    \"\"\"\n    @classmethod\n    def new(cls, *, token: HeaderToken, type: Encoding):\n        \"\"\"\n        Create a new HeaderTokenGenerator object. Only accepts stardized Humdrum **kern encodings. \n\n        Args:\n            token (HeaderToken): The HeaderToken to be translated.\n            type (Encoding): The tokenizer to be used.\n\n        Examples:\n            &gt;&gt;&gt; header = HeaderToken('**kern', 0)\n            &gt;&gt;&gt; header.encoding\n            '**kern'\n            &gt;&gt;&gt; new_header = HeaderTokenGenerator.new(token=header, type=Encoding.eKern)\n            &gt;&gt;&gt; new_header.encoding\n            '**ekern'\n        \"\"\"\n        new_encoding = f'**{type.prefix()}{token.encoding[2:]}'\n        new_token = HeaderToken(new_encoding, token.spine_id)\n\n        return new_token\n</code></pre>"},{"location":"reference/#kernpy.HeaderTokenGenerator.new","title":"<code>new(*, token, type)</code>  <code>classmethod</code>","text":"<p>Create a new HeaderTokenGenerator object. Only accepts stardized Humdrum **kern encodings. </p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>HeaderToken</code> <p>The HeaderToken to be translated.</p> required <code>type</code> <code>Encoding</code> <p>The tokenizer to be used.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; header = HeaderToken('**kern', 0)\n&gt;&gt;&gt; header.encoding\n'**kern'\n&gt;&gt;&gt; new_header = HeaderTokenGenerator.new(token=header, type=Encoding.eKern)\n&gt;&gt;&gt; new_header.encoding\n'**ekern'\n</code></pre> Source code in <code>kernpy/core/exporter.py</code> <pre><code>@classmethod\ndef new(cls, *, token: HeaderToken, type: Encoding):\n    \"\"\"\n    Create a new HeaderTokenGenerator object. Only accepts stardized Humdrum **kern encodings. \n\n    Args:\n        token (HeaderToken): The HeaderToken to be translated.\n        type (Encoding): The tokenizer to be used.\n\n    Examples:\n        &gt;&gt;&gt; header = HeaderToken('**kern', 0)\n        &gt;&gt;&gt; header.encoding\n        '**kern'\n        &gt;&gt;&gt; new_header = HeaderTokenGenerator.new(token=header, type=Encoding.eKern)\n        &gt;&gt;&gt; new_header.encoding\n        '**ekern'\n    \"\"\"\n    new_encoding = f'**{type.prefix()}{token.encoding[2:]}'\n    new_token = HeaderToken(new_encoding, token.spine_id)\n\n    return new_token\n</code></pre>"},{"location":"reference/#kernpy.HumdrumPitchImporter","title":"<code>HumdrumPitchImporter</code>","text":"<p>               Bases: <code>PitchImporter</code></p> <p>Represents the pitch in the Humdrum Kern format.</p> <p>The name is represented using the International Standard Organization (ISO) name notation. The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.</p> <p>The Humdrum Kern format uses the following name representation: 'c' = C4 'cc' = C5 'ccc' = C6 'cccc' = C7</p> <p>'C' = C3 'CC' = C2 'CCC' = C1</p> <p>This class do not limit the name ranges.</p> <p>In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.</p> <pre><code>**kern\n*clefG2\n2c          // C4\n2cc         // C5\n2ccc        // C6\n2C          // C3\n2CC         // C2\n2CCC        // C1\n*-\n</code></pre> Source code in <code>kernpy/core/pitch_models.py</code> <pre><code>class HumdrumPitchImporter(PitchImporter):\n    \"\"\"\n    Represents the pitch in the Humdrum Kern format.\n\n    The name is represented using the International Standard Organization (ISO) name notation.\n    The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.\n\n    The Humdrum Kern format uses the following name representation:\n    'c' = C4\n    'cc' = C5\n    'ccc' = C6\n    'cccc' = C7\n\n    'C' = C3\n    'CC' = C2\n    'CCC' = C1\n\n    This class do not limit the name ranges.\n\n    In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.\n    ```\n    **kern\n    *clefG2\n    2c          // C4\n    2cc         // C5\n    2ccc        // C6\n    2C          // C3\n    2CC         // C2\n    2CCC        // C1\n    *-\n    ```\n    \"\"\"\n    C4_PITCH_LOWERCASE = 'c'\n    C4_OCATAVE = 4\n    C3_PITCH_UPPERCASE = 'C'\n    C3_OCATAVE = 3\n    VALID_PITCHES = 'abcdefg' + 'ABCDEFG'\n\n    def __init__(self):\n        super().__init__()\n\n    def import_pitch(self, encoding: str) -&gt; AgnosticPitch:\n        self.name, self.octave = self._parse_pitch(encoding)\n        return AgnosticPitch(self.name, self.octave)\n\n    def _parse_pitch(self, encoding: str) -&gt; tuple:\n        accidentals = ''.join([c for c in encoding if c in ['#', '-']])\n        accidentals = accidentals.replace('#', '+')\n        encoding = encoding.replace('#', '').replace('-', '')\n        pitch = encoding[0].lower()\n        octave = None\n        if encoding[0].islower():\n            min_octave = HumdrumPitchImporter.C4_OCATAVE\n            octave = min_octave + (len(encoding) - 1)\n        elif encoding[0].isupper():\n            max_octave = HumdrumPitchImporter.C3_OCATAVE\n            octave = max_octave - (len(encoding) - 1)\n        name = f\"{pitch}{accidentals}\"\n        return name, octave\n</code></pre>"},{"location":"reference/#kernpy.Importer","title":"<code>Importer</code>","text":"<p>Importer class.</p> <p>Use this class to import the content from a file or a string to a <code>Document</code> object.</p> Source code in <code>kernpy/core/importer.py</code> <pre><code>class Importer:\n    \"\"\"\n    Importer class.\n\n    Use this class to import the content from a file or a string to a `Document` object.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Create an instance of the importer.\n\n        Raises:\n            Exception: If the importer content is not a valid **kern file.\n\n        Examples:\n            # Create the importer\n            &gt;&gt;&gt; importer = Importer()\n\n            # Import the content from a file\n            &gt;&gt;&gt; document = importer.import_file('file.krn')\n\n            # Import the content from a string\n            &gt;&gt;&gt; document = importer.import_string(\"**kern\\n*clefF4\\nc4\\n4d\\n4e\\n4f\\n*-\")\n        \"\"\"\n        self.last_measure_number = None\n        self.last_bounding_box = None\n        self.errors = []\n\n        self._tree = MultistageTree()\n        self._document = Document(self._tree)\n        self._importers = {}\n        self._header_row_number = None\n        self._row_number = 1\n        self._tree_stage = 0\n        self._next_stage_parents = None\n        self._prev_stage_parents = None\n        self._last_node_previous_to_header = self._tree.root\n\n    @staticmethod\n    def get_last_spine_operator(parent):\n        if parent is None:\n            return None\n        elif isinstance(parent.token, SpineOperationToken):\n            return parent\n        else:\n            return parent.last_spine_operator_node\n\n    #TODO Documentar c\u00f3mo propagamos los header_node y last_spine_operator_node...\n    def run(self, reader) -&gt; Document:\n        for row in reader:\n            if len(row) &lt;= 0:\n                # Found an empty row, usually the last one. Ignore it.\n                continue\n\n            self._tree_stage = self._tree_stage + 1\n            is_barline = False\n            if self._next_stage_parents:\n                self._prev_stage_parents = copy(self._next_stage_parents)\n            self._next_stage_parents = []\n\n            if row[0].startswith(\"!!\"):\n                self._compute_metacomment_token(row[0].strip())\n            else:\n                for icolumn, column in enumerate(row):\n                    if column.startswith(\"**\"):\n                        self._compute_header_token(icolumn, column)\n                        # go to next row\n                        continue\n\n                    if column in SPINE_OPERATIONS:\n                        self._compute_spine_operator_token(icolumn, column, row)\n                    else:  # column is not a spine operation\n                        if column.startswith(\"!\"):\n                            token = FieldCommentToken(column)\n                        else:\n                            if self._prev_stage_parents is None:\n                                raise ValueError(f'Any spine header found in the column #{icolumn}. '\n                                                 f'Expected a previous line with valid content. '\n                                                 f'The token in column #{icolumn} and row #{self._row_number - 1}'\n                                                 f' was not created correctly. Error detected in '\n                                                 f'column #{icolumn} in row #{self._row_number}. '\n                                                 f'Found {column}. ')\n                            if icolumn &gt;= len(self._prev_stage_parents):\n                                # TODO: Try to fix the kern in runtime. Add options to public API\n                                # continue  # ignore the column\n                                raise ValueError(f'Wrong columns number in row {self._row_number}. '\n                                                 f'The token in column #{icolumn} and row #{self._row_number}'\n                                                 f' has more columns than expected in its row. '\n                                                 f'Expected {len(self._prev_stage_parents)} columns '\n                                                 f'but found {len(row)}.')\n                            parent = self._prev_stage_parents[icolumn]\n                            if not parent:\n                                raise Exception(f'Cannot find a parent node for column #{icolumn} in row {self._row_number}')\n                            if not parent.header_node:\n                                raise Exception(f'Cannot find a header node for column #{icolumn} in row {self._row_number}')\n                            importer = self._importers.get(parent.header_node.token.encoding)\n                            if not importer:\n                                raise Exception(f'Cannot find an importer for header {parent.header_node.token.encoding}')\n                            try:\n                                token = importer.import_token(column)\n                            except Exception as error:\n                                token = ErrorToken(column, self._row_number, str(error))\n                                self.errors.append(token)\n                        if not token:\n                            raise Exception(\n                                f'No token generated for input {column} in row number #{self._row_number} using importer {importer}')\n\n                        parent = self._prev_stage_parents[icolumn]\n                        node = self._tree.add_node(self._tree_stage, parent, token, self.get_last_spine_operator(parent), parent.last_signature_nodes, parent.header_node)\n                        self._next_stage_parents.append(node)\n\n                        if (token.category == TokenCategory.BARLINES\n                                or TokenCategory.is_child(child=token.category, parent=TokenCategory.CORE)\n                                    and len(self._document.measure_start_tree_stages) == 0):\n                            is_barline = True\n                        elif isinstance(token, BoundingBoxToken):\n                            self.handle_bounding_box(self._document, token)\n                        elif isinstance(token, SignatureToken):\n                            node.last_signature_nodes.update(node)\n\n                if is_barline:\n                    self._document.measure_start_tree_stages.append(self._tree_stage)\n                    self.last_measure_number = len(self._document.measure_start_tree_stages)\n                    if self.last_bounding_box:\n                        self.last_bounding_box.to_measure = self.last_measure_number\n            self._row_number = self._row_number + 1\n        return self._document\n\n    def handle_bounding_box(self, document: Document, token: BoundingBoxToken):\n        page_number = token.page_number\n        last_page_bb = document.page_bounding_boxes.get(page_number)\n        if last_page_bb is None:\n            if self.last_measure_number is None:\n                self.last_measure_number = 0\n            self.last_bounding_box = BoundingBoxMeasures(token.bounding_box, self.last_measure_number,\n                                                         self.last_measure_number)\n            document.page_bounding_boxes[page_number] = self.last_bounding_box\n        else:\n            last_page_bb.bounding_box.extend(token.bounding_box)\n            last_page_bb.to_measure = self.last_measure_number\n\n    def import_file(self, file_path: Path) -&gt; Document:\n        \"\"\"\n        Import the content from the importer to the file.\n        Args:\n            file_path: The path to the file.\n\n        Returns:\n            Document - The document with the imported content.\n\n        Examples:\n            # Create the importer and read the file\n            &gt;&gt;&gt; importer = Importer()\n            &gt;&gt;&gt; importer.import_file('file.krn')\n        \"\"\"\n        with open(file_path, 'r', newline='', encoding='utf-8', errors='ignore') as file:\n            reader = csv.reader(file, delimiter='\\t')\n            return self.run(reader)\n\n    def import_string(self, text: str) -&gt; Document:\n        \"\"\"\n        Import the content from the content of the score in string format.\n\n        Args:\n            text: The content of the score in string format.\n\n        Returns:\n            Document - The document with the imported content.\n\n        Examples:\n            # Create the importer and read the file\n            &gt;&gt;&gt; importer = Importer()\n            &gt;&gt;&gt; importer.import_string(\"**kern\\n*clefF4\\nc4\\n4d\\n4e\\n4f\\n*-\")\n            # Read the content from a file\n            &gt;&gt;&gt; with open('file.krn',  'r', newline='', encoding='utf-8', errors='ignore') as f: # We encourage you to use these open file options\n            &gt;&gt;&gt;     content = f.read()\n            &gt;&gt;&gt; importer.import_string(content)\n            &gt;&gt;&gt; document = importer.import_string(content)\n        \"\"\"\n        lines = text.splitlines()\n        reader = csv.reader(lines, delimiter='\\t')\n        return self.run(reader)\n\n    def get_error_messages(self) -&gt; str:\n        \"\"\"\n        Get the error messages of the importer.\n\n        Returns: str - The error messages split by a new line character.\n\n        Examples:\n            # Create the importer and read the file\n            &gt;&gt;&gt; importer = Importer()\n            &gt;&gt;&gt; importer.import_file(Path('file.krn'))\n            &gt;&gt;&gt; print(importer.get_error_messages())\n            'Error: Invalid token in row 1'\n        \"\"\"\n        result = ''\n        for err in self.errors:\n            result += str(err)\n            result += '\\n'\n        return result\n\n    def has_errors(self) -&gt; bool:\n        \"\"\"\n        Check if the importer has any errors.\n\n        Returns: bool - True if the importer has errors, False otherwise.\n\n        Examples:\n            # Create the importer and read the file\n            &gt;&gt;&gt; importer = Importer()\n            &gt;&gt;&gt; importer.import_file(Path('file.krn'))    # file.krn has an error\n            &gt;&gt;&gt; print(importer.has_errors())\n            True\n            &gt;&gt;&gt; importer.import_file(Path('file2.krn'))   # file2.krn has no errors\n            &gt;&gt;&gt; print(importer.has_errors())\n            False\n        \"\"\"\n        return len(self.errors) &gt; 0\n\n    def _compute_metacomment_token(self, raw_token: str):\n        token = MetacommentToken(raw_token)\n        if self._header_row_number is None:\n            node = self._tree.add_node(self._tree_stage, self._last_node_previous_to_header, token, None, None, None)\n            self._last_node_previous_to_header = node\n        else:\n            for parent in self._prev_stage_parents:\n                node = self._tree.add_node(self._tree_stage, parent, token, self.get_last_spine_operator(parent), parent.last_signature_nodes, parent.header_node) # the same reference for all spines - TODO Recordar documentarlo\n                self._next_stage_parents.append(node)\n\n    def _compute_header_token(self, column_index: int, column_content: str):\n        if self._header_row_number is not None and self._header_row_number != self._row_number:\n            raise Exception(\n                f\"Several header rows not supported, there is a header row in #{self._header_row_number} and another in #{self._row_number} \")\n\n            # it's a spine header\n        self._document.header_stage = self._tree_stage\n        importer = self._importers.get(column_content)\n        if not importer:\n            importer = createImporter(column_content)\n            self._importers[column_content] = importer\n\n        token = HeaderToken(column_content, spine_id=column_index)\n        node = self._tree.add_node(self._tree_stage, self._last_node_previous_to_header, token, None, None)\n        node.header_node = node # this value will be propagated\n        self._next_stage_parents.append(node)\n\n    def _compute_spine_operator_token(self, column_index: int, column_content: str, row: List[str]):\n        token = SpineOperationToken(column_content)\n\n        if column_index &gt;= len(self._prev_stage_parents):\n            raise Exception(f'Expected at least {column_index+1} parents in row {self._row_number}, but found {len(self._prev_stage_parents)}: {row}')\n\n        parent = self._prev_stage_parents[column_index]\n        node = self._tree.add_node(self._tree_stage, parent, token, self.get_last_spine_operator(parent), parent.last_signature_nodes, parent.header_node)\n\n        if column_content == '*-':\n            if node.last_spine_operator_node is not None:\n                node.last_spine_operator_node.token.cancelled_at_stage = self._tree_stage\n            pass # it's terminated, no continuation\n        elif column_content == \"*+\" or column_content == \"*^\":\n            self._next_stage_parents.append(node)\n            self._next_stage_parents.append(node) # twice, the next stage two children will have this one as parent\n        elif column_content == \"*v\":\n            if node.last_spine_operator_node is not None:\n                node.last_spine_operator_node.token.cancelled_at_stage = self._tree_stage\n\n            if column_index == 0 or row[column_index-1] != '*v' or self._prev_stage_parents[column_index-1].header_node != self._prev_stage_parents[column_index].header_node: # don't collapse two different spines\n                self._next_stage_parents.append(node) # just one spine each two\n        else:\n            raise Exception(f'Unknown spine operation in column #{column_content} and row #{self._row_number}')\n</code></pre>"},{"location":"reference/#kernpy.Importer.__init__","title":"<code>__init__()</code>","text":"<pre><code>    Create an instance of the importer.\n\n    Raises:\n        Exception: If the importer content is not a valid **kern file.\n\n    Examples:\n        # Create the importer\n        &gt;&gt;&gt; importer = Importer()\n\n        # Import the content from a file\n        &gt;&gt;&gt; document = importer.import_file('file.krn')\n\n        # Import the content from a string\n        &gt;&gt;&gt; document = importer.import_string(\"**kern\n</code></pre> <p>clefF4 c4 4d 4e 4f -\")</p> Source code in <code>kernpy/core/importer.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Create an instance of the importer.\n\n    Raises:\n        Exception: If the importer content is not a valid **kern file.\n\n    Examples:\n        # Create the importer\n        &gt;&gt;&gt; importer = Importer()\n\n        # Import the content from a file\n        &gt;&gt;&gt; document = importer.import_file('file.krn')\n\n        # Import the content from a string\n        &gt;&gt;&gt; document = importer.import_string(\"**kern\\n*clefF4\\nc4\\n4d\\n4e\\n4f\\n*-\")\n    \"\"\"\n    self.last_measure_number = None\n    self.last_bounding_box = None\n    self.errors = []\n\n    self._tree = MultistageTree()\n    self._document = Document(self._tree)\n    self._importers = {}\n    self._header_row_number = None\n    self._row_number = 1\n    self._tree_stage = 0\n    self._next_stage_parents = None\n    self._prev_stage_parents = None\n    self._last_node_previous_to_header = self._tree.root\n</code></pre>"},{"location":"reference/#kernpy.Importer.get_error_messages","title":"<code>get_error_messages()</code>","text":"<p>Get the error messages of the importer.</p> <p>Returns: str - The error messages split by a new line character.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.Importer.get_error_messages--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file(Path('file.krn'))\n&gt;&gt;&gt; print(importer.get_error_messages())\n'Error: Invalid token in row 1'\n</code></pre> Source code in <code>kernpy/core/importer.py</code> <pre><code>def get_error_messages(self) -&gt; str:\n    \"\"\"\n    Get the error messages of the importer.\n\n    Returns: str - The error messages split by a new line character.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_file(Path('file.krn'))\n        &gt;&gt;&gt; print(importer.get_error_messages())\n        'Error: Invalid token in row 1'\n    \"\"\"\n    result = ''\n    for err in self.errors:\n        result += str(err)\n        result += '\\n'\n    return result\n</code></pre>"},{"location":"reference/#kernpy.Importer.has_errors","title":"<code>has_errors()</code>","text":"<p>Check if the importer has any errors.</p> <p>Returns: bool - True if the importer has errors, False otherwise.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.Importer.has_errors--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file(Path('file.krn'))    # file.krn has an error\n&gt;&gt;&gt; print(importer.has_errors())\nTrue\n&gt;&gt;&gt; importer.import_file(Path('file2.krn'))   # file2.krn has no errors\n&gt;&gt;&gt; print(importer.has_errors())\nFalse\n</code></pre> Source code in <code>kernpy/core/importer.py</code> <pre><code>def has_errors(self) -&gt; bool:\n    \"\"\"\n    Check if the importer has any errors.\n\n    Returns: bool - True if the importer has errors, False otherwise.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_file(Path('file.krn'))    # file.krn has an error\n        &gt;&gt;&gt; print(importer.has_errors())\n        True\n        &gt;&gt;&gt; importer.import_file(Path('file2.krn'))   # file2.krn has no errors\n        &gt;&gt;&gt; print(importer.has_errors())\n        False\n    \"\"\"\n    return len(self.errors) &gt; 0\n</code></pre>"},{"location":"reference/#kernpy.Importer.import_file","title":"<code>import_file(file_path)</code>","text":"<p>Import the content from the importer to the file. Args:     file_path: The path to the file.</p> <p>Returns:</p> Type Description <code>Document</code> <p>Document - The document with the imported content.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.Importer.import_file--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file('file.krn')\n</code></pre> Source code in <code>kernpy/core/importer.py</code> <pre><code>def import_file(self, file_path: Path) -&gt; Document:\n    \"\"\"\n    Import the content from the importer to the file.\n    Args:\n        file_path: The path to the file.\n\n    Returns:\n        Document - The document with the imported content.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_file('file.krn')\n    \"\"\"\n    with open(file_path, 'r', newline='', encoding='utf-8', errors='ignore') as file:\n        reader = csv.reader(file, delimiter='\\t')\n        return self.run(reader)\n</code></pre>"},{"location":"reference/#kernpy.Importer.import_string","title":"<code>import_string(text)</code>","text":"<pre><code>    Import the content from the content of the score in string format.\n\n    Args:\n        text: The content of the score in string format.\n\n    Returns:\n        Document - The document with the imported content.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_string(\"**kern\n</code></pre> <p>clefF4 c4 4d 4e 4f -\")             # Read the content from a file             &gt;&gt;&gt; with open('file.krn',  'r', newline='', encoding='utf-8', errors='ignore') as f: # We encourage you to use these open file options             &gt;&gt;&gt;     content = f.read()             &gt;&gt;&gt; importer.import_string(content)             &gt;&gt;&gt; document = importer.import_string(content)</p> Source code in <code>kernpy/core/importer.py</code> <pre><code>def import_string(self, text: str) -&gt; Document:\n    \"\"\"\n    Import the content from the content of the score in string format.\n\n    Args:\n        text: The content of the score in string format.\n\n    Returns:\n        Document - The document with the imported content.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_string(\"**kern\\n*clefF4\\nc4\\n4d\\n4e\\n4f\\n*-\")\n        # Read the content from a file\n        &gt;&gt;&gt; with open('file.krn',  'r', newline='', encoding='utf-8', errors='ignore') as f: # We encourage you to use these open file options\n        &gt;&gt;&gt;     content = f.read()\n        &gt;&gt;&gt; importer.import_string(content)\n        &gt;&gt;&gt; document = importer.import_string(content)\n    \"\"\"\n    lines = text.splitlines()\n    reader = csv.reader(lines, delimiter='\\t')\n    return self.run(reader)\n</code></pre>"},{"location":"reference/#kernpy.KernSpineImporter","title":"<code>KernSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/kern_spine_importer.py</code> <pre><code>class KernSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()\n\n    def import_token(self, encoding: str):\n        self._raise_error_if_wrong_input(encoding)\n\n        # self.listenerImporter = KernListenerImporter(token) # TODO \u00bfPor qu\u00e9 no va esto?\n        # self.listenerImporter.start()\n        lexer = kernSpineLexer(InputStream(encoding))\n        lexer.removeErrorListeners()\n        lexer.addErrorListener(self.error_listener)\n        stream = CommonTokenStream(lexer)\n        parser = kernSpineParser(stream)\n        parser._interp.predictionMode = PredictionMode.SLL  # it improves a lot the parsing\n        parser.removeErrorListeners()\n        parser.addErrorListener(self.error_listener)\n        parser.errHandler = BailErrorStrategy()\n        tree = parser.start()\n        walker = ParseTreeWalker()\n        listener = KernSpineListener()\n        walker.walk(listener, tree)\n        if self.error_listener.getNumberErrorsFound() &gt; 0:\n            raise Exception(self.error_listener.errors)\n        return listener.token\n</code></pre>"},{"location":"reference/#kernpy.KernSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/kern_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.KernTokenizer","title":"<code>KernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>KernTokenizer converts a Token into a normalized kern string representation.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class KernTokenizer(Tokenizer):\n    \"\"\"\n    KernTokenizer converts a Token into a normalized kern string representation.\n    \"\"\"\n    def __init__(self, *, token_categories: Set['TokenCategory']):\n        \"\"\"\n        Create a new KernTokenizer.\n\n        Args:\n            token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n        \"\"\"\n        super().__init__(token_categories=token_categories)\n\n    def tokenize(self, token: Token) -&gt; str:\n        \"\"\"\n        Tokenize a token into a normalized kern string representation.\n        This format is the classic Humdrum **kern representation.\n\n        Args:\n            token (Token): Token to be tokenized.\n\n        Returns (str): Normalized kern string representation. This is the classic Humdrum **kern representation.\n\n        Examples:\n            &gt;&gt;&gt; token.encoding\n            '2@.@bb@-\u00b7_\u00b7L'\n            &gt;&gt;&gt; KernTokenizer().tokenize(token)\n            '2.bb-_L'\n        \"\"\"\n        return EkernTokenizer(token_categories=self.token_categories).tokenize(token).replace(TOKEN_SEPARATOR, '').replace(DECORATION_SEPARATOR, '')\n</code></pre>"},{"location":"reference/#kernpy.KernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new KernTokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def __init__(self, *, token_categories: Set['TokenCategory']):\n    \"\"\"\n    Create a new KernTokenizer.\n\n    Args:\n        token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n    \"\"\"\n    super().__init__(token_categories=token_categories)\n</code></pre>"},{"location":"reference/#kernpy.KernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a normalized kern string representation. This format is the classic Humdrum **kern representation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>Token to be tokenized.</p> required <p>Returns (str): Normalized kern string representation. This is the classic Humdrum **kern representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; KernTokenizer().tokenize(token)\n'2.bb-_L'\n</code></pre> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def tokenize(self, token: Token) -&gt; str:\n    \"\"\"\n    Tokenize a token into a normalized kern string representation.\n    This format is the classic Humdrum **kern representation.\n\n    Args:\n        token (Token): Token to be tokenized.\n\n    Returns (str): Normalized kern string representation. This is the classic Humdrum **kern representation.\n\n    Examples:\n        &gt;&gt;&gt; token.encoding\n        '2@.@bb@-\u00b7_\u00b7L'\n        &gt;&gt;&gt; KernTokenizer().tokenize(token)\n        '2.bb-_L'\n    \"\"\"\n    return EkernTokenizer(token_categories=self.token_categories).tokenize(token).replace(TOKEN_SEPARATOR, '').replace(DECORATION_SEPARATOR, '')\n</code></pre>"},{"location":"reference/#kernpy.MensSpineImporter","title":"<code>MensSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/mens_spine_importer.py</code> <pre><code>class MensSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        MensSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        raise NotImplementedError()\n\n    def import_token(self, encoding: str) -&gt; Token:\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/#kernpy.MensSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>MensSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/mens_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    MensSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.MxhmSpineImporter","title":"<code>MxhmSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/mhxm_spine_importer.py</code> <pre><code>class MxhmSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.HARMONY)\n\n        return token\n\n        return MHXMToken(encoding)\n</code></pre>"},{"location":"reference/#kernpy.MxhmSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/mhxm_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.NoteRestToken","title":"<code>NoteRestToken</code>","text":"<p>               Bases: <code>ComplexToken</code></p> <p>NoteRestToken class.</p> <p>Attributes:</p> Name Type Description <code>pitch_duration_subtokens</code> <code>list</code> <p>The subtokens for the pitch and duration</p> <code>decoration_subtokens</code> <code>list</code> <p>The subtokens for the decorations</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class NoteRestToken(ComplexToken):\n    \"\"\"\n    NoteRestToken class.\n\n    Attributes:\n        pitch_duration_subtokens (list): The subtokens for the pitch and duration\n        decoration_subtokens (list): The subtokens for the decorations\n    \"\"\"\n\n    def __init__(\n            self,\n            encoding: str,\n            pitch_duration_subtokens: List[Subtoken],\n            decoration_subtokens: List[Subtoken]\n    ):\n        \"\"\"\n        NoteRestToken constructor.\n\n        Args:\n            encoding (str): The complete unprocessed encoding\n            pitch_duration_subtokens (List[Subtoken])y: The subtokens for the pitch and duration\n            decoration_subtokens (List[Subtoken]): The subtokens for the decorations. Individual elements of the token, of type Subtoken\n        \"\"\"\n        super().__init__(encoding, TokenCategory.NOTE_REST)\n        if not pitch_duration_subtokens or len(pitch_duration_subtokens) == 0:\n            raise ValueError('Empty name-duration subtokens')\n\n        for subtoken in pitch_duration_subtokens:\n            if not isinstance(subtoken, Subtoken):\n                raise ValueError(f'All pitch-duration subtokens must be instances of Subtoken. Found {type(subtoken)}')\n        for subtoken in decoration_subtokens:\n            if not isinstance(subtoken, Subtoken):\n                raise ValueError(f'All decoration subtokens must be instances of Subtoken. Found {type(subtoken)}')\n\n        self.pitch_duration_subtokens = pitch_duration_subtokens\n        self.decoration_subtokens = decoration_subtokens\n\n    def export(self, **kwargs) -&gt; str:\n        \"\"\"\n        Exports the token.\n\n        Keyword Arguments:\n            filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n                indicating whether the token should be included in the export. If provided, only tokens for which the\n                function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n        Returns (str): The exported token.\n\n        \"\"\"\n        filter_categories_fn = kwargs.get('filter_categories', None)\n\n        # Filter subcategories\n        pitch_duration_tokens = {\n            subtoken for subtoken in self.pitch_duration_subtokens\n            if filter_categories_fn is None or filter_categories_fn(subtoken.category)\n        }\n        decoration_tokens = {\n            subtoken for subtoken in self.decoration_subtokens\n            if filter_categories_fn is None or filter_categories_fn(subtoken.category)\n        }\n        pitch_duration_tokens_sorted = sorted(pitch_duration_tokens, key=lambda t:  (t.category.value, t.encoding))\n        decoration_tokens_sorted     = sorted(decoration_tokens,     key=lambda t:  (t.category.value, t.encoding))\n\n        # Join the sorted subtokens\n        pitch_duration_part = TOKEN_SEPARATOR.join([subtoken.encoding for subtoken in pitch_duration_tokens_sorted])\n        decoration_part = DECORATION_SEPARATOR.join([subtoken.encoding for subtoken in decoration_tokens_sorted])\n\n        result = pitch_duration_part\n        if len(decoration_part):\n            result += DECORATION_SEPARATOR + decoration_part\n\n        return result if len(result) &gt; 0 else EMPTY_TOKEN\n</code></pre>"},{"location":"reference/#kernpy.NoteRestToken.__init__","title":"<code>__init__(encoding, pitch_duration_subtokens, decoration_subtokens)</code>","text":"<p>NoteRestToken constructor.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>pitch_duration_subtokens</code> <code>List[Subtoken])y</code> <p>The subtokens for the pitch and duration</p> required <code>decoration_subtokens</code> <code>List[Subtoken]</code> <p>The subtokens for the decorations. Individual elements of the token, of type Subtoken</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(\n        self,\n        encoding: str,\n        pitch_duration_subtokens: List[Subtoken],\n        decoration_subtokens: List[Subtoken]\n):\n    \"\"\"\n    NoteRestToken constructor.\n\n    Args:\n        encoding (str): The complete unprocessed encoding\n        pitch_duration_subtokens (List[Subtoken])y: The subtokens for the pitch and duration\n        decoration_subtokens (List[Subtoken]): The subtokens for the decorations. Individual elements of the token, of type Subtoken\n    \"\"\"\n    super().__init__(encoding, TokenCategory.NOTE_REST)\n    if not pitch_duration_subtokens or len(pitch_duration_subtokens) == 0:\n        raise ValueError('Empty name-duration subtokens')\n\n    for subtoken in pitch_duration_subtokens:\n        if not isinstance(subtoken, Subtoken):\n            raise ValueError(f'All pitch-duration subtokens must be instances of Subtoken. Found {type(subtoken)}')\n    for subtoken in decoration_subtokens:\n        if not isinstance(subtoken, Subtoken):\n            raise ValueError(f'All decoration subtokens must be instances of Subtoken. Found {type(subtoken)}')\n\n    self.pitch_duration_subtokens = pitch_duration_subtokens\n    self.decoration_subtokens = decoration_subtokens\n</code></pre>"},{"location":"reference/#kernpy.NoteRestToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def export(self, **kwargs) -&gt; str:\n    \"\"\"\n    Exports the token.\n\n    Keyword Arguments:\n        filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n            indicating whether the token should be included in the export. If provided, only tokens for which the\n            function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n    Returns (str): The exported token.\n\n    \"\"\"\n    filter_categories_fn = kwargs.get('filter_categories', None)\n\n    # Filter subcategories\n    pitch_duration_tokens = {\n        subtoken for subtoken in self.pitch_duration_subtokens\n        if filter_categories_fn is None or filter_categories_fn(subtoken.category)\n    }\n    decoration_tokens = {\n        subtoken for subtoken in self.decoration_subtokens\n        if filter_categories_fn is None or filter_categories_fn(subtoken.category)\n    }\n    pitch_duration_tokens_sorted = sorted(pitch_duration_tokens, key=lambda t:  (t.category.value, t.encoding))\n    decoration_tokens_sorted     = sorted(decoration_tokens,     key=lambda t:  (t.category.value, t.encoding))\n\n    # Join the sorted subtokens\n    pitch_duration_part = TOKEN_SEPARATOR.join([subtoken.encoding for subtoken in pitch_duration_tokens_sorted])\n    decoration_part = DECORATION_SEPARATOR.join([subtoken.encoding for subtoken in decoration_tokens_sorted])\n\n    result = pitch_duration_part\n    if len(decoration_part):\n        result += DECORATION_SEPARATOR + decoration_part\n\n    return result if len(result) &gt; 0 else EMPTY_TOKEN\n</code></pre>"},{"location":"reference/#kernpy.PitchPositionReferenceSystem","title":"<code>PitchPositionReferenceSystem</code>","text":"Source code in <code>kernpy/core/gkern.py</code> <pre><code>class PitchPositionReferenceSystem:\n    def __init__(self, base_pitch: AgnosticPitch):\n        \"\"\"\n        Initializes the PitchPositionReferenceSystem object.\n        Args:\n            base_pitch (AgnosticPitch): The AgnosticPitch in the first line of the Staff. \\\n             The AgnosticPitch object that serves as the reference point for the system.\n        \"\"\"\n        self.base_pitch = base_pitch\n\n    def compute_position(self, pitch: AgnosticPitch) -&gt; PositionInStaff:\n        \"\"\"\n        Computes the position in staff for the given pitch.\n        Args:\n            pitch (AgnosticPitch): The AgnosticPitch object to compute the position for.\n        Returns:\n            PositionInStaff: The PositionInStaff object representing the computed position.\n        \"\"\"\n        # map A\u2013G to 0\u20136\n        LETTER_TO_INDEX = {'C': 0, 'D': 1, 'E': 2,\n                           'F': 3, 'G': 4, 'A': 5, 'B': 6}\n\n        # strip off any '+' or '-' accidentals, then grab the letter\n        def letter(p: AgnosticPitch) -&gt; str:\n            name = p.name.replace('+', '').replace('-', '')\n            return AgnosticPitch(name, p.octave).name\n\n        base_letter_idx = LETTER_TO_INDEX[letter(self.base_pitch)]\n        target_letter_idx = LETTER_TO_INDEX[letter(pitch)]\n\n        # \"octave difference \u00d7 7\" plus the letter\u2010index difference\n        diatonic_steps = (pitch.octave - self.base_pitch.octave) * 7 \\\n                         + (target_letter_idx - base_letter_idx)\n\n        # that many \"lines or spaces\" above (or below) the reference line\n        return PositionInStaff(diatonic_steps)\n</code></pre>"},{"location":"reference/#kernpy.PitchPositionReferenceSystem.__init__","title":"<code>__init__(base_pitch)</code>","text":"<p>Initializes the PitchPositionReferenceSystem object. Args:     base_pitch (AgnosticPitch): The AgnosticPitch in the first line of the Staff.              The AgnosticPitch object that serves as the reference point for the system.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self, base_pitch: AgnosticPitch):\n    \"\"\"\n    Initializes the PitchPositionReferenceSystem object.\n    Args:\n        base_pitch (AgnosticPitch): The AgnosticPitch in the first line of the Staff. \\\n         The AgnosticPitch object that serves as the reference point for the system.\n    \"\"\"\n    self.base_pitch = base_pitch\n</code></pre>"},{"location":"reference/#kernpy.PitchPositionReferenceSystem.compute_position","title":"<code>compute_position(pitch)</code>","text":"<p>Computes the position in staff for the given pitch. Args:     pitch (AgnosticPitch): The AgnosticPitch object to compute the position for. Returns:     PositionInStaff: The PositionInStaff object representing the computed position.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def compute_position(self, pitch: AgnosticPitch) -&gt; PositionInStaff:\n    \"\"\"\n    Computes the position in staff for the given pitch.\n    Args:\n        pitch (AgnosticPitch): The AgnosticPitch object to compute the position for.\n    Returns:\n        PositionInStaff: The PositionInStaff object representing the computed position.\n    \"\"\"\n    # map A\u2013G to 0\u20136\n    LETTER_TO_INDEX = {'C': 0, 'D': 1, 'E': 2,\n                       'F': 3, 'G': 4, 'A': 5, 'B': 6}\n\n    # strip off any '+' or '-' accidentals, then grab the letter\n    def letter(p: AgnosticPitch) -&gt; str:\n        name = p.name.replace('+', '').replace('-', '')\n        return AgnosticPitch(name, p.octave).name\n\n    base_letter_idx = LETTER_TO_INDEX[letter(self.base_pitch)]\n    target_letter_idx = LETTER_TO_INDEX[letter(pitch)]\n\n    # \"octave difference \u00d7 7\" plus the letter\u2010index difference\n    diatonic_steps = (pitch.octave - self.base_pitch.octave) * 7 \\\n                     + (target_letter_idx - base_letter_idx)\n\n    # that many \"lines or spaces\" above (or below) the reference line\n    return PositionInStaff(diatonic_steps)\n</code></pre>"},{"location":"reference/#kernpy.PitchRest","title":"<code>PitchRest</code>","text":"<p>Represents a name or a rest in a note.</p> <p>The name is represented using the International Standard Organization (ISO) name notation. The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.</p> <p>The Humdrum Kern format uses the following name representation: 'c' = C4 'cc' = C5 'ccc' = C6 'cccc' = C7</p> <p>'C' = C3 'CC' = C2 'CCC' = C1</p> <p>The rests are represented by the letter 'r'. The rests do not have name.</p> <p>This class do not limit the name ranges.</p> <p>In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.</p> <pre><code>**kern\n*clefG2\n2c          // C4\n2cc         // C5\n2ccc        // C6\n2C          // C3\n2CC         // C2\n2CCC        // C1\n*-\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class PitchRest:\n    \"\"\"\n    Represents a name or a rest in a note.\n\n    The name is represented using the International Standard Organization (ISO) name notation.\n    The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.\n\n    The Humdrum Kern format uses the following name representation:\n    'c' = C4\n    'cc' = C5\n    'ccc' = C6\n    'cccc' = C7\n\n    'C' = C3\n    'CC' = C2\n    'CCC' = C1\n\n    The rests are represented by the letter 'r'. The rests do not have name.\n\n    This class do not limit the name ranges.\n\n\n    In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.\n    ```\n    **kern\n    *clefG2\n    2c          // C4\n    2cc         // C5\n    2ccc        // C6\n    2C          // C3\n    2CC         // C2\n    2CCC        // C1\n    *-\n    ```\n    \"\"\"\n    C4_PITCH_LOWERCASE = 'c'\n    C4_OCATAVE = 4\n    C3_PITCH_UPPERCASE = 'C'\n    C3_OCATAVE = 3\n    REST_CHARACTER = 'r'\n\n    VALID_PITCHES = 'abcdefg' + 'ABCDEFG' + REST_CHARACTER\n\n    def __init__(self, raw_pitch: str):\n        \"\"\"\n        Create a new PitchRest object.\n\n        Args:\n            raw_pitch (str): name representation in Humdrum Kern format\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest = PitchRest('DDD')\n        \"\"\"\n        if raw_pitch is None or len(raw_pitch) == 0:\n            raise ValueError(f'Empty name: name can not be None or empty. But {raw_pitch} was provided.')\n\n        self.encoding = raw_pitch\n        self.pitch, self.octave = self.__parse_pitch_octave()\n\n    def __parse_pitch_octave(self) -&gt; (str, int):\n        if self.encoding == PitchRest.REST_CHARACTER:\n            return PitchRest.REST_CHARACTER, None\n\n        if self.encoding.islower():\n            min_octave = PitchRest.C4_OCATAVE\n            octave = min_octave + (len(self.encoding) - 1)\n            pitch = self.encoding[0].lower()\n            return pitch, octave\n\n        if self.encoding.isupper():\n            max_octave = PitchRest.C3_OCATAVE\n            octave = max_octave - (len(self.encoding) - 1)\n            pitch = self.encoding[0].lower()\n            return pitch, octave\n\n        raise ValueError(f'Invalid name: name {self.encoding} is not a valid name representation.')\n\n    def is_rest(self) -&gt; bool:\n        \"\"\"\n        Check if the name is a rest.\n\n        Returns:\n            bool: True if the name is a rest, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest.is_rest()\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest.is_rest()\n            True\n        \"\"\"\n        return self.octave is None\n\n    @staticmethod\n    def pitch_comparator(pitch_a: str, pitch_b: str) -&gt; int:\n        \"\"\"\n        Compare two pitches of the same octave.\n\n        The lower name is 'a'. So 'a' &lt; 'b' &lt; 'c' &lt; 'd' &lt; 'e' &lt; 'f' &lt; 'g'\n\n        Args:\n            pitch_a: One name of 'abcdefg'\n            pitch_b: Another name of 'abcdefg'\n\n        Returns:\n            -1 if pitch1 is lower than pitch2\n            0 if pitch1 is equal to pitch2\n            1 if pitch1 is higher than pitch2\n\n        Examples:\n            &gt;&gt;&gt; PitchRest.pitch_comparator('c', 'c')\n            0\n            &gt;&gt;&gt; PitchRest.pitch_comparator('c', 'd')\n            -1\n            &gt;&gt;&gt; PitchRest.pitch_comparator('d', 'c')\n            1\n        \"\"\"\n        if pitch_a &lt; pitch_b:\n            return -1\n        if pitch_a &gt; pitch_b:\n            return 1\n        return 0\n\n    def __str__(self):\n        return f'{self.encoding}'\n\n    def __repr__(self):\n        return f'[PitchRest: {self.encoding}, name={self.pitch}, octave={self.octave}]'\n\n    def __eq__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches and rests.\n\n        Args:\n            other (PitchRest): The other name to compare\n\n        Returns (bool):\n            True if the pitches are equal, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest == pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n            &gt;&gt;&gt; pitch_rest == pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest == pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest == pitch_rest2\n            True\n\n        \"\"\"\n        if not isinstance(other, PitchRest):\n            return False\n        if self.is_rest() and other.is_rest():\n            return True\n        if self.is_rest() or other.is_rest():\n            return False\n        return self.pitch == other.pitch and self.octave == other.octave\n\n    def __ne__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches and rests.\n        Args:\n            other (PitchRest): The other name to compare\n\n        Returns (bool):\n            True if the pitches are different, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest != pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n            &gt;&gt;&gt; pitch_rest != pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest != pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest != pitch_rest2\n            False\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __gt__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches.\n\n        If any of the pitches is a rest, the comparison raise an exception.\n\n        Args:\n            other (PitchRest): The other name to compare\n\n        Returns (bool): True if this name is higher than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n            &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n            &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n            Traceback (most recent call last):\n            ValueError: ...\n\n\n        \"\"\"\n        if self.is_rest() or other.is_rest():\n            raise ValueError(f'Invalid comparison: &gt; operator can not be used to compare name of a rest.\\n\\\n            self={repr(self)} &gt; other={repr(other)}')\n\n        if self.octave &gt; other.octave:\n            return True\n        if self.octave == other.octave:\n            return PitchRest.pitch_comparator(self.pitch, other.pitch) &gt; 0\n        return False\n\n    def __lt__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches.\n\n        If any of the pitches is a rest, the comparison raise an exception.\n\n        Args:\n            other: The other name to compare\n\n        Returns:\n            True if this name is lower than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n            &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n            &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n\n        \"\"\"\n        if self.is_rest() or other.is_rest():\n            raise ValueError(f'Invalid comparison: &lt; operator can not be used to compare name of a rest.\\n\\\n            self={repr(self)} &lt; other={repr(other)}')\n\n        if self.octave &lt; other.octave:\n            return True\n        if self.octave == other.octave:\n            return PitchRest.pitch_comparator(self.pitch, other.pitch) &lt; 0\n        return False\n\n    def __ge__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception.\n        Args:\n            other (PitchRest): The other name to compare\n\n        Returns (bool):\n            True if this name is higher or equal than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n            &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n            &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n\n\n        \"\"\"\n        return self.__gt__(other) or self.__eq__(other)\n\n    def __le__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception.\n        Args:\n            other (PitchRest): The other name to compare\n\n        Returns (bool): True if this name is lower or equal than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n            &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n            &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n\n        \"\"\"\n        return self.__lt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two pitches and rests.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PitchRest</code> <p>The other name to compare</p> required <p>Returns (bool):     True if the pitches are equal, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nTrue\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __eq__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches and rests.\n\n    Args:\n        other (PitchRest): The other name to compare\n\n    Returns (bool):\n        True if the pitches are equal, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest == pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n        &gt;&gt;&gt; pitch_rest == pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest == pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest == pitch_rest2\n        True\n\n    \"\"\"\n    if not isinstance(other, PitchRest):\n        return False\n    if self.is_rest() and other.is_rest():\n        return True\n    if self.is_rest() or other.is_rest():\n        return False\n    return self.pitch == other.pitch and self.octave == other.octave\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool):     True if this name is higher or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ge__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception.\n    Args:\n        other (PitchRest): The other name to compare\n\n    Returns (bool):\n        True if this name is higher or equal than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n        &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n        &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n\n    \"\"\"\n    return self.__gt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Compare two pitches.</p> <p>If any of the pitches is a rest, the comparison raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PitchRest</code> <p>The other name to compare</p> required <p>Returns (bool): True if this name is higher than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTraceback (most recent call last):\nValueError: ...\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __gt__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches.\n\n    If any of the pitches is a rest, the comparison raise an exception.\n\n    Args:\n        other (PitchRest): The other name to compare\n\n    Returns (bool): True if this name is higher than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n        &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n        &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n        Traceback (most recent call last):\n        ValueError: ...\n\n\n    \"\"\"\n    if self.is_rest() or other.is_rest():\n        raise ValueError(f'Invalid comparison: &gt; operator can not be used to compare name of a rest.\\n\\\n        self={repr(self)} &gt; other={repr(other)}')\n\n    if self.octave &gt; other.octave:\n        return True\n    if self.octave == other.octave:\n        return PitchRest.pitch_comparator(self.pitch, other.pitch) &gt; 0\n    return False\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__init__","title":"<code>__init__(raw_pitch)</code>","text":"<p>Create a new PitchRest object.</p> <p>Parameters:</p> Name Type Description Default <code>raw_pitch</code> <code>str</code> <p>name representation in Humdrum Kern format</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest = PitchRest('DDD')\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, raw_pitch: str):\n    \"\"\"\n    Create a new PitchRest object.\n\n    Args:\n        raw_pitch (str): name representation in Humdrum Kern format\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest = PitchRest('DDD')\n    \"\"\"\n    if raw_pitch is None or len(raw_pitch) == 0:\n        raise ValueError(f'Empty name: name can not be None or empty. But {raw_pitch} was provided.')\n\n    self.encoding = raw_pitch\n    self.pitch, self.octave = self.__parse_pitch_octave()\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__le__","title":"<code>__le__(other)</code>","text":"<p>Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool): True if this name is lower or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __le__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception.\n    Args:\n        other (PitchRest): The other name to compare\n\n    Returns (bool): True if this name is lower or equal than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n        &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n        &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n    \"\"\"\n    return self.__lt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two pitches.</p> <p>If any of the pitches is a rest, the comparison raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'PitchRest'</code> <p>The other name to compare</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this name is lower than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __lt__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches.\n\n    If any of the pitches is a rest, the comparison raise an exception.\n\n    Args:\n        other: The other name to compare\n\n    Returns:\n        True if this name is lower than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n        &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n        &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n    \"\"\"\n    if self.is_rest() or other.is_rest():\n        raise ValueError(f'Invalid comparison: &lt; operator can not be used to compare name of a rest.\\n\\\n        self={repr(self)} &lt; other={repr(other)}')\n\n    if self.octave &lt; other.octave:\n        return True\n    if self.octave == other.octave:\n        return PitchRest.pitch_comparator(self.pitch, other.pitch) &lt; 0\n    return False\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two pitches and rests. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool):     True if the pitches are different, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ne__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches and rests.\n    Args:\n        other (PitchRest): The other name to compare\n\n    Returns (bool):\n        True if the pitches are different, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest != pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n        &gt;&gt;&gt; pitch_rest != pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest != pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest != pitch_rest2\n        False\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.is_rest","title":"<code>is_rest()</code>","text":"<p>Check if the name is a rest.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the name is a rest, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest.is_rest()\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest.is_rest()\nTrue\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def is_rest(self) -&gt; bool:\n    \"\"\"\n    Check if the name is a rest.\n\n    Returns:\n        bool: True if the name is a rest, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest.is_rest()\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest.is_rest()\n        True\n    \"\"\"\n    return self.octave is None\n</code></pre>"},{"location":"reference/#kernpy.PitchRest.pitch_comparator","title":"<code>pitch_comparator(pitch_a, pitch_b)</code>  <code>staticmethod</code>","text":"<p>Compare two pitches of the same octave.</p> <p>The lower name is 'a'. So 'a' &lt; 'b' &lt; 'c' &lt; 'd' &lt; 'e' &lt; 'f' &lt; 'g'</p> <p>Parameters:</p> Name Type Description Default <code>pitch_a</code> <code>str</code> <p>One name of 'abcdefg'</p> required <code>pitch_b</code> <code>str</code> <p>Another name of 'abcdefg'</p> required <p>Returns:</p> Type Description <code>int</code> <p>-1 if pitch1 is lower than pitch2</p> <code>int</code> <p>0 if pitch1 is equal to pitch2</p> <code>int</code> <p>1 if pitch1 is higher than pitch2</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PitchRest.pitch_comparator('c', 'c')\n0\n&gt;&gt;&gt; PitchRest.pitch_comparator('c', 'd')\n-1\n&gt;&gt;&gt; PitchRest.pitch_comparator('d', 'c')\n1\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@staticmethod\ndef pitch_comparator(pitch_a: str, pitch_b: str) -&gt; int:\n    \"\"\"\n    Compare two pitches of the same octave.\n\n    The lower name is 'a'. So 'a' &lt; 'b' &lt; 'c' &lt; 'd' &lt; 'e' &lt; 'f' &lt; 'g'\n\n    Args:\n        pitch_a: One name of 'abcdefg'\n        pitch_b: Another name of 'abcdefg'\n\n    Returns:\n        -1 if pitch1 is lower than pitch2\n        0 if pitch1 is equal to pitch2\n        1 if pitch1 is higher than pitch2\n\n    Examples:\n        &gt;&gt;&gt; PitchRest.pitch_comparator('c', 'c')\n        0\n        &gt;&gt;&gt; PitchRest.pitch_comparator('c', 'd')\n        -1\n        &gt;&gt;&gt; PitchRest.pitch_comparator('d', 'c')\n        1\n    \"\"\"\n    if pitch_a &lt; pitch_b:\n        return -1\n    if pitch_a &gt; pitch_b:\n        return 1\n    return 0\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff","title":"<code>PositionInStaff</code>","text":"Source code in <code>kernpy/core/gkern.py</code> <pre><code>class PositionInStaff:\n    LINE_CHARACTER = 'L'\n    SPACE_CHARACTER = 'S'\n\n    def __init__(self, line_space: int):\n        \"\"\"\n        Initializes the PositionInStaff object.\n\n        Args:\n            line_space (int): 0 for bottom line, -1 for space under bottom line, 1 for space above bottom line. \\\n             Increments by 1 for each line or space.\n\n        \"\"\"\n        self.line_space = line_space\n\n    @classmethod\n    def from_line(cls, line: int) -&gt; PositionInStaff:\n        \"\"\"\n        Creates a PositionInStaff object from a line number.\n\n        Args:\n            line (int): The line number. line 1 is bottom line, 2 is the 1st line from bottom, 0 is the bottom ledger line\n\n        Returns:\n            PositionInStaff: The PositionInStaff object. 0 for the bottom line, 2 for the 1st line from bottom, -1 for the bottom ledger line, etc.\n        \"\"\"\n        return cls((line - 1) * 2)\n\n    @classmethod\n    def from_space(cls, space: int) -&gt; PositionInStaff:\n        \"\"\"\n        Creates a PositionInStaff object from a space number.\n\n        Args:\n            space (int): The space number. space 1 is bottom space, 2\n\n        Returns:\n            PositionInStaff: The PositionInStaff object.\n        \"\"\"\n        return cls((space) * 2 - 1)\n\n    @classmethod\n    def from_encoded(cls, encoded: str) -&gt; PositionInStaff:\n        \"\"\"\n        Creates a PositionInStaff object from an encoded string.\n\n        Args:\n            encoded (str): The encoded string.\n\n        Returns:\n            PositionInStaff: The PositionInStaff object.\n        \"\"\"\n        if encoded.startswith(cls.LINE_CHARACTER):\n            line = int(encoded[1:])  # Extract the line number\n            return cls.from_line(line)\n        elif encoded.startswith(cls.SPACE_CHARACTER):\n            space = int(encoded[1:])  # Extract the space number\n            return cls.from_space(space)\n        else:\n            raise ValueError(f\"\"\n                             f\"Invalid encoded string: {encoded}. \"\n                             f\"Expected to start with '{cls.LINE_CHARACTER}' or '{cls.SPACE_CHARACTER} at the beginning.\")\n\n\n    def line(self):\n        \"\"\"\n        Returns the line number of the position in staff.\n        \"\"\"\n        return self.line_space // 2 + 1\n\n\n    def space(self):\n        \"\"\"\n        Returns the space number of the position in staff.\n        \"\"\"\n        return (self.line_space - 1) // 2 + 1\n\n\n    def is_line(self) -&gt; bool:\n        \"\"\"\n        Returns True if the position is a line, False otherwise. If is not a line, it is a space, and vice versa.\n        \"\"\"\n        return self.line_space % 2 == 0\n\n    def move(self, line_space_difference: int) -&gt; PositionInStaff:\n        \"\"\"\n        Returns a new PositionInStaff object with the position moved by the given number of lines or spaces.\n\n        Args:\n            line_space_difference (int): The number of lines or spaces to move.\n\n        Returns:\n            PositionInStaff: The new PositionInStaff object.\n        \"\"\"\n        return PositionInStaff(self.line_space + line_space_difference)\n\n    def position_below(self) -&gt; PositionInStaff:\n        \"\"\"\n        Returns the position below the current position.\n        \"\"\"\n        return self.move(-2)\n\n    def position_above(self) -&gt; PositionInStaff:\n        \"\"\"\n        Returns the position above the current position.\n        \"\"\"\n        return self.move(2)\n\n\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns the string representation of the position in staff.\n        \"\"\"\n        if self.is_line():\n            return f\"{self.LINE_CHARACTER}{int(self.line())}\"\n        else:\n            return f\"{self.SPACE_CHARACTER}{int(self.space())}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns the string representation of the PositionInStaff object.\n        \"\"\"\n        return f\"PositionInStaff(line_space={self.line_space}), {self.__str__()}\"\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        Compares two PositionInStaff objects.\n        \"\"\"\n        if not isinstance(other, PositionInStaff):\n            return False\n        return self.line_space == other.line_space\n\n    def __ne__(self, other) -&gt; bool:\n        \"\"\"\n        Compares two PositionInStaff objects.\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Returns the hash of the PositionInStaff object.\n        \"\"\"\n        return hash(self.line_space)\n\n    def __lt__(self, other) -&gt; bool:\n        \"\"\"\n        Compares two PositionInStaff objects.\n        \"\"\"\n        if not isinstance(other, PositionInStaff):\n            return NotImplemented\n        return self.line_space &lt; other.line_space\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Compares two PositionInStaff objects.\n    \"\"\"\n    if not isinstance(other, PositionInStaff):\n        return False\n    return self.line_space == other.line_space\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the PositionInStaff object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Returns the hash of the PositionInStaff object.\n    \"\"\"\n    return hash(self.line_space)\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.__init__","title":"<code>__init__(line_space)</code>","text":"<p>Initializes the PositionInStaff object.</p> <p>Parameters:</p> Name Type Description Default <code>line_space</code> <code>int</code> <p>0 for bottom line, -1 for space under bottom line, 1 for space above bottom line.              Increments by 1 for each line or space.</p> required Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self, line_space: int):\n    \"\"\"\n    Initializes the PositionInStaff object.\n\n    Args:\n        line_space (int): 0 for bottom line, -1 for space under bottom line, 1 for space above bottom line. \\\n         Increments by 1 for each line or space.\n\n    \"\"\"\n    self.line_space = line_space\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __lt__(self, other) -&gt; bool:\n    \"\"\"\n    Compares two PositionInStaff objects.\n    \"\"\"\n    if not isinstance(other, PositionInStaff):\n        return NotImplemented\n    return self.line_space &lt; other.line_space\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __ne__(self, other) -&gt; bool:\n    \"\"\"\n    Compares two PositionInStaff objects.\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the PositionInStaff object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns the string representation of the PositionInStaff object.\n    \"\"\"\n    return f\"PositionInStaff(line_space={self.line_space}), {self.__str__()}\"\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the position in staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns the string representation of the position in staff.\n    \"\"\"\n    if self.is_line():\n        return f\"{self.LINE_CHARACTER}{int(self.line())}\"\n    else:\n        return f\"{self.SPACE_CHARACTER}{int(self.space())}\"\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.from_encoded","title":"<code>from_encoded(encoded)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from an encoded string.</p> <p>Parameters:</p> Name Type Description Default <code>encoded</code> <code>str</code> <p>The encoded string.</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>@classmethod\ndef from_encoded(cls, encoded: str) -&gt; PositionInStaff:\n    \"\"\"\n    Creates a PositionInStaff object from an encoded string.\n\n    Args:\n        encoded (str): The encoded string.\n\n    Returns:\n        PositionInStaff: The PositionInStaff object.\n    \"\"\"\n    if encoded.startswith(cls.LINE_CHARACTER):\n        line = int(encoded[1:])  # Extract the line number\n        return cls.from_line(line)\n    elif encoded.startswith(cls.SPACE_CHARACTER):\n        space = int(encoded[1:])  # Extract the space number\n        return cls.from_space(space)\n    else:\n        raise ValueError(f\"\"\n                         f\"Invalid encoded string: {encoded}. \"\n                         f\"Expected to start with '{cls.LINE_CHARACTER}' or '{cls.SPACE_CHARACTER} at the beginning.\")\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.from_line","title":"<code>from_line(line)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from a line number.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line number. line 1 is bottom line, 2 is the 1st line from bottom, 0 is the bottom ledger line</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object. 0 for the bottom line, 2 for the 1st line from bottom, -1 for the bottom ledger line, etc.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>@classmethod\ndef from_line(cls, line: int) -&gt; PositionInStaff:\n    \"\"\"\n    Creates a PositionInStaff object from a line number.\n\n    Args:\n        line (int): The line number. line 1 is bottom line, 2 is the 1st line from bottom, 0 is the bottom ledger line\n\n    Returns:\n        PositionInStaff: The PositionInStaff object. 0 for the bottom line, 2 for the 1st line from bottom, -1 for the bottom ledger line, etc.\n    \"\"\"\n    return cls((line - 1) * 2)\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.from_space","title":"<code>from_space(space)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from a space number.</p> <p>Parameters:</p> Name Type Description Default <code>space</code> <code>int</code> <p>The space number. space 1 is bottom space, 2</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>@classmethod\ndef from_space(cls, space: int) -&gt; PositionInStaff:\n    \"\"\"\n    Creates a PositionInStaff object from a space number.\n\n    Args:\n        space (int): The space number. space 1 is bottom space, 2\n\n    Returns:\n        PositionInStaff: The PositionInStaff object.\n    \"\"\"\n    return cls((space) * 2 - 1)\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.is_line","title":"<code>is_line()</code>","text":"<p>Returns True if the position is a line, False otherwise. If is not a line, it is a space, and vice versa.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def is_line(self) -&gt; bool:\n    \"\"\"\n    Returns True if the position is a line, False otherwise. If is not a line, it is a space, and vice versa.\n    \"\"\"\n    return self.line_space % 2 == 0\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.line","title":"<code>line()</code>","text":"<p>Returns the line number of the position in staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def line(self):\n    \"\"\"\n    Returns the line number of the position in staff.\n    \"\"\"\n    return self.line_space // 2 + 1\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.move","title":"<code>move(line_space_difference)</code>","text":"<p>Returns a new PositionInStaff object with the position moved by the given number of lines or spaces.</p> <p>Parameters:</p> Name Type Description Default <code>line_space_difference</code> <code>int</code> <p>The number of lines or spaces to move.</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The new PositionInStaff object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def move(self, line_space_difference: int) -&gt; PositionInStaff:\n    \"\"\"\n    Returns a new PositionInStaff object with the position moved by the given number of lines or spaces.\n\n    Args:\n        line_space_difference (int): The number of lines or spaces to move.\n\n    Returns:\n        PositionInStaff: The new PositionInStaff object.\n    \"\"\"\n    return PositionInStaff(self.line_space + line_space_difference)\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.position_above","title":"<code>position_above()</code>","text":"<p>Returns the position above the current position.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def position_above(self) -&gt; PositionInStaff:\n    \"\"\"\n    Returns the position above the current position.\n    \"\"\"\n    return self.move(2)\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.position_below","title":"<code>position_below()</code>","text":"<p>Returns the position below the current position.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def position_below(self) -&gt; PositionInStaff:\n    \"\"\"\n    Returns the position below the current position.\n    \"\"\"\n    return self.move(-2)\n</code></pre>"},{"location":"reference/#kernpy.PositionInStaff.space","title":"<code>space()</code>","text":"<p>Returns the space number of the position in staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def space(self):\n    \"\"\"\n    Returns the space number of the position in staff.\n    \"\"\"\n    return (self.line_space - 1) // 2 + 1\n</code></pre>"},{"location":"reference/#kernpy.RootSpineImporter","title":"<code>RootSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/root_spine_importer.py</code> <pre><code>class RootSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        #return RootSpineListener() # TODO: Create a custom functional listener for RootSpineImporter\n        return KernSpineListener()\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        return token  # The **root spine tokens are always a subset of the **kern spine tokens\n</code></pre>"},{"location":"reference/#kernpy.RootSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/root_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.SimpleToken","title":"<code>SimpleToken</code>","text":"<p>               Bases: <code>Token</code></p> <p>SimpleToken class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class SimpleToken(Token):\n    \"\"\"\n    SimpleToken class.\n    \"\"\"\n\n    def __init__(self, encoding, category):\n        super().__init__(encoding, category)\n\n    def export(self, **kwargs) -&gt; str:\n        \"\"\"\n        Exports the token.\n\n        Args:\n            **kwargs: 'filter_categories' (Optional[Callable[[TokenCategory], bool]]): It is ignored in this class.\n\n        Returns (str): The encoded token representation.\n        \"\"\"\n        return self.encoding\n</code></pre>"},{"location":"reference/#kernpy.SimpleToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>'filter_categories' (Optional[Callable[[TokenCategory], bool]]): It is ignored in this class.</p> <code>{}</code> <p>Returns (str): The encoded token representation.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def export(self, **kwargs) -&gt; str:\n    \"\"\"\n    Exports the token.\n\n    Args:\n        **kwargs: 'filter_categories' (Optional[Callable[[TokenCategory], bool]]): It is ignored in this class.\n\n    Returns (str): The encoded token representation.\n    \"\"\"\n    return self.encoding\n</code></pre>"},{"location":"reference/#kernpy.SpineOperationToken","title":"<code>SpineOperationToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>SpineOperationToken class.</p> <p>This token represents different operations in the Humdrum kern encoding. These are the available operations:     - <code>*-</code>:  spine-path terminator.     - <code>*</code>: null interpretation.     - <code>*+</code>: add spines.     - <code>*^</code>: split spines.     - <code>*x</code>: exchange spines.</p> <p>Attributes:</p> Name Type Description <code>cancelled_at_stage</code> <code>int</code> <p>The stage at which the operation was cancelled. Defaults to None.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class SpineOperationToken(SimpleToken):\n    \"\"\"\n    SpineOperationToken class.\n\n    This token represents different operations in the Humdrum kern encoding.\n    These are the available operations:\n        - `*-`:  spine-path terminator.\n        - `*`: null interpretation.\n        - `*+`: add spines.\n        - `*^`: split spines.\n        - `*x`: exchange spines.\n\n    Attributes:\n        cancelled_at_stage (int): The stage at which the operation was cancelled. Defaults to None.\n    \"\"\"\n\n    def __init__(self, encoding):\n        super().__init__(encoding, TokenCategory.SPINE_OPERATION)\n        self.cancelled_at_stage = None\n\n    def is_cancelled_at(self, stage) -&gt; bool:\n        \"\"\"\n        Checks if the operation was cancelled at the given stage.\n\n        Args:\n            stage (int): The stage at which the operation was cancelled.\n\n        Returns:\n            bool: True if the operation was cancelled at the given stage, False otherwise.\n        \"\"\"\n        if self.cancelled_at_stage is None:\n            return False\n        else:\n            return self.cancelled_at_stage &lt; stage\n</code></pre>"},{"location":"reference/#kernpy.SpineOperationToken.is_cancelled_at","title":"<code>is_cancelled_at(stage)</code>","text":"<p>Checks if the operation was cancelled at the given stage.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>int</code> <p>The stage at which the operation was cancelled.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the operation was cancelled at the given stage, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def is_cancelled_at(self, stage) -&gt; bool:\n    \"\"\"\n    Checks if the operation was cancelled at the given stage.\n\n    Args:\n        stage (int): The stage at which the operation was cancelled.\n\n    Returns:\n        bool: True if the operation was cancelled at the given stage, False otherwise.\n    \"\"\"\n    if self.cancelled_at_stage is None:\n        return False\n    else:\n        return self.cancelled_at_stage &lt; stage\n</code></pre>"},{"location":"reference/#kernpy.StoreCache","title":"<code>StoreCache</code>","text":"<p>A simple cache that stores the result of a callback function</p> Source code in <code>kernpy/util/store_cache.py</code> <pre><code>class StoreCache:\n    \"\"\"\n    A simple cache that stores the result of a callback function\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.memory = {}\n\n    def request(self, callback, request):\n        \"\"\"\n        Request a value from the cache. If the value is not in the cache, it will be calculated by the callback function\n        Args:\n            callback (function): The callback function that will be called to calculate the value\n            request (any): The request that will be passed to the callback function\n\n        Returns (any): The value that was requested\n\n        Examples:\n            &gt;&gt;&gt; def add_five(x):\n            ...     return x + 5\n            &gt;&gt;&gt; store_cache = StoreCache()\n            &gt;&gt;&gt; store_cache.request(callback, 5)  # Call the callback function\n            10\n            &gt;&gt;&gt; store_cache.request(callback, 5)  # Return the value from the cache, without calling the callback function\n            10\n        \"\"\"\n        if request in self.memory:\n            return self.memory[request]\n        else:\n            result = callback(request)\n            self.memory[request] = result\n            return result\n</code></pre>"},{"location":"reference/#kernpy.StoreCache.__init__","title":"<code>__init__()</code>","text":"<p>Constructor</p> Source code in <code>kernpy/util/store_cache.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.memory = {}\n</code></pre>"},{"location":"reference/#kernpy.StoreCache.request","title":"<code>request(callback, request)</code>","text":"<p>Request a value from the cache. If the value is not in the cache, it will be calculated by the callback function Args:     callback (function): The callback function that will be called to calculate the value     request (any): The request that will be passed to the callback function</p> <p>Returns (any): The value that was requested</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def add_five(x):\n...     return x + 5\n&gt;&gt;&gt; store_cache = StoreCache()\n&gt;&gt;&gt; store_cache.request(callback, 5)  # Call the callback function\n10\n&gt;&gt;&gt; store_cache.request(callback, 5)  # Return the value from the cache, without calling the callback function\n10\n</code></pre> Source code in <code>kernpy/util/store_cache.py</code> <pre><code>def request(self, callback, request):\n    \"\"\"\n    Request a value from the cache. If the value is not in the cache, it will be calculated by the callback function\n    Args:\n        callback (function): The callback function that will be called to calculate the value\n        request (any): The request that will be passed to the callback function\n\n    Returns (any): The value that was requested\n\n    Examples:\n        &gt;&gt;&gt; def add_five(x):\n        ...     return x + 5\n        &gt;&gt;&gt; store_cache = StoreCache()\n        &gt;&gt;&gt; store_cache.request(callback, 5)  # Call the callback function\n        10\n        &gt;&gt;&gt; store_cache.request(callback, 5)  # Return the value from the cache, without calling the callback function\n        10\n    \"\"\"\n    if request in self.memory:\n        return self.memory[request]\n    else:\n        result = callback(request)\n        self.memory[request] = result\n        return result\n</code></pre>"},{"location":"reference/#kernpy.Subtoken","title":"<code>Subtoken</code>","text":"<p>Subtoken class. Thhe subtokens are the smallest units of categories. ComplexToken objects are composed of subtokens.</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <p>The complete unprocessed encoding</p> <code>category</code> <p>The subtoken category, one of SubTokenCategory</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class Subtoken:\n    \"\"\"\n    Subtoken class. Thhe subtokens are the smallest units of categories. ComplexToken objects are composed of subtokens.\n\n    Attributes:\n        encoding: The complete unprocessed encoding\n        category: The subtoken category, one of SubTokenCategory\n    \"\"\"\n    DECORATION = None\n\n    def __init__(self, encoding: str, category: TokenCategory):\n        \"\"\"\n        Subtoken constructor\n\n        Args:\n            encoding (str): The complete unprocessed encoding\n            category (TokenCategory): The subtoken category. \\\n                It should be a child of the main 'TokenCategory' in the hierarchy.\n\n        \"\"\"\n        self.encoding = encoding\n        self.category = category\n\n    def __str__(self):\n        \"\"\"\n        Returns the string representation of the subtoken.\n\n        Returns (str): The string representation of the subtoken.\n        \"\"\"\n        return self.encoding\n\n    def __eq__(self, other):\n        \"\"\"\n        Compare two subtokens.\n\n        Args:\n            other (Subtoken): The other subtoken to compare.\n        Returns (bool): True if the subtokens are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, Subtoken):\n            return False\n        return self.encoding == other.encoding and self.category == other.category\n\n    def __ne__(self, other):\n        \"\"\"\n        Compare two subtokens.\n\n        Args:\n            other (Subtoken): The other subtoken to compare.\n        Returns (bool): True if the subtokens are different, False otherwise.\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        \"\"\"\n        Returns the hash of the subtoken.\n\n        Returns (int): The hash of the subtoken.\n        \"\"\"\n        return hash((self.encoding, self.category))\n</code></pre>"},{"location":"reference/#kernpy.Subtoken.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two subtokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Subtoken</code> <p>The other subtoken to compare.</p> required <p>Returns (bool): True if the subtokens are equal, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compare two subtokens.\n\n    Args:\n        other (Subtoken): The other subtoken to compare.\n    Returns (bool): True if the subtokens are equal, False otherwise.\n    \"\"\"\n    if not isinstance(other, Subtoken):\n        return False\n    return self.encoding == other.encoding and self.category == other.category\n</code></pre>"},{"location":"reference/#kernpy.Subtoken.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the subtoken.</p> <p>Returns (int): The hash of the subtoken.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Returns the hash of the subtoken.\n\n    Returns (int): The hash of the subtoken.\n    \"\"\"\n    return hash((self.encoding, self.category))\n</code></pre>"},{"location":"reference/#kernpy.Subtoken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>Subtoken constructor</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>category</code> <code>TokenCategory</code> <p>The subtoken category.                 It should be a child of the main 'TokenCategory' in the hierarchy.</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding: str, category: TokenCategory):\n    \"\"\"\n    Subtoken constructor\n\n    Args:\n        encoding (str): The complete unprocessed encoding\n        category (TokenCategory): The subtoken category. \\\n            It should be a child of the main 'TokenCategory' in the hierarchy.\n\n    \"\"\"\n    self.encoding = encoding\n    self.category = category\n</code></pre>"},{"location":"reference/#kernpy.Subtoken.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two subtokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Subtoken</code> <p>The other subtoken to compare.</p> required <p>Returns (bool): True if the subtokens are different, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ne__(self, other):\n    \"\"\"\n    Compare two subtokens.\n\n    Args:\n        other (Subtoken): The other subtoken to compare.\n    Returns (bool): True if the subtokens are different, False otherwise.\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.Subtoken.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the subtoken.</p> <p>Returns (str): The string representation of the subtoken.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Returns the string representation of the subtoken.\n\n    Returns (str): The string representation of the subtoken.\n    \"\"\"\n    return self.encoding\n</code></pre>"},{"location":"reference/#kernpy.TextSpineImporter","title":"<code>TextSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/text_spine_importer.py</code> <pre><code>class TextSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()  # TODO: Create a custom functional listener for TextSpineImporter\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.BARLINES,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if not any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.LYRICS)\n\n        return token\n</code></pre>"},{"location":"reference/#kernpy.TextSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/text_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.Token","title":"<code>Token</code>","text":"<p>               Bases: <code>AbstractToken</code>, <code>ABC</code></p> <p>Abstract Token class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class Token(AbstractToken, ABC):\n    \"\"\"\n    Abstract Token class.\n    \"\"\"\n\n    def __init__(self, encoding, category):\n        super().__init__(encoding, category)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory","title":"<code>TokenCategory</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Options for the category of a token.</p> <p>This is used to determine what kind of token should be exported.</p> <p>The categories are sorted the specific order they are compared to sorthem. But hierarchical order must be defined in other data structures.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class TokenCategory(Enum):\n    \"\"\"\n    Options for the category of a token.\n\n    This is used to determine what kind of token should be exported.\n\n    The categories are sorted the specific order they are compared to sorthem. But hierarchical order must be defined in other data structures.\n    \"\"\"\n    STRUCTURAL = auto()  # header, spine operations\n    HEADER = auto()  # **kern, **mens, **text, **harm, **mxhm, **root, **dyn, **dynam, **fing\n    SPINE_OPERATION = auto()\n    CORE = auto() # notes, rests, chords, etc.\n    ERROR = auto()\n    NOTE_REST = auto()\n    NOTE = auto()\n    DURATION = auto()\n    PITCH = auto()\n    ALTERATION = auto()\n    DECORATION = auto()\n    REST = auto()\n    CHORD = auto()\n    EMPTY = auto()  # placeholders, null interpretation\n    SIGNATURES = auto()\n    CLEF = auto()\n    TIME_SIGNATURE = auto()\n    METER_SYMBOL = auto()\n    KEY_SIGNATURE = auto()\n    KEY_TOKEN = auto()\n    ENGRAVED_SYMBOLS = auto()\n    OTHER_CONTEXTUAL = auto()\n    BARLINES = auto()\n    COMMENTS = auto()\n    FIELD_COMMENTS = auto()\n    LINE_COMMENTS = auto()\n    DYNAMICS = auto()\n    HARMONY = auto()\n    FINGERING = auto()\n    LYRICS = auto()\n    INSTRUMENTS = auto()\n    IMAGE_ANNOTATIONS = auto()\n    BOUNDING_BOXES = auto()\n    LINE_BREAK = auto()\n    OTHER = auto()\n    MHXM = auto()\n    ROOT = auto()\n\n    def __lt__(self, other):\n        \"\"\"\n        Compare two TokenCategory.\n        Args:\n            other (TokenCategory): The other category to compare.\n\n        Returns (bool): True if this category is lower than the other, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.CORE\n            True\n            &gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.STRUCTURAL\n            False\n            &gt;&gt;&gt; TokenCategory.CORE &lt; TokenCategory.STRUCTURAL\n            False\n            &gt;&gt;&gt; sorted([TokenCategory.STRUCTURAL, TokenCategory.CORE])\n            [TokenCategory.STRUCTURAL, TokenCategory.CORE]\n        \"\"\"\n        if isinstance(other, TokenCategory):\n            return self.value &lt; other.value\n        return NotImplemented\n\n    @classmethod\n    def all(cls) -&gt; Set[TokenCategory]:\n        f\"\"\"\n        Get all categories in the hierarchy.\n\n        Returns:\n            Set[TokenCategory]: The set of all categories in the hierarchy.\n\n        Examples:\n            &gt;&gt;&gt; import kernpy as kp\n            &gt;&gt;&gt; kp.TokenCategory.all()\n            set([&lt;TokenCategory.MHXM: 29&gt;, &lt;TokenCategory.COMMENTS: 19&gt;, &lt;TokenCategory.BARLINES: 18&gt;, &lt;TokenCategory.CORE: 2&gt;, &lt;TokenCategory.BOUNDING_BOXES: 27&gt;, &lt;TokenCategory.NOTE_REST: 3&gt;, &lt;TokenCategory.NOTE: 4&gt;, &lt;TokenCategory.ENGRAVED_SYMBOLS: 16&gt;, &lt;TokenCategory.SIGNATURES: 11&gt;, &lt;TokenCategory.REST: 8&gt;, &lt;TokenCategory.METER_SYMBOL: 14&gt;, &lt;TokenCategory.HARMONY: 23&gt;, &lt;TokenCategory.KEY_SIGNATURE: 15&gt;, &lt;TokenCategory.EMPTY: 10&gt;, &lt;TokenCategory.PITCH: 6&gt;, &lt;TokenCategory.LINE_COMMENTS: 21&gt;, &lt;TokenCategory.FINGERING: 24&gt;, &lt;TokenCategory.DECORATION: 7&gt;, &lt;TokenCategory.OTHER: 28&gt;, &lt;TokenCategory.INSTRUMENTS: 26&gt;, &lt;TokenCategory.STRUCTURAL: 1&gt;, &lt;TokenCategory.FIELD_COMMENTS: 20&gt;, &lt;TokenCategory.LYRICS: 25&gt;, &lt;TokenCategory.CLEF: 12&gt;, &lt;TokenCategory.DURATION: 5&gt;, &lt;TokenCategory.DYNAMICS: 22&gt;, &lt;TokenCategory.CHORD: 9&gt;, &lt;TokenCategory.TIME_SIGNATURE: 13&gt;, &lt;TokenCategory.OTHER_CONTEXTUAL: 17&gt;])\n        \"\"\"\n        return set([t for t in TokenCategory])\n\n    @classmethod\n    def tree(cls):\n        \"\"\"\n        Return a string representation of the category hierarchy\n        Returns (str): The string representation of the category hierarchy\n\n        Examples:\n            &gt;&gt;&gt; import kernpy as kp\n            &gt;&gt;&gt; print(kp.TokenCategory.tree())\n            .\n            \u251c\u2500\u2500 TokenCategory.STRUCTURAL\n            \u251c\u2500\u2500 TokenCategory.CORE\n            \u2502   \u251c\u2500\u2500 TokenCategory.NOTE_REST\n            \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.DURATION\n            \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.NOTE\n            \u2502   \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.PITCH\n            \u2502   \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.DECORATION\n            \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.REST\n            \u2502   \u251c\u2500\u2500 TokenCategory.CHORD\n            \u2502   \u2514\u2500\u2500 TokenCategory.EMPTY\n            \u251c\u2500\u2500 TokenCategory.SIGNATURES\n            \u2502   \u251c\u2500\u2500 TokenCategory.CLEF\n            \u2502   \u251c\u2500\u2500 TokenCategory.TIME_SIGNATURE\n            \u2502   \u251c\u2500\u2500 TokenCategory.METER_SYMBOL\n            \u2502   \u2514\u2500\u2500 TokenCategory.KEY_SIGNATURE\n            \u251c\u2500\u2500 TokenCategory.ENGRAVED_SYMBOLS\n            \u251c\u2500\u2500 TokenCategory.OTHER_CONTEXTUAL\n            \u251c\u2500\u2500 TokenCategory.BARLINES\n            \u251c\u2500\u2500 TokenCategory.COMMENTS\n            \u2502   \u251c\u2500\u2500 TokenCategory.FIELD_COMMENTS\n            \u2502   \u2514\u2500\u2500 TokenCategory.LINE_COMMENTS\n            \u251c\u2500\u2500 TokenCategory.DYNAMICS\n            \u251c\u2500\u2500 TokenCategory.HARMONY\n            \u251c\u2500\u2500 TokenCategory.FINGERING\n            \u251c\u2500\u2500 TokenCategory.LYRICS\n            \u251c\u2500\u2500 TokenCategory.INSTRUMENTS\n            \u251c\u2500\u2500 TokenCategory.BOUNDING_BOXES\n            \u2514\u2500\u2500 TokenCategory.OTHER\n        \"\"\"\n        return TokenCategoryHierarchyMapper.tree()\n\n    @classmethod\n    def is_child(cls, *, child: TokenCategory, parent: TokenCategory) -&gt; bool:\n        \"\"\"\n        Check if the child category is a child of the parent category.\n\n        Args:\n            child (TokenCategory): The child category.\n            parent (TokenCategory): The parent category.\n\n        Returns (bool): True if the child category is a child of the parent category, False otherwise.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.is_child(parent=parent, child=child)\n\n    @classmethod\n    def children(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the children of the target category.\n\n        Args:\n            target (TokenCategory): The target category.\n\n        Returns (List[TokenCategory]): The list of child categories of the target category.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.children(parent=target)\n\n    @classmethod\n    def valid(cls, *, include: Optional[Set[TokenCategory]] = None, exclude: Optional[Set[TokenCategory]] = None) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the valid categories based on the include and exclude sets.\n\n        Args:\n            include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n                If None, all categories are included.\n            exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n                If None, no categories are excluded.\n\n        Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.valid(include=include, exclude=exclude)\n\n    @classmethod\n    def leaves(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the leaves of the subtree of the target category.\n\n        Args:\n            target (TokenCategory): The target category.\n\n        Returns (List[TokenCategory]): The list of leaf categories of the target category.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.leaves(target=target)\n\n    @classmethod\n    def nodes(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the nodes of the subtree of the target category.\n\n        Args:\n            target (TokenCategory): The target category.\n\n        Returns (List[TokenCategory]): The list of node categories of the target category.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.nodes(parent=target)\n\n    @classmethod\n    def match(cls,\n              target: TokenCategory, *,\n              include: Optional[Set[TokenCategory]] = None,\n              exclude: Optional[Set[TokenCategory]] = None) -&gt; bool:\n        \"\"\"\n        Check if the target category matches the include and exclude sets.\n\n        Args:\n            target (TokenCategory): The target category.\n            include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n                If None, all categories are included.\n            exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n                If None, no categories are excluded.\n\n        Returns (bool): True if the target category matches the include and exclude sets, False otherwise.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.match(category=target, include=include, exclude=exclude)\n\n    def __str__(self):\n        \"\"\"\n        Get the string representation of the category.\n\n        Returns (str): The string representation of the category.\n        \"\"\"\n        return self.name\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two TokenCategory. Args:     other (TokenCategory): The other category to compare.</p> <p>Returns (bool): True if this category is lower than the other, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.CORE\nTrue\n&gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.STRUCTURAL\nFalse\n&gt;&gt;&gt; TokenCategory.CORE &lt; TokenCategory.STRUCTURAL\nFalse\n&gt;&gt;&gt; sorted([TokenCategory.STRUCTURAL, TokenCategory.CORE])\n[TokenCategory.STRUCTURAL, TokenCategory.CORE]\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __lt__(self, other):\n    \"\"\"\n    Compare two TokenCategory.\n    Args:\n        other (TokenCategory): The other category to compare.\n\n    Returns (bool): True if this category is lower than the other, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.CORE\n        True\n        &gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.STRUCTURAL\n        False\n        &gt;&gt;&gt; TokenCategory.CORE &lt; TokenCategory.STRUCTURAL\n        False\n        &gt;&gt;&gt; sorted([TokenCategory.STRUCTURAL, TokenCategory.CORE])\n        [TokenCategory.STRUCTURAL, TokenCategory.CORE]\n    \"\"\"\n    if isinstance(other, TokenCategory):\n        return self.value &lt; other.value\n    return NotImplemented\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory.__str__","title":"<code>__str__()</code>","text":"<p>Get the string representation of the category.</p> <p>Returns (str): The string representation of the category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Get the string representation of the category.\n\n    Returns (str): The string representation of the category.\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory.children","title":"<code>children(target)</code>  <code>classmethod</code>","text":"<p>Get the children of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of child categories of the target category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef children(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the children of the target category.\n\n    Args:\n        target (TokenCategory): The target category.\n\n    Returns (List[TokenCategory]): The list of child categories of the target category.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.children(parent=target)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory.is_child","title":"<code>is_child(*, child, parent)</code>  <code>classmethod</code>","text":"<p>Check if the child category is a child of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>TokenCategory</code> <p>The child category.</p> required <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns (bool): True if the child category is a child of the parent category, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef is_child(cls, *, child: TokenCategory, parent: TokenCategory) -&gt; bool:\n    \"\"\"\n    Check if the child category is a child of the parent category.\n\n    Args:\n        child (TokenCategory): The child category.\n        parent (TokenCategory): The parent category.\n\n    Returns (bool): True if the child category is a child of the parent category, False otherwise.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.is_child(parent=parent, child=child)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory.leaves","title":"<code>leaves(target)</code>  <code>classmethod</code>","text":"<p>Get the leaves of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of leaf categories of the target category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef leaves(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the leaves of the subtree of the target category.\n\n    Args:\n        target (TokenCategory): The target category.\n\n    Returns (List[TokenCategory]): The list of leaf categories of the target category.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.leaves(target=target)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory.match","title":"<code>match(target, *, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Check if the target category matches the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (bool): True if the target category matches the include and exclude sets, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef match(cls,\n          target: TokenCategory, *,\n          include: Optional[Set[TokenCategory]] = None,\n          exclude: Optional[Set[TokenCategory]] = None) -&gt; bool:\n    \"\"\"\n    Check if the target category matches the include and exclude sets.\n\n    Args:\n        target (TokenCategory): The target category.\n        include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n            If None, all categories are included.\n        exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n            If None, no categories are excluded.\n\n    Returns (bool): True if the target category matches the include and exclude sets, False otherwise.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.match(category=target, include=include, exclude=exclude)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory.nodes","title":"<code>nodes(target)</code>  <code>classmethod</code>","text":"<p>Get the nodes of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of node categories of the target category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef nodes(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the nodes of the subtree of the target category.\n\n    Args:\n        target (TokenCategory): The target category.\n\n    Returns (List[TokenCategory]): The list of node categories of the target category.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.nodes(parent=target)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory.tree","title":"<code>tree()</code>  <code>classmethod</code>","text":"<p>Return a string representation of the category hierarchy Returns (str): The string representation of the category hierarchy</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; print(kp.TokenCategory.tree())\n.\n\u251c\u2500\u2500 TokenCategory.STRUCTURAL\n\u251c\u2500\u2500 TokenCategory.CORE\n\u2502   \u251c\u2500\u2500 TokenCategory.NOTE_REST\n\u2502   \u2502   \u251c\u2500\u2500 TokenCategory.DURATION\n\u2502   \u2502   \u251c\u2500\u2500 TokenCategory.NOTE\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.PITCH\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.DECORATION\n\u2502   \u2502   \u2514\u2500\u2500 TokenCategory.REST\n\u2502   \u251c\u2500\u2500 TokenCategory.CHORD\n\u2502   \u2514\u2500\u2500 TokenCategory.EMPTY\n\u251c\u2500\u2500 TokenCategory.SIGNATURES\n\u2502   \u251c\u2500\u2500 TokenCategory.CLEF\n\u2502   \u251c\u2500\u2500 TokenCategory.TIME_SIGNATURE\n\u2502   \u251c\u2500\u2500 TokenCategory.METER_SYMBOL\n\u2502   \u2514\u2500\u2500 TokenCategory.KEY_SIGNATURE\n\u251c\u2500\u2500 TokenCategory.ENGRAVED_SYMBOLS\n\u251c\u2500\u2500 TokenCategory.OTHER_CONTEXTUAL\n\u251c\u2500\u2500 TokenCategory.BARLINES\n\u251c\u2500\u2500 TokenCategory.COMMENTS\n\u2502   \u251c\u2500\u2500 TokenCategory.FIELD_COMMENTS\n\u2502   \u2514\u2500\u2500 TokenCategory.LINE_COMMENTS\n\u251c\u2500\u2500 TokenCategory.DYNAMICS\n\u251c\u2500\u2500 TokenCategory.HARMONY\n\u251c\u2500\u2500 TokenCategory.FINGERING\n\u251c\u2500\u2500 TokenCategory.LYRICS\n\u251c\u2500\u2500 TokenCategory.INSTRUMENTS\n\u251c\u2500\u2500 TokenCategory.BOUNDING_BOXES\n\u2514\u2500\u2500 TokenCategory.OTHER\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef tree(cls):\n    \"\"\"\n    Return a string representation of the category hierarchy\n    Returns (str): The string representation of the category hierarchy\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; print(kp.TokenCategory.tree())\n        .\n        \u251c\u2500\u2500 TokenCategory.STRUCTURAL\n        \u251c\u2500\u2500 TokenCategory.CORE\n        \u2502   \u251c\u2500\u2500 TokenCategory.NOTE_REST\n        \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.DURATION\n        \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.NOTE\n        \u2502   \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.PITCH\n        \u2502   \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.DECORATION\n        \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.REST\n        \u2502   \u251c\u2500\u2500 TokenCategory.CHORD\n        \u2502   \u2514\u2500\u2500 TokenCategory.EMPTY\n        \u251c\u2500\u2500 TokenCategory.SIGNATURES\n        \u2502   \u251c\u2500\u2500 TokenCategory.CLEF\n        \u2502   \u251c\u2500\u2500 TokenCategory.TIME_SIGNATURE\n        \u2502   \u251c\u2500\u2500 TokenCategory.METER_SYMBOL\n        \u2502   \u2514\u2500\u2500 TokenCategory.KEY_SIGNATURE\n        \u251c\u2500\u2500 TokenCategory.ENGRAVED_SYMBOLS\n        \u251c\u2500\u2500 TokenCategory.OTHER_CONTEXTUAL\n        \u251c\u2500\u2500 TokenCategory.BARLINES\n        \u251c\u2500\u2500 TokenCategory.COMMENTS\n        \u2502   \u251c\u2500\u2500 TokenCategory.FIELD_COMMENTS\n        \u2502   \u2514\u2500\u2500 TokenCategory.LINE_COMMENTS\n        \u251c\u2500\u2500 TokenCategory.DYNAMICS\n        \u251c\u2500\u2500 TokenCategory.HARMONY\n        \u251c\u2500\u2500 TokenCategory.FINGERING\n        \u251c\u2500\u2500 TokenCategory.LYRICS\n        \u251c\u2500\u2500 TokenCategory.INSTRUMENTS\n        \u251c\u2500\u2500 TokenCategory.BOUNDING_BOXES\n        \u2514\u2500\u2500 TokenCategory.OTHER\n    \"\"\"\n    return TokenCategoryHierarchyMapper.tree()\n</code></pre>"},{"location":"reference/#kernpy.TokenCategory.valid","title":"<code>valid(*, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Get the valid categories based on the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef valid(cls, *, include: Optional[Set[TokenCategory]] = None, exclude: Optional[Set[TokenCategory]] = None) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the valid categories based on the include and exclude sets.\n\n    Args:\n        include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n            If None, all categories are included.\n        exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n            If None, no categories are excluded.\n\n    Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.valid(include=include, exclude=exclude)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper","title":"<code>TokenCategoryHierarchyMapper</code>","text":"<p>Mapping of the TokenCategory hierarchy.</p> <p>This class is used to define the hierarchy of the TokenCategory. Useful related methods are provided.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class TokenCategoryHierarchyMapper:\n    \"\"\"\n    Mapping of the TokenCategory hierarchy.\n\n    This class is used to define the hierarchy of the TokenCategory. Useful related methods are provided.\n    \"\"\"\n    \"\"\"\n    The hierarchy of the TokenCategory is a recursive dictionary that defines the parent-child relationships \\\n        between the categories. It's a tree.\n    \"\"\"\n    _hierarchy_typing = Dict[TokenCategory, '_hierarchy_typing']\n    hierarchy: _hierarchy_typing = {\n        TokenCategory.STRUCTURAL: {\n            TokenCategory.HEADER: {},  # each leave must be an empty dictionary\n            TokenCategory.SPINE_OPERATION: {},\n        },\n        TokenCategory.CORE: {\n            TokenCategory.NOTE_REST: {\n                TokenCategory.DURATION: {},\n                TokenCategory.NOTE: {\n                    TokenCategory.PITCH: {},\n                    TokenCategory.DECORATION: {},\n                    TokenCategory.ALTERATION: {},\n                },\n                TokenCategory.REST: {},\n            },\n            TokenCategory.CHORD: {},\n            TokenCategory.EMPTY: {},\n            TokenCategory.ERROR: {},\n        },\n        TokenCategory.SIGNATURES: {\n            TokenCategory.CLEF: {},\n            TokenCategory.TIME_SIGNATURE: {},\n            TokenCategory.METER_SYMBOL: {},\n            TokenCategory.KEY_SIGNATURE: {},\n            TokenCategory.KEY_TOKEN: {},\n        },\n        TokenCategory.ENGRAVED_SYMBOLS: {},\n        TokenCategory.OTHER_CONTEXTUAL: {},\n        TokenCategory.BARLINES: {},\n        TokenCategory.COMMENTS: {\n            TokenCategory.FIELD_COMMENTS: {},\n            TokenCategory.LINE_COMMENTS: {},\n        },\n        TokenCategory.DYNAMICS: {},\n        TokenCategory.HARMONY: {},\n        TokenCategory.FINGERING: {},\n        TokenCategory.LYRICS: {},\n        TokenCategory.INSTRUMENTS: {},\n        TokenCategory.IMAGE_ANNOTATIONS: {\n            TokenCategory.BOUNDING_BOXES: {},\n            TokenCategory.LINE_BREAK: {},\n        },\n        TokenCategory.OTHER: {},\n        TokenCategory.MHXM: {},\n        TokenCategory.ROOT: {},\n    }\n\n    @classmethod\n    def _is_child(cls, parent: TokenCategory, child: TokenCategory, *, tree: '_hierarchy_typing') -&gt; bool:\n        \"\"\"\n        Recursively check if `child` is in the subtree of `parent`.\n\n        Args:\n            parent (TokenCategory): The parent category.\n            child (TokenCategory): The category to check.\n            tree (_hierarchy_typing): The subtree to check.\n\n        Returns:\n            bool: True if `child` is a descendant of `parent`, False otherwise.\n        \"\"\"\n        # Base case: the parent is empty.\n        if len(tree.keys()) == 0:\n            return False\n\n        # Recursive case: explore the direct children of the parent.\n        return any(\n            direct_child == child or cls._is_child(direct_child, child, tree=tree[parent])\n            for direct_child in tree.get(parent, {})\n        )\n        # Vectorized version of the following code:\n        #direct_children = tree.get(parent, dict())\n        #for direct_child in direct_children.keys():\n        #    if direct_child == child or cls._is_child(direct_child, child, tree=tree[parent]):\n        #        return True\n\n    @classmethod\n    def is_child(cls, parent: TokenCategory, child: TokenCategory) -&gt; bool:\n        \"\"\"\n        Recursively check if `child` is in the subtree of `parent`. If `parent` is the same as `child`, return True.\n\n        Args:\n            parent (TokenCategory): The parent category.\n            child (TokenCategory): The category to check.\n\n        Returns:\n            bool: True if `child` is a descendant of `parent`, False otherwise.\n        \"\"\"\n        if parent == child:\n            return True\n        return cls._is_child(parent, child, tree=cls.hierarchy)\n\n    @classmethod\n    def children(cls, parent: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the direct children of the parent category.\n\n        Args:\n            parent (TokenCategory): The parent category.\n\n        Returns:\n            Set[TokenCategory]: The list of children categories of the parent category.\n        \"\"\"\n        return set(cls.hierarchy.get(parent, {}).keys())\n\n    @classmethod\n    def _nodes(cls, tree: _hierarchy_typing) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Recursively get all nodes in the given hierarchy tree.\n        \"\"\"\n        nodes = set(tree.keys())\n        for child in tree.values():\n            nodes.update(cls._nodes(child))\n        return nodes\n\n    @classmethod\n    def _find_subtree(cls, tree: '_hierarchy_typing', parent: TokenCategory) -&gt; Optional['_hierarchy_typing']:\n        \"\"\"\n        Recursively find the subtree for the given parent category.\n        \"\"\"\n        if parent in tree:\n            return tree[parent]  # Return subtree if parent is found at this level\n        for child, sub_tree in tree.items():\n            result = cls._find_subtree(sub_tree, parent)\n            if result is not None:\n                return result\n        return None  # Return None if parent is not found. It won't happer never\n\n\n    @classmethod\n    def nodes(cls, parent: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the all nodes of the subtree of the parent category.\n\n        Args:\n            parent (TokenCategory): The parent category.\n\n        Returns:\n            List[TokenCategory]: The list of nodes of the subtree of the parent category.\n        \"\"\"\n        subtree = cls._find_subtree(cls.hierarchy, parent)\n        return cls._nodes(subtree) if subtree is not None else set()\n\n    @classmethod\n    def valid(cls,\n              include: Optional[Set[TokenCategory]] = None,\n              exclude: Optional[Set[TokenCategory]] = None) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the valid categories based on the include and exclude sets.\n\n        Args:\n            include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n                If None, all categories are included.\n            exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n                If None, no categories are excluded.\n\n        Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.\n        \"\"\"\n        include = cls._validate_include(include)\n        exclude = cls._validate_exclude(exclude)\n\n        included_nodes = set.union(*[(cls.nodes(cat) | {cat}) for cat in include]) if len(include) &gt; 0 else include\n        excluded_nodes = set.union(*[(cls.nodes(cat) | {cat}) for cat in exclude]) if len(exclude) &gt; 0 else exclude\n        return included_nodes - excluded_nodes\n\n    @classmethod\n    def _leaves(cls, tree: '_hierarchy_typing') -&gt; Set[TokenCategory]:\n        \"\"\"\n        Recursively get all leaves (nodes without children) in the hierarchy tree.\n        \"\"\"\n        if not tree:\n            return set()\n        leaves = {node for node, children in tree.items() if not children}\n        for node, children in tree.items():\n            leaves.update(cls._leaves(children))\n        return leaves\n\n    @classmethod\n    def leaves(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the leaves of the subtree of the target category.\n\n        Args:\n            target (TokenCategory): The target category.\n\n        Returns (List[TokenCategory]): The list of leaf categories of the target category.\n        \"\"\"\n        tree = cls._find_subtree(cls.hierarchy, target)\n        return cls._leaves(tree)\n\n\n    @classmethod\n    def _match(cls, category: TokenCategory, *,\n               include: Set[TokenCategory],\n               exclude: Set[TokenCategory]) -&gt; bool:\n        \"\"\"\n        Check if a category matches include/exclude criteria.\n        \"\"\"\n        # Include the category itself along with its descendants.\n        target_nodes = cls.nodes(category) | {category}\n\n        valid_categories = cls.valid(include=include, exclude=exclude)\n\n        # Check if any node in the target set is in the valid categories.\n        return len(target_nodes &amp; valid_categories) &gt; 0\n\n    @classmethod\n    def _validate_include(cls, include: Optional[Set[TokenCategory]]) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Validate the include set.\n        \"\"\"\n        if include is None:\n            return cls.all()\n        if isinstance(include, (list, tuple)):\n            include = set(include)\n        elif not isinstance(include, set):\n            include = {include}\n        if not all(isinstance(cat, TokenCategory) for cat in include):\n            raise ValueError('Invalid category: include and exclude must be a set of TokenCategory.')\n        return include\n\n    @classmethod\n    def _validate_exclude(cls, exclude: Optional[Set[TokenCategory]]) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Validate the exclude set.\n        \"\"\"\n        if exclude is None:\n            return set()\n        if isinstance(exclude, (list, tuple)):\n            exclude = set(exclude)\n        elif not isinstance(exclude, set):\n            exclude = {exclude}\n        if not all(isinstance(cat, TokenCategory) for cat in exclude):\n            raise ValueError(f'Invalid category: category must be a {TokenCategory.__name__}.')\n        return exclude\n\n\n    @classmethod\n    def match(cls, category: TokenCategory, *,\n              include: Optional[Set[TokenCategory]] = None,\n              exclude: Optional[Set[TokenCategory]] = None) -&gt; bool:\n        \"\"\"\n        Check if the category matches the include and exclude sets.\n            If include is None, all categories are included. \\\n            If exclude is None, no categories are excluded.\n\n        Args:\n            category (TokenCategory): The category to check.\n            include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n                If None, all categories are included.\n            exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n                If None, no categories are excluded.\n\n        Returns (bool): True if the category matches the include and exclude sets, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST})\n            True\n            &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.REST})\n            True\n            &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.NOTE})\n            False\n            &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\n            True\n            &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.DURATION, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\n            False\n        \"\"\"\n        include = cls._validate_include(include)\n        exclude = cls._validate_exclude(exclude)\n\n        return cls._match(category, include=include, exclude=exclude)\n\n    @classmethod\n    def all(cls) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get all categories in the hierarchy.\n\n        Returns:\n            Set[TokenCategory]: The set of all categories in the hierarchy.\n        \"\"\"\n        return cls._nodes(cls.hierarchy)\n\n    @classmethod\n    def tree(cls) -&gt; str:\n        \"\"\"\n        Return a string representation of the category hierarchy,\n        formatted similar to the output of the Unix 'tree' command.\n\n        Example output:\n            .\n            \u251c\u2500\u2500 STRUCTURAL\n            \u251c\u2500\u2500 CORE\n            \u2502   \u251c\u2500\u2500 NOTE_REST\n            \u2502   \u2502   \u251c\u2500\u2500 DURATION\n            \u2502   \u2502   \u251c\u2500\u2500 NOTE\n            \u2502   \u2502   \u2502   \u251c\u2500\u2500 PITCH\n            \u2502   \u2502   \u2502   \u2514\u2500\u2500 DECORATION\n            \u2502   \u2502   \u2514\u2500\u2500 REST\n            \u2502   \u251c\u2500\u2500 CHORD\n            \u2502   \u2514\u2500\u2500 EMPTY\n            \u251c\u2500\u2500 SIGNATURES\n            \u2502   \u251c\u2500\u2500 CLEF\n            \u2502   \u251c\u2500\u2500 TIME_SIGNATURE\n            \u2502   \u251c\u2500\u2500 METER_SYMBOL\n            \u2502   \u2514\u2500\u2500 KEY_SIGNATURE\n            \u251c\u2500\u2500 ENGRAVED_SYMBOLS\n            \u251c\u2500\u2500 OTHER_CONTEXTUAL\n            \u251c\u2500\u2500 BARLINES\n            \u251c\u2500\u2500 COMMENTS\n            \u2502   \u251c\u2500\u2500 FIELD_COMMENTS\n            \u2502   \u2514\u2500\u2500 LINE_COMMENTS\n            \u251c\u2500\u2500 DYNAMICS\n            \u251c\u2500\u2500 HARMONY\n            ...\n        \"\"\"\n        def build_tree(tree: Dict[TokenCategory, '_hierarchy_typing'], prefix: str = \"\") -&gt; [str]:\n            lines_buffer = []\n            items = list(tree.items())\n            count = len(items)\n            for index, (category, subtree) in enumerate(items):\n                connector = \"\u2514\u2500\u2500 \" if index == count - 1 else \"\u251c\u2500\u2500 \"\n                lines_buffer.append(prefix + connector + str(category))\n                extension = \"    \" if index == count - 1 else \"\u2502   \"\n                lines_buffer.extend(build_tree(subtree, prefix + extension))\n            return lines_buffer\n\n        lines = [\".\"]\n        lines.extend(build_tree(cls.hierarchy))\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.all","title":"<code>all()</code>  <code>classmethod</code>","text":"<p>Get all categories in the hierarchy.</p> <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>Set[TokenCategory]: The set of all categories in the hierarchy.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef all(cls) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get all categories in the hierarchy.\n\n    Returns:\n        Set[TokenCategory]: The set of all categories in the hierarchy.\n    \"\"\"\n    return cls._nodes(cls.hierarchy)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.children","title":"<code>children(parent)</code>  <code>classmethod</code>","text":"<p>Get the direct children of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>Set[TokenCategory]: The list of children categories of the parent category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef children(cls, parent: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the direct children of the parent category.\n\n    Args:\n        parent (TokenCategory): The parent category.\n\n    Returns:\n        Set[TokenCategory]: The list of children categories of the parent category.\n    \"\"\"\n    return set(cls.hierarchy.get(parent, {}).keys())\n</code></pre>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.is_child","title":"<code>is_child(parent, child)</code>  <code>classmethod</code>","text":"<p>Recursively check if <code>child</code> is in the subtree of <code>parent</code>. If <code>parent</code> is the same as <code>child</code>, return True.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <code>child</code> <code>TokenCategory</code> <p>The category to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>child</code> is a descendant of <code>parent</code>, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef is_child(cls, parent: TokenCategory, child: TokenCategory) -&gt; bool:\n    \"\"\"\n    Recursively check if `child` is in the subtree of `parent`. If `parent` is the same as `child`, return True.\n\n    Args:\n        parent (TokenCategory): The parent category.\n        child (TokenCategory): The category to check.\n\n    Returns:\n        bool: True if `child` is a descendant of `parent`, False otherwise.\n    \"\"\"\n    if parent == child:\n        return True\n    return cls._is_child(parent, child, tree=cls.hierarchy)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.leaves","title":"<code>leaves(target)</code>  <code>classmethod</code>","text":"<p>Get the leaves of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of leaf categories of the target category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef leaves(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the leaves of the subtree of the target category.\n\n    Args:\n        target (TokenCategory): The target category.\n\n    Returns (List[TokenCategory]): The list of leaf categories of the target category.\n    \"\"\"\n    tree = cls._find_subtree(cls.hierarchy, target)\n    return cls._leaves(tree)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.match","title":"<code>match(category, *, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Check if the category matches the include and exclude sets.     If include is None, all categories are included.             If exclude is None, no categories are excluded.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>TokenCategory</code> <p>The category to check.</p> required <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (bool): True if the category matches the include and exclude sets, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.REST})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.NOTE})\nFalse\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.DURATION, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef match(cls, category: TokenCategory, *,\n          include: Optional[Set[TokenCategory]] = None,\n          exclude: Optional[Set[TokenCategory]] = None) -&gt; bool:\n    \"\"\"\n    Check if the category matches the include and exclude sets.\n        If include is None, all categories are included. \\\n        If exclude is None, no categories are excluded.\n\n    Args:\n        category (TokenCategory): The category to check.\n        include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n            If None, all categories are included.\n        exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n            If None, no categories are excluded.\n\n    Returns (bool): True if the category matches the include and exclude sets, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST})\n        True\n        &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.REST})\n        True\n        &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.NOTE})\n        False\n        &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\n        True\n        &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.DURATION, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\n        False\n    \"\"\"\n    include = cls._validate_include(include)\n    exclude = cls._validate_exclude(exclude)\n\n    return cls._match(category, include=include, exclude=exclude)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.nodes","title":"<code>nodes(parent)</code>  <code>classmethod</code>","text":"<p>Get the all nodes of the subtree of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>List[TokenCategory]: The list of nodes of the subtree of the parent category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef nodes(cls, parent: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the all nodes of the subtree of the parent category.\n\n    Args:\n        parent (TokenCategory): The parent category.\n\n    Returns:\n        List[TokenCategory]: The list of nodes of the subtree of the parent category.\n    \"\"\"\n    subtree = cls._find_subtree(cls.hierarchy, parent)\n    return cls._nodes(subtree) if subtree is not None else set()\n</code></pre>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.tree","title":"<code>tree()</code>  <code>classmethod</code>","text":"<p>Return a string representation of the category hierarchy, formatted similar to the output of the Unix 'tree' command.</p> Example output <p>. \u251c\u2500\u2500 STRUCTURAL \u251c\u2500\u2500 CORE \u2502   \u251c\u2500\u2500 NOTE_REST \u2502   \u2502   \u251c\u2500\u2500 DURATION \u2502   \u2502   \u251c\u2500\u2500 NOTE \u2502   \u2502   \u2502   \u251c\u2500\u2500 PITCH \u2502   \u2502   \u2502   \u2514\u2500\u2500 DECORATION \u2502   \u2502   \u2514\u2500\u2500 REST \u2502   \u251c\u2500\u2500 CHORD \u2502   \u2514\u2500\u2500 EMPTY \u251c\u2500\u2500 SIGNATURES \u2502   \u251c\u2500\u2500 CLEF \u2502   \u251c\u2500\u2500 TIME_SIGNATURE \u2502   \u251c\u2500\u2500 METER_SYMBOL \u2502   \u2514\u2500\u2500 KEY_SIGNATURE \u251c\u2500\u2500 ENGRAVED_SYMBOLS \u251c\u2500\u2500 OTHER_CONTEXTUAL \u251c\u2500\u2500 BARLINES \u251c\u2500\u2500 COMMENTS \u2502   \u251c\u2500\u2500 FIELD_COMMENTS \u2502   \u2514\u2500\u2500 LINE_COMMENTS \u251c\u2500\u2500 DYNAMICS \u251c\u2500\u2500 HARMONY ...</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef tree(cls) -&gt; str:\n    \"\"\"\n    Return a string representation of the category hierarchy,\n    formatted similar to the output of the Unix 'tree' command.\n\n    Example output:\n        .\n        \u251c\u2500\u2500 STRUCTURAL\n        \u251c\u2500\u2500 CORE\n        \u2502   \u251c\u2500\u2500 NOTE_REST\n        \u2502   \u2502   \u251c\u2500\u2500 DURATION\n        \u2502   \u2502   \u251c\u2500\u2500 NOTE\n        \u2502   \u2502   \u2502   \u251c\u2500\u2500 PITCH\n        \u2502   \u2502   \u2502   \u2514\u2500\u2500 DECORATION\n        \u2502   \u2502   \u2514\u2500\u2500 REST\n        \u2502   \u251c\u2500\u2500 CHORD\n        \u2502   \u2514\u2500\u2500 EMPTY\n        \u251c\u2500\u2500 SIGNATURES\n        \u2502   \u251c\u2500\u2500 CLEF\n        \u2502   \u251c\u2500\u2500 TIME_SIGNATURE\n        \u2502   \u251c\u2500\u2500 METER_SYMBOL\n        \u2502   \u2514\u2500\u2500 KEY_SIGNATURE\n        \u251c\u2500\u2500 ENGRAVED_SYMBOLS\n        \u251c\u2500\u2500 OTHER_CONTEXTUAL\n        \u251c\u2500\u2500 BARLINES\n        \u251c\u2500\u2500 COMMENTS\n        \u2502   \u251c\u2500\u2500 FIELD_COMMENTS\n        \u2502   \u2514\u2500\u2500 LINE_COMMENTS\n        \u251c\u2500\u2500 DYNAMICS\n        \u251c\u2500\u2500 HARMONY\n        ...\n    \"\"\"\n    def build_tree(tree: Dict[TokenCategory, '_hierarchy_typing'], prefix: str = \"\") -&gt; [str]:\n        lines_buffer = []\n        items = list(tree.items())\n        count = len(items)\n        for index, (category, subtree) in enumerate(items):\n            connector = \"\u2514\u2500\u2500 \" if index == count - 1 else \"\u251c\u2500\u2500 \"\n            lines_buffer.append(prefix + connector + str(category))\n            extension = \"    \" if index == count - 1 else \"\u2502   \"\n            lines_buffer.extend(build_tree(subtree, prefix + extension))\n        return lines_buffer\n\n    lines = [\".\"]\n    lines.extend(build_tree(cls.hierarchy))\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/#kernpy.TokenCategoryHierarchyMapper.valid","title":"<code>valid(include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Get the valid categories based on the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef valid(cls,\n          include: Optional[Set[TokenCategory]] = None,\n          exclude: Optional[Set[TokenCategory]] = None) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the valid categories based on the include and exclude sets.\n\n    Args:\n        include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n            If None, all categories are included.\n        exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n            If None, no categories are excluded.\n\n    Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.\n    \"\"\"\n    include = cls._validate_include(include)\n    exclude = cls._validate_exclude(exclude)\n\n    included_nodes = set.union(*[(cls.nodes(cat) | {cat}) for cat in include]) if len(include) &gt; 0 else include\n    excluded_nodes = set.union(*[(cls.nodes(cat) | {cat}) for cat in exclude]) if len(exclude) &gt; 0 else exclude\n    return included_nodes - excluded_nodes\n</code></pre>"},{"location":"reference/#kernpy.Tokenizer","title":"<code>Tokenizer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Tokenizer interface. All tokenizers must implement this interface.</p> <p>Tokenizers are responsible for converting a token into a string representation.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class Tokenizer(ABC):\n    \"\"\"\n    Tokenizer interface. All tokenizers must implement this interface.\n\n    Tokenizers are responsible for converting a token into a string representation.\n    \"\"\"\n    def __init__(self, *, token_categories: Set['TokenCategory']):\n        \"\"\"\n        Create a new Tokenizer.\n\n        Args:\n            token_categories Set[TokenCategory]: List of categories to be tokenized.\n                If None, an exception will be raised.\n        \"\"\"\n        if token_categories is None:\n            raise ValueError('Categories must be provided. Found None.')\n\n        self.token_categories = token_categories\n\n\n    @abstractmethod\n    def tokenize(self, token: Token) -&gt; str:\n        \"\"\"\n        Tokenize a token into a string representation.\n\n        Args:\n            token (Token): Token to be tokenized.\n\n        Returns (str): Tokenized string representation.\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/#kernpy.Tokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new Tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None, an exception will be raised.</p> required Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def __init__(self, *, token_categories: Set['TokenCategory']):\n    \"\"\"\n    Create a new Tokenizer.\n\n    Args:\n        token_categories Set[TokenCategory]: List of categories to be tokenized.\n            If None, an exception will be raised.\n    \"\"\"\n    if token_categories is None:\n        raise ValueError('Categories must be provided. Found None.')\n\n    self.token_categories = token_categories\n</code></pre>"},{"location":"reference/#kernpy.Tokenizer.tokenize","title":"<code>tokenize(token)</code>  <code>abstractmethod</code>","text":"<p>Tokenize a token into a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>Token to be tokenized.</p> required <p>Returns (str): Tokenized string representation.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>@abstractmethod\ndef tokenize(self, token: Token) -&gt; str:\n    \"\"\"\n    Tokenize a token into a string representation.\n\n    Args:\n        token (Token): Token to be tokenized.\n\n    Returns (str): Tokenized string representation.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#kernpy.agnostic_distance","title":"<code>agnostic_distance(first_pitch, second_pitch)</code>","text":"<p>Calculate the distance in semitones between two pitches.</p> <p>Parameters:</p> Name Type Description Default <code>first_pitch</code> <code>AgnosticPitch</code> <p>The first pitch to compare.</p> required <code>second_pitch</code> <code>AgnosticPitch</code> <p>The second pitch to compare.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The distance in semitones between the two pitches.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('E4'))\n4\n&gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('B3'))\n-1\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def agnostic_distance(\n    first_pitch: AgnosticPitch,\n    second_pitch: AgnosticPitch,\n) -&gt; int:\n    \"\"\"\n    Calculate the distance in semitones between two pitches.\n\n    Args:\n        first_pitch (AgnosticPitch): The first pitch to compare.\n        second_pitch (AgnosticPitch): The second pitch to compare.\n\n    Returns:\n        int: The distance in semitones between the two pitches.\n\n    Examples:\n        &gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('E4'))\n        4\n        &gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('B3'))\n        -1\n    \"\"\"\n    def semitone_index(p: AgnosticPitch) -&gt; int:\n        # base letter:\n        letter = p.name.replace('+', '').replace('-', '')\n        base = LETTER_TO_SEMITONES[letter]\n        # accidentals: '+' is one sharp, '-' one flat\n        alteration = p.name.count('+') - p.name.count('-')\n        return p.octave * 12 + base + alteration\n\n    return semitone_index(second_pitch) - semitone_index(first_pitch)\n</code></pre>"},{"location":"reference/#kernpy.concat","title":"<code>concat(contents, *, separator='\\n')</code>","text":"<pre><code>Concatenate multiple **kern fragments into a single Document object.      All the fragments should be presented in order. Each fragment does not need to be a complete **kern file. \nWarnings:\n    Processing a large number of files in a row may take some time.\n     This method performs as many `kp.read` operations as there are fragments to concatenate.\nArgs:\n    contents (Sequence[str]): List of **kern strings\n    separator (Optional[str]): Separator string to separate the **kern fragments. Default is '\n</code></pre> <p>' (newline).</p> <pre><code>Returns (Tuple[Document, List[Tuple[int, int]]]): Document object and       and a List of Pairs (Tuple[int, int]) representing the measure fragment indexes of the concatenated document.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; contents = ['**kern\n</code></pre> <p>4e 4f 4g - ', '4a 4b 4c - = ', '4d 4e 4f *- ']         &gt;&gt;&gt; document, indexes = kp.concat(contents)         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; document, indexes = kp.concat(contents, separator=' ')         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; document, indexes = kp.concat(contents, separator='')         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; for start, end in indexes:         &gt;&gt;&gt;     print(kp.dumps(document, from_measure=start, to_measure=end)))</p> Source code in <code>kernpy/io/public.py</code> <pre><code>def concat(\n        contents: List[str],\n        *,\n        separator: Optional[str] = '\\n',\n) -&gt; Tuple[Document, List[Tuple[int, int]]]:\n    \"\"\"\n    Concatenate multiple **kern fragments into a single Document object. \\\n     All the fragments should be presented in order. Each fragment does not need to be a complete **kern file. \\\n\n    Warnings:\n        Processing a large number of files in a row may take some time.\n         This method performs as many `kp.read` operations as there are fragments to concatenate.\n    Args:\n        contents (Sequence[str]): List of **kern strings\n        separator (Optional[str]): Separator string to separate the **kern fragments. Default is '\\n' (newline).\n\n    Returns (Tuple[Document, List[Tuple[int, int]]]): Document object and \\\n      and a List of Pairs (Tuple[int, int]) representing the measure fragment indexes of the concatenated document.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; contents = ['**kern\\n4e\\n4f\\n4g\\n*-\\n', '4a\\n4b\\n4c\\n*-\\n=\\n', '4d\\n4e\\n4f\\n*-\\n']\n        &gt;&gt;&gt; document, indexes = kp.concat(contents)\n        &gt;&gt;&gt; indexes\n        [(0, 3), (3, 6), (6, 9)]\n        &gt;&gt;&gt; document, indexes = kp.concat(contents, separator='\\n')\n        &gt;&gt;&gt; indexes\n        [(0, 3), (3, 6), (6, 9)]\n        &gt;&gt;&gt; document, indexes = kp.concat(contents, separator='')\n        &gt;&gt;&gt; indexes\n        [(0, 3), (3, 6), (6, 9)]\n        &gt;&gt;&gt; for start, end in indexes:\n        &gt;&gt;&gt;     print(kp.dumps(document, from_measure=start, to_measure=end)))\n    \"\"\"\n    return generic.Generic.concat(\n        contents=contents,\n        separator=separator,\n    )\n</code></pre>"},{"location":"reference/#kernpy.create","title":"<code>create(content, strict=False)</code>","text":"<pre><code>Create a Document object from a string encoded in Humdrum **kern format.\n\nArgs:\n    content: String encoded in Humdrum **kern format\n    strict: If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.\n\nReturns (Document, list): Document object and list of error messages. Empty list if no errors.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; document, errors = kp.create('**kern\n</code></pre> <p>4e 4f 4g - ')         &gt;&gt;&gt; if len(errors) &gt; 0:         &gt;&gt;&gt;     print(errors)         ['Error: Invalid kern spine: 1', 'Error: Invalid *kern spine: 2']</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'loads' instead.\")\ndef create(\n        content: str,\n        strict=False\n) -&gt; (Document, []):\n    \"\"\"\n    Create a Document object from a string encoded in Humdrum **kern format.\n\n    Args:\n        content: String encoded in Humdrum **kern format\n        strict: If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.\n\n    Returns (Document, list): Document object and list of error messages. Empty list if no errors.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.create('**kern\\n4e\\n4f\\n4g\\n*-\\n')\n        &gt;&gt;&gt; if len(errors) &gt; 0:\n        &gt;&gt;&gt;     print(errors)\n        ['Error: Invalid **kern spine: 1', 'Error: Invalid **kern spine: 2']\n    \"\"\"\n    return Generic.create(\n        content=content,\n        strict=strict\n    )\n</code></pre>"},{"location":"reference/#kernpy.distance","title":"<code>distance(first_encoding, second_encoding, *, first_format=NotationEncoding.HUMDRUM.value, second_format=NotationEncoding.HUMDRUM.value)</code>","text":"<p>Calculate the distance in semitones between two pitches.</p> <p>Parameters:</p> Name Type Description Default <code>first_encoding</code> <code>str</code> <p>The first pitch to compare.</p> required <code>second_encoding</code> <code>str</code> <p>The second pitch to compare.</p> required <code>first_format</code> <code>str</code> <p>The encoding format of the first pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>second_format</code> <code>str</code> <p>The encoding format of the second pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The distance in semitones between the two pitches.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; distance('C4', 'E4')\n4\n&gt;&gt;&gt; distance('C4', 'B3')\n-1\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def distance(\n    first_encoding: str,\n    second_encoding: str,\n    *,\n    first_format: str = NotationEncoding.HUMDRUM.value,\n    second_format: str = NotationEncoding.HUMDRUM.value,\n) -&gt; int:\n    \"\"\"\n    Calculate the distance in semitones between two pitches.\n\n    Args:\n        first_encoding (str): The first pitch to compare.\n        second_encoding (str): The second pitch to compare.\n        first_format (str): The encoding format of the first pitch. Default is HUMDRUM.\n        second_format (str): The encoding format of the second pitch. Default is HUMDRUM.\n\n    Returns:\n        int: The distance in semitones between the two pitches.\n\n    Examples:\n        &gt;&gt;&gt; distance('C4', 'E4')\n        4\n        &gt;&gt;&gt; distance('C4', 'B3')\n        -1\n    \"\"\"\n    first_importer = PitchImporterFactory.create(first_format)\n    first_pitch: AgnosticPitch = first_importer.import_pitch(first_encoding)\n\n    second_importer = PitchImporterFactory.create(second_format)\n    second_pitch: AgnosticPitch = second_importer.import_pitch(second_encoding)\n\n    return agnostic_distance(first_pitch, second_pitch)\n</code></pre>"},{"location":"reference/#kernpy.download_polish_scores","title":"<code>download_polish_scores(input_directory, output_directory, remove_empty_directories=True, kern_spines_filter=2, exporter_kern_type='ekern')</code>","text":"<p>Process the files in the input_directory and save the results in the output_directory. http requests are made to download the images.</p> <p>Parameters:</p> Name Type Description Default <code>input_directory</code> <code>str</code> <p>directory where the input files are found</p> required <code>output_directory</code> <code>str</code> <p>directory where the output files are saved</p> required <code>remove_empty_directories</code> <code>Optional[bool]</code> <p>remove empty directories when finish processing the files</p> <code>True</code> <code>kern_spines_filter</code> <code>Optional[int]</code> <p>Only process files with the number of **kern spines specified.            Use it to export 2-voice files. Default is 2.            Use None to process all files.</p> <code>2</code> <code>exporter_kern_type</code> <code>Optional[str]</code> <p>the type of kern exporter. It can be 'krn' or 'ekrn'</p> <code>'ekern'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern')\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern', remove_empty_directories=False)\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern', kern_spines_filter=2, remove_empty_directories=False)\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern', kern_spines_filter=None, remove_empty_directories=False)\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern', exporter_kern_type='krn', remove_empty_directories=True)\nNone\n</code></pre> <pre><code>&gt;&gt;&gt; main('/kern_files', '/output_ekern', exporter_kern_type='ekrn', remove_empty_directories=True, kern_spines_filter=2)\nNone\n</code></pre> Source code in <code>kernpy/polish_scores/download_polish_dataset.py</code> <pre><code>def main(\n        input_directory: str,\n        output_directory: str,\n        remove_empty_directories: Optional[bool] = True,\n        kern_spines_filter: Optional[int] = 2,\n        exporter_kern_type: Optional[str] = 'ekern'\n) -&gt; None:\n    \"\"\"\n    Process the files in the input_directory and save the results in the output_directory.\n    http requests are made to download the images.\n\n    Args:\n        input_directory (str): directory where the input files are found\n        output_directory (str): directory where the output files are saved\n        remove_empty_directories (Optional[bool]): remove empty directories when finish processing the files\n        kern_spines_filter (Optional[int]): Only process files with the number of **kern spines specified.\\\n            Use it to export 2-voice files. Default is 2.\\\n            Use None to process all files.\n        exporter_kern_type (Optional[str]): the type of kern exporter. It can be 'krn' or 'ekrn'\n\n\n\n    Returns:\n        None\n\n    Examples:\n        &gt;&gt;&gt; main('/kern_files', '/output_ekern')\n        None\n\n        &gt;&gt;&gt; main('/kern_files', '/output_ekern', remove_empty_directories=False)\n        None\n\n        &gt;&gt;&gt; main('/kern_files', '/output_ekern', kern_spines_filter=2, remove_empty_directories=False)\n        None\n\n        &gt;&gt;&gt; main('/kern_files', '/output_ekern', kern_spines_filter=None, remove_empty_directories=False)\n        None\n\n        &gt;&gt;&gt; main('/kern_files', '/output_ekern', exporter_kern_type='krn', remove_empty_directories=True)\n        None\n\n        &gt;&gt;&gt; main('/kern_files', '/output_ekern', exporter_kern_type='ekrn', remove_empty_directories=True, kern_spines_filter=2)\n        None\n\n    \"\"\"\n    print(f'Processing files in {input_directory} and saving to {output_directory}')\n    kern_with_bboxes = search_files_with_string(input_directory, 'xywh')\n    ok_files = []\n    ko_files = []\n    log_file = os.path.join(output_directory, LOG_FILENAME)\n    print(f\"{25*'='}\"\n          f\"\\nProcessing {len(kern_with_bboxes)} files.\"\n          f\"\\nLog will be saved in {log_file}.\"\n          f\"\\n{25*'='}\")\n    for kern in kern_with_bboxes:\n        try:\n            filename = remove_extension(kern)\n            kern_path = os.path.join(input_directory, kern)\n            output_kern_path = os.path.join(output_directory, filename)\n            if not os.path.exists(output_kern_path):\n                os.makedirs(output_kern_path)\n            convert_and_download_file(kern_path, output_kern_path, log_filename=log_file, kern_spines_filter=kern_spines_filter, exporter_kern_type=exporter_kern_type)\n            ok_files.append(kern)\n        except Exception as error:\n            ko_files.append(kern)\n            print(f'Errors in {kern}: {error}')\n            store_error_log(os.path.join(output_directory, 'errors.json'), {'kern': kern, 'error': str(error)})\n\n    if remove_empty_directories:\n        remove_empty_dirs(output_directory)\n\n    print(f'----&gt; OK files #{len(ok_files)}')\n    print(f'----&gt; KO files #{len(ko_files)}')\n    print(ko_files)\n</code></pre>"},{"location":"reference/#kernpy.dump","title":"<code>dump(document, fp, *, spine_types=None, include=None, exclude=None, from_measure=None, to_measure=None, tokenizer=None, instruments=None, show_measure_numbers=None, spine_ids=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>The Document object to write to the file.</p> required <code>fp</code> <code>Union[str, Path]</code> <p>The file path to write the Document object.</p> required <code>spine_types</code> <code>Iterable</code> <p>kern, mens, etc...</p> <code>None</code> <code>include</code> <code>Iterable</code> <p>The token categories to include in the exported file. When None, all the token categories will be exported.</p> <code>None</code> <code>exclude</code> <code>Iterable</code> <p>The token categories to exclude from the exported file. When None, no token categories will be excluded.</p> <code>None</code> <code>from_measure</code> <code>int</code> <p>The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1</p> <code>None</code> <code>to_measure</code> <code>int</code> <p>The measure to end exporting. When None, the exporter will end at the end of the file.</p> <code>None</code> <code>tokenizer</code> <code>Encoding</code> <p>The type of the **kern file to export.</p> <code>None</code> <code>instruments</code> <code>Iterable</code> <p>The instruments to export. If None, all the instruments will be exported.</p> <code>None</code> <code>show_measure_numbers</code> <code>Bool</code> <p>Show the measure numbers in the exported file.</p> <code>None</code> <code>spine_ids</code> <code>Iterable</code> <p>The ids of the spines to export. When None, all the spines will be exported.             Spines ids start from 0, and they are increased by 1 for each spine to the right.</p> <code>None</code> <p>Returns (None): None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the document could not be exported.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.load('BWV565.krn')\n&gt;&gt;&gt; kp.dump(document, 'BWV565_normalized.krn')\nNone\n&gt;&gt;&gt; # File 'BWV565_normalized.krn' will be created with the normalized **kern representation.\n</code></pre> Source code in <code>kernpy/io/public.py</code> <pre><code>def dump(document: Document, fp: Union[str, Path], *,\n         spine_types: [] = None,\n         include: [] = None,\n         exclude: [] = None,\n         from_measure: int = None,\n         to_measure: int = None,\n         tokenizer: Encoding = None,\n         instruments: [] = None,\n         show_measure_numbers: bool = None,\n         spine_ids: [int] = None\n         ) -&gt; None:\n    \"\"\"\n\n    Args:\n        document (Document): The Document object to write to the file.\n        fp (Union[str, Path]): The file path to write the Document object.\n        spine_types (Iterable): **kern, **mens, etc...\n        include (Iterable): The token categories to include in the exported file. When None, all the token categories will be exported.\n        exclude (Iterable): The token categories to exclude from the exported file. When None, no token categories will be excluded.\n        from_measure (int): The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1\n        to_measure (int): The measure to end exporting. When None, the exporter will end at the end of the file.\n        tokenizer (Encoding): The type of the **kern file to export.\n        instruments (Iterable): The instruments to export. If None, all the instruments will be exported.\n        show_measure_numbers (Bool): Show the measure numbers in the exported file.\n        spine_ids (Iterable): The ids of the spines to export. When None, all the spines will be exported. \\\n            Spines ids start from 0, and they are increased by 1 for each spine to the right.\n\n\n    Returns (None): None\n\n    Raises:\n        ValueError: If the document could not be exported.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.load('BWV565.krn')\n        &gt;&gt;&gt; kp.dump(document, 'BWV565_normalized.krn')\n        None\n        &gt;&gt;&gt; # File 'BWV565_normalized.krn' will be created with the normalized **kern representation.\n    \"\"\"\n    # Create an ExportOptions instance with only user-modified arguments\n    options = generic.Generic.parse_options_to_ExportOptions(\n        spine_types=spine_types,\n        include=include,\n        exclude=exclude,\n        from_measure=from_measure,\n        to_measure=to_measure,\n        kern_type=tokenizer,\n        instruments=instruments,\n        show_measure_numbers=show_measure_numbers,\n        spine_ids=spine_ids\n    )\n\n    return generic.Generic.store(\n        document=document,\n        path=fp,\n        options=options\n    )\n</code></pre>"},{"location":"reference/#kernpy.dumps","title":"<code>dumps(document, *, spine_types=None, include=None, exclude=None, from_measure=None, to_measure=None, tokenizer=None, instruments=None, show_measure_numbers=None, spine_ids=None)</code>","text":"<pre><code>Args:\n    document (Document): The Document object to write to the file.\n    fp (Union[str, Path]): The file path to write the Document object.\n    spine_types (Iterable): **kern, **mens, etc...\n    include (Iterable): The token categories to include in the exported file. When None, all the token categories will be exported.\n    exclude (Iterable): The token categories to exclude from the exported file. When None, no token categories will be excluded.\n    from_measure (int): The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1\n    to_measure (int): The measure to end exporting. When None, the exporter will end at the end of the file.\n    tokenizer (Encoding): The type of the **kern file to export.\n    instruments (Iterable): The instruments to export. If None, all the instruments will be exported.\n    show_measure_numbers (Bool): Show the measure numbers in the exported file.\n    spine_ids (Iterable): The ids of the spines to export. When None, all the spines will be exported.             Spines ids start from 0, and they are increased by 1 for each spine to the right.\n\n\nReturns (None): None\n\nRaises:\n    ValueError: If the document could not be exported.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; document, errors = kp.load('score.krn')\n    &gt;&gt;&gt; kp.dumps(document)\n    '**kern\n</code></pre> <p>clefG2 =1 4c 4d 4e 4f -'</p> Source code in <code>kernpy/io/public.py</code> <pre><code>def dumps(document: Document, *,\n          spine_types: [] = None,\n          include: [] = None,\n          exclude: [] = None,\n          from_measure: int = None,\n          to_measure: int = None,\n          tokenizer: Encoding = None,\n          instruments: [] = None,\n          show_measure_numbers: bool = None,\n          spine_ids: [int] = None\n          ) -&gt; str:\n    \"\"\"\n\n    Args:\n        document (Document): The Document object to write to the file.\n        fp (Union[str, Path]): The file path to write the Document object.\n        spine_types (Iterable): **kern, **mens, etc...\n        include (Iterable): The token categories to include in the exported file. When None, all the token categories will be exported.\n        exclude (Iterable): The token categories to exclude from the exported file. When None, no token categories will be excluded.\n        from_measure (int): The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1\n        to_measure (int): The measure to end exporting. When None, the exporter will end at the end of the file.\n        tokenizer (Encoding): The type of the **kern file to export.\n        instruments (Iterable): The instruments to export. If None, all the instruments will be exported.\n        show_measure_numbers (Bool): Show the measure numbers in the exported file.\n        spine_ids (Iterable): The ids of the spines to export. When None, all the spines will be exported. \\\n            Spines ids start from 0, and they are increased by 1 for each spine to the right.\n\n\n    Returns (None): None\n\n    Raises:\n        ValueError: If the document could not be exported.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.load('score.krn')\n        &gt;&gt;&gt; kp.dumps(document)\n        '**kern\\n*clefG2\\n=1\\n4c\\n4d\\n4e\\n4f\\n*-'\n    \"\"\"\n    # Create an ExportOptions instance with only user-modified arguments\n    options = generic.Generic.parse_options_to_ExportOptions(\n        spine_types=spine_types,\n        include=include,\n        exclude=exclude,\n        from_measure=from_measure,\n        to_measure=to_measure,\n        kern_type=tokenizer,\n        instruments=instruments,\n        show_measure_numbers=show_measure_numbers,\n        spine_ids=spine_ids\n    )\n\n    return generic.Generic.export(\n        document=document,\n        options=options\n    )\n</code></pre>"},{"location":"reference/#kernpy.ekern_to_krn","title":"<code>ekern_to_krn(input_file, output_file)</code>","text":"<p>Convert one .ekrn file to .krn file.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Filepath to the input **ekern</p> required <code>output_file</code> <code>str</code> <p>Filepath to the output **kern</p> required <p>Returns:     None</p> Example Source code in <code>kernpy/core/exporter.py</code> <pre><code>def ekern_to_krn(\n        input_file: str,\n        output_file: str\n) -&gt; None:\n    \"\"\"\n    Convert one .ekrn file to .krn file.\n\n    Args:\n        input_file (str): Filepath to the input **ekern\n        output_file (str): Filepath to the output **kern\n    Returns:\n        None\n\n    Example:\n        # Convert .ekrn to .krn\n        &gt;&gt;&gt; ekern_to_krn('path/to/file.ekrn', 'path/to/file.krn')\n\n        # Convert a list of .ekrn files to .krn files\n        ```python\n        ekrn_files = your_modue.get_files()\n\n        # Use the wrapper to avoid stopping the process if an error occurs\n        def ekern_to_krn_wrapper(ekern_file, kern_file):\n            try:\n                ekern_to_krn(ekrn_files, output_folder)\n            except Exception as e:\n                print(f'Error:{e}')\n\n        # Convert all the files\n        for ekern_file in ekrn_files:\n            output_file = ekern_file.replace('.ekrn', '.krn')\n            ekern_to_krn_wrapper(ekern_file, output_file)\n        ```\n    \"\"\"\n    with open(input_file, 'r') as file:\n        content = file.read()\n\n    kern_content = get_kern_from_ekern(content)\n\n    with open(output_file, 'w') as file:\n        file.write(kern_content)\n</code></pre>"},{"location":"reference/#kernpy.ekern_to_krn--convert-ekrn-to-krn","title":"Convert .ekrn to .krn","text":"<p>ekern_to_krn('path/to/file.ekrn', 'path/to/file.krn')</p>"},{"location":"reference/#kernpy.ekern_to_krn--convert-a-list-of-ekrn-files-to-krn-files","title":"Convert a list of .ekrn files to .krn files","text":"<pre><code>ekrn_files = your_modue.get_files()\n\n# Use the wrapper to avoid stopping the process if an error occurs\ndef ekern_to_krn_wrapper(ekern_file, kern_file):\n    try:\n        ekern_to_krn(ekrn_files, output_folder)\n    except Exception as e:\n        print(f'Error:{e}')\n\n# Convert all the files\nfor ekern_file in ekrn_files:\n    output_file = ekern_file.replace('.ekrn', '.krn')\n    ekern_to_krn_wrapper(ekern_file, output_file)\n</code></pre>"},{"location":"reference/#kernpy.export","title":"<code>export(document, options)</code>","text":"<p>Export a Document object to a string.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to export</p> required <code>options</code> <code>ExportOptions</code> <p>Export options</p> required <p>Returns: Exported string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; options = kp.ExportOptions()\n&gt;&gt;&gt; content = kp.export(document, options)\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'dumps' instead.\")\ndef export(\n        document: Document,\n        options: ExportOptions\n) -&gt; str:\n    \"\"\"\n    Export a Document object to a string.\n\n    Args:\n        document: Document object to export\n        options: Export options\n\n    Returns: Exported string\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n        &gt;&gt;&gt; options = kp.ExportOptions()\n        &gt;&gt;&gt; content = kp.export(document, options)\n    \"\"\"\n    return Generic.export(\n        document=document,\n        options=options\n    )\n</code></pre>"},{"location":"reference/#kernpy.get_kern_from_ekern","title":"<code>get_kern_from_ekern(ekern_content)</code>","text":"<p>Read the content of a ekern file and return the kern content.</p> <p>Parameters:</p> Name Type Description Default <code>ekern_content</code> <code>str</code> <p>The content of the **ekern file.</p> required <p>Returns:     The content of the **kern file.</p> Example <pre><code># Read **ekern file\nekern_file = 'path/to/file.ekrn'\nwith open(ekern_file, 'r') as file:\n    ekern_content = file.read()\n\n# Get **kern content\nkern_content = get_kern_from_ekern(ekern_content)\nwith open('path/to/file.krn', 'w') as file:\n    file.write(kern_content)\n\n</code></pre> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def get_kern_from_ekern(ekern_content: str) -&gt; str:\n    \"\"\"\n    Read the content of a **ekern file and return the **kern content.\n\n    Args:\n        ekern_content: The content of the **ekern file.\n    Returns:\n        The content of the **kern file.\n\n    Example:\n        ```python\n        # Read **ekern file\n        ekern_file = 'path/to/file.ekrn'\n        with open(ekern_file, 'r') as file:\n            ekern_content = file.read()\n\n        # Get **kern content\n        kern_content = get_kern_from_ekern(ekern_content)\n        with open('path/to/file.krn', 'w') as file:\n            file.write(kern_content)\n\n        ```\n    \"\"\"\n    content = ekern_content.replace(\"**ekern\", \"**kern\")  # TODO Constante seg\u00fan las cabeceras\n    content = content.replace(TOKEN_SEPARATOR, \"\")\n    content = content.replace(DECORATION_SEPARATOR, \"\")\n\n    return content\n</code></pre>"},{"location":"reference/#kernpy.get_spine_types","title":"<code>get_spine_types(document, spine_types=None)</code>","text":"<p>Get the spines of a Document object.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to get spines from</p> required <code>spine_types</code> <code>Optional[Sequence[str]]</code> <p>List of spine types to get. If None, all spines are returned.</p> <code>None</code> <p>Returns (List[str]): List of spines</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n&gt;&gt;&gt; kp.get_spine_types(document)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern'])\n['**kern', '**kern', '**kern', '**kern']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root'])\n['**kern', '**kern', '**kern', '**kern', '**root']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root', '**harm'])\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, [])\n[]\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'spine_types' instead.\")\ndef get_spine_types(\n        document: Document,\n        spine_types: Optional[Sequence[str]] = None\n) -&gt; List[str]:\n    \"\"\"\n    Get the spines of a Document object.\n\n    Args:\n        document (Document): Document object to get spines from\n        spine_types (Optional[Sequence[str]]): List of spine types to get. If None, all spines are returned.\n\n    Returns (List[str]): List of spines\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n        &gt;&gt;&gt; kp.get_spine_types(document)\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; kp.get_spine_types(document, None)\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; kp.get_spine_types(document, ['**kern'])\n        ['**kern', '**kern', '**kern', '**kern']\n        &gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root'])\n        ['**kern', '**kern', '**kern', '**kern', '**root']\n        &gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root', '**harm'])\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; kp.get_spine_types(document, [])\n        []\n    \"\"\"\n    return Generic.get_spine_types(\n        document=document,\n        spine_types=spine_types\n    )\n</code></pre>"},{"location":"reference/#kernpy.graph","title":"<code>graph(document, fp)</code>","text":"<p>Create a graph representation of a Document object using Graphviz. Save the graph as a .dot file or indicate the     output file path or stream. If the output file path is None, the function will return the graphviz content as a        string to the standard output.</p> <p>Use the Graphviz software to convert the .dot file to an image.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>The Document object to export as a graphviz file.</p> required <code>fp</code> <code>Optional[Union[str, Path]]</code> <p>The file path to write the graphviz file. If None, the function will return the            graphviz content as a string to the standard output.</p> required <p>Returns (None): None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.load('score.krn')\n&gt;&gt;&gt; kp.graph(document, 'score.dot')\nNone\n&gt;&gt;&gt; # File 'score.dot' will be created with the graphviz representation of the Document object.\n&gt;&gt;&gt; kp.graph(document, None)\n'digraph G { ... }'\n</code></pre> Source code in <code>kernpy/io/public.py</code> <pre><code>def graph(document: Document, fp: Optional[Union[str, Path]]) -&gt; None:\n    \"\"\"\n    Create a graph representation of a Document object using Graphviz. Save the graph as a .dot file or indicate the\\\n     output file path or stream. If the output file path is None, the function will return the graphviz content as a\\\n        string to the standard output.\n\n    Use the Graphviz software to convert the .dot file to an image.\n\n\n    Args:\n        document (Document): The Document object to export as a graphviz file.\n        fp (Optional[Union[str, Path]]): The file path to write the graphviz file. If None, the function will return the\\\n            graphviz content as a string to the standard output.\n\n    Returns (None): None\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.load('score.krn')\n        &gt;&gt;&gt; kp.graph(document, 'score.dot')\n        None\n        &gt;&gt;&gt; # File 'score.dot' will be created with the graphviz representation of the Document object.\n        &gt;&gt;&gt; kp.graph(document, None)\n        'digraph G { ... }'\n    \"\"\"\n    return generic.Generic.store_graph(\n        document=document,\n        path=fp\n    )\n</code></pre>"},{"location":"reference/#kernpy.kern_to_ekern","title":"<code>kern_to_ekern(input_file, output_file)</code>","text":"<p>Convert one .krn file to .ekrn file</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Filepath to the input **kern</p> required <code>output_file</code> <code>str</code> <p>Filepath to the output **ekern</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example Source code in <code>kernpy/core/exporter.py</code> <pre><code>def kern_to_ekern(\n        input_file: str,\n        output_file: str\n) -&gt; None:\n    \"\"\"\n    Convert one .krn file to .ekrn file\n\n    Args:\n        input_file (str): Filepath to the input **kern\n        output_file (str): Filepath to the output **ekern\n\n    Returns:\n        None\n\n    Example:\n        # Convert .krn to .ekrn\n        &gt;&gt;&gt; kern_to_ekern('path/to/file.krn', 'path/to/file.ekrn')\n\n        # Convert a list of .krn files to .ekrn files\n        ```python\n        krn_files = your_module.get_files()\n\n        # Use the wrapper to avoid stopping the process if an error occurs\n        def kern_to_ekern_wrapper(krn_file, ekern_file):\n            try:\n                kern_to_ekern(krn_file, ekern_file)\n            except Exception as e:\n                print(f'Error:{e}')\n\n        # Convert all the files\n        for krn_file in krn_files:\n            output_file = krn_file.replace('.krn', '.ekrn')\n            kern_to_ekern_wrapper(krn_file, output_file)\n        ```\n\n    \"\"\"\n    importer = Importer()\n    document = importer.import_file(input_file)\n\n    if len(importer.errors):\n        raise Exception(f'ERROR: {input_file} has errors {importer.get_error_messages()}')\n\n    export_options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES,\n                                   kern_type=Encoding.eKern)\n    exporter = Exporter()\n    exported_ekern = exporter.export_string(document, export_options)\n\n    with open(output_file, 'w') as file:\n        file.write(exported_ekern)\n</code></pre>"},{"location":"reference/#kernpy.kern_to_ekern--convert-krn-to-ekrn","title":"Convert .krn to .ekrn","text":"<p>kern_to_ekern('path/to/file.krn', 'path/to/file.ekrn')</p>"},{"location":"reference/#kernpy.kern_to_ekern--convert-a-list-of-krn-files-to-ekrn-files","title":"Convert a list of .krn files to .ekrn files","text":"<pre><code>krn_files = your_module.get_files()\n\n# Use the wrapper to avoid stopping the process if an error occurs\ndef kern_to_ekern_wrapper(krn_file, ekern_file):\n    try:\n        kern_to_ekern(krn_file, ekern_file)\n    except Exception as e:\n        print(f'Error:{e}')\n\n# Convert all the files\nfor krn_file in krn_files:\n    output_file = krn_file.replace('.krn', '.ekrn')\n    kern_to_ekern_wrapper(krn_file, output_file)\n</code></pre>"},{"location":"reference/#kernpy.load","title":"<code>load(fp, *, raise_on_errors=False, **kwargs)</code>","text":"<p>Load a Document object from a Humdrum **kern file-like object.</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Union[str, Path]</code> <p>A path-like object representing a **kern file.</p> required <code>raise_on_errors</code> <code>Optional[bool]</code> <p>If True, raise an exception if any grammar error is detected            during parsing.</p> <code>False</code> <p>Returns ((Document, List[str])): A tuple containing the Document object and a list of messages representing         grammar errors detected during parsing. If the list is empty,        the parsing did not detect any errors.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the Humdrum **kern representation could not be parsed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.load('BWV565.krn')\n&gt;&gt;&gt; if len(errors) &gt; 0:\n&gt;&gt;&gt;     print(f\"Grammar didn't recognize the following errors: {errors}\")\n['Error: Invalid **kern spine: 1', 'Error: Invalid **kern spine: 2']\n&gt;&gt;&gt;     # Anyway, we can use the Document\n&gt;&gt;&gt;     print(document)\n&gt;&gt;&gt; else:\n&gt;&gt;&gt;     print(document)\n&lt;kernpy.core.document.Document object at 0x7f8b3b7b3d90&gt;\n</code></pre> Source code in <code>kernpy/io/public.py</code> <pre><code>def load(fp: Union[str, Path], *, raise_on_errors: Optional[bool] = False, **kwargs) -&gt; (Document, List[str]):\n    \"\"\"\n    Load a Document object from a Humdrum **kern file-like object.\n\n    Args:\n        fp (Union[str, Path]): A path-like object representing a **kern file.\n        raise_on_errors (Optional[bool], optional): If True, raise an exception if any grammar error is detected\\\n            during parsing.\n\n    Returns ((Document, List[str])): A tuple containing the Document object and a list of messages representing \\\n        grammar errors detected during parsing. If the list is empty,\\\n        the parsing did not detect any errors.\n\n    Raises:\n        ValueError: If the Humdrum **kern representation could not be parsed.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.load('BWV565.krn')\n        &gt;&gt;&gt; if len(errors) &gt; 0:\n        &gt;&gt;&gt;     print(f\"Grammar didn't recognize the following errors: {errors}\")\n        ['Error: Invalid **kern spine: 1', 'Error: Invalid **kern spine: 2']\n        &gt;&gt;&gt;     # Anyway, we can use the Document\n        &gt;&gt;&gt;     print(document)\n        &gt;&gt;&gt; else:\n        &gt;&gt;&gt;     print(document)\n        &lt;kernpy.core.document.Document object at 0x7f8b3b7b3d90&gt;\n    \"\"\"\n    return generic.Generic.read(\n        path=fp,\n        strict=raise_on_errors,\n    )\n</code></pre>"},{"location":"reference/#kernpy.loads","title":"<code>loads(s, *, raise_on_errors=False, **kwargs)</code>","text":"<pre><code>Load a Document object from a string encoded in Humdrum **kern.\n\nArgs:\n    s (str): A string containing a **kern file.\n    raise_on_errors (Optional[bool], optional): If True, raise an exception if any grammar error is detected            during parsing.\n\nReturns ((Document, List[str])): A tuple containing the Document object and a list of messages representing         grammar errors detected during parsing. If the list is empty,        the parsing did not detect any errors.\n\nRaises:\n    ValueError: If the Humdrum **kern representation could not be parsed.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; document, errors = kp.loads('**kern\n</code></pre> <p>clefG2 =1 4c 4d 4e 4f ')         &gt;&gt;&gt; if len(errors) &gt; 0:         &gt;&gt;&gt;     print(f\"Grammar didn't recognize the following errors: {errors}\")         ['Error: Invalid *kern spine: 1']         &gt;&gt;&gt;     # Anyway, we can use the Document         &gt;&gt;&gt;     print(document)         &gt;&gt;&gt; else:         &gt;&gt;&gt;     print(document)          Source code in <code>kernpy/io/public.py</code> <pre><code>def loads(s, *, raise_on_errors: Optional[bool] = False, **kwargs) -&gt; (Document, List[str]):\n    \"\"\"\n    Load a Document object from a string encoded in Humdrum **kern.\n\n    Args:\n        s (str): A string containing a **kern file.\n        raise_on_errors (Optional[bool], optional): If True, raise an exception if any grammar error is detected\\\n            during parsing.\n\n    Returns ((Document, List[str])): A tuple containing the Document object and a list of messages representing \\\n        grammar errors detected during parsing. If the list is empty,\\\n        the parsing did not detect any errors.\n\n    Raises:\n        ValueError: If the Humdrum **kern representation could not be parsed.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.loads('**kern\\n*clefG2\\n=1\\n4c\\n4d\\n4e\\n4f\\n')\n        &gt;&gt;&gt; if len(errors) &gt; 0:\n        &gt;&gt;&gt;     print(f\"Grammar didn't recognize the following errors: {errors}\")\n        ['Error: Invalid **kern spine: 1']\n        &gt;&gt;&gt;     # Anyway, we can use the Document\n        &gt;&gt;&gt;     print(document)\n        &gt;&gt;&gt; else:\n        &gt;&gt;&gt;     print(document)\n        &lt;kernpy.core.document.Document object at 0x7f8b3b7b3d90&gt;\n    \"\"\"\n    return generic.Generic.create(\n        content=s,\n        strict=raise_on_errors,\n    )\n</code></pre>"},{"location":"reference/#kernpy.merge","title":"<code>merge(contents, *, raise_on_errors=False)</code>","text":"<pre><code>Merge multiple **kern fragments into a single **kern string.      All the fragments should be presented in order. Each fragment does not need to be a complete **kern file. \nWarnings:\n    Processing a large number of files in a row may take some time.\n     This method performs as many `kp.read` operations as there are fragments to concatenate.\nArgs:\n    contents (Sequence[str]): List of **kern strings\n    raise_on_errors (Optional[bool], optional): If True, raise an exception if any grammar error is detected            during parsing.\n\nReturns (Tuple[Document, List[Tuple[int, int]]]): Document object and       and a List of Pairs (Tuple[int, int]) representing the measure fragment indexes of the concatenated document.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; contents = ['**kern\n</code></pre> <p>4e 4f 4g - -', 'kern 4a 4b 4c - = -', 'kern 4d 4e 4f - -']         &gt;&gt;&gt; document, indexes = kp.concat(contents)         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; document, indexes = kp.concat(contents, separator=' ')         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; document, indexes = kp.concat(contents, separator='')         &gt;&gt;&gt; indexes         [(0, 3), (3, 6), (6, 9)]         &gt;&gt;&gt; for start, end in indexes:         &gt;&gt;&gt;     print(kp.dumps(document, from_measure=start, to_measure=end)))</p> Source code in <code>kernpy/io/public.py</code> <pre><code>def merge(\n        contents: List[str],\n        *,\n        raise_on_errors: Optional[bool] = False,\n) -&gt; Tuple[Document, List[Tuple[int, int]]]:\n    \"\"\"\n    Merge multiple **kern fragments into a single **kern string. \\\n     All the fragments should be presented in order. Each fragment does not need to be a complete **kern file. \\\n\n    Warnings:\n        Processing a large number of files in a row may take some time.\n         This method performs as many `kp.read` operations as there are fragments to concatenate.\n    Args:\n        contents (Sequence[str]): List of **kern strings\n        raise_on_errors (Optional[bool], optional): If True, raise an exception if any grammar error is detected\\\n            during parsing.\n\n    Returns (Tuple[Document, List[Tuple[int, int]]]): Document object and \\\n      and a List of Pairs (Tuple[int, int]) representing the measure fragment indexes of the concatenated document.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; contents = ['**kern\\n4e\\n4f\\n4g\\n*-\\n*-', '**kern\\n4a\\n4b\\n4c\\n*-\\n=\\n*-', '**kern\\n4d\\n4e\\n4f\\n*-\\n*-']\n        &gt;&gt;&gt; document, indexes = kp.concat(contents)\n        &gt;&gt;&gt; indexes\n        [(0, 3), (3, 6), (6, 9)]\n        &gt;&gt;&gt; document, indexes = kp.concat(contents, separator='\\n')\n        &gt;&gt;&gt; indexes\n        [(0, 3), (3, 6), (6, 9)]\n        &gt;&gt;&gt; document, indexes = kp.concat(contents, separator='')\n        &gt;&gt;&gt; indexes\n        [(0, 3), (3, 6), (6, 9)]\n        &gt;&gt;&gt; for start, end in indexes:\n        &gt;&gt;&gt;     print(kp.dumps(document, from_measure=start, to_measure=end)))\n    \"\"\"\n    return generic.Generic.merge(\n        contents=contents,\n        strict=raise_on_errors\n    )\n</code></pre>"},{"location":"reference/#kernpy.read","title":"<code>read(path, strict=False)</code>","text":"<p>Read a Humdrum **kern file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>File path to read</p> required <code>strict</code> <code>Optional[bool]</code> <p>If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.</p> <code>False</code> <p>Returns (Document, List[str]): Document object and list of error messages. Empty list if no errors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n</code></pre> <pre><code>&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; if len(errors) &gt; 0:\n&gt;&gt;&gt;     print(errors)\n['Error: Invalid **kern spine: 1', 'Error: Invalid **kern spine: 2']\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'load' instead.\")\ndef read(\n        path: Union[str, Path],\n        strict: Optional[bool] = False\n) -&gt; (Document, List[str]):\n    \"\"\"\n    Read a Humdrum **kern file.\n\n    Args:\n        path (Union[str, Path]): File path to read\n        strict (Optional[bool]): If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.\n\n    Returns (Document, List[str]): Document object and list of error messages. Empty list if no errors.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n\n        &gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n        &gt;&gt;&gt; if len(errors) &gt; 0:\n        &gt;&gt;&gt;     print(errors)\n        ['Error: Invalid **kern spine: 1', 'Error: Invalid **kern spine: 2']\n    \"\"\"\n    return Generic.read(\n        path=Path(path),\n        strict=strict\n    )\n</code></pre>"},{"location":"reference/#kernpy.spine_types","title":"<code>spine_types(document, headers=None)</code>","text":"<p>Get the spines of a Document object.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to get spines from</p> required <code>headers</code> <code>Optional[Sequence[str]]</code> <p>List of spine types to get. If None, all spines are returned. Using a          header will return all the spines of that type.</p> <code>None</code> <p>Returns (List[str]): List of spines</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n&gt;&gt;&gt; kp.spine_types(document)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.spine_types(document, None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.spine_types(document, headers=None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.spine_types(document, headers=['**kern'])\n['**kern', '**kern', '**kern', '**kern']\n&gt;&gt;&gt; kp.spine_types(document, headers=['**kern', '**root'])\n['**kern', '**kern', '**kern', '**kern', '**root']\n&gt;&gt;&gt; kp.spine_types(document, headers=['**kern', '**root', '**harm'])\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.spine_types(document, headers=[])\n[]\n</code></pre> Source code in <code>kernpy/io/public.py</code> <pre><code>def spine_types(\n        document: Document,\n        headers: Optional[Sequence[str]] = None\n) -&gt; List[str]:\n    \"\"\"\n    Get the spines of a Document object.\n\n    Args:\n        document (Document): Document object to get spines from\n        headers (Optional[Sequence[str]]): List of spine types to get. If None, all spines are returned. Using a \\\n         header will return all the spines of that type.\n\n    Returns (List[str]): List of spines\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n        &gt;&gt;&gt; kp.spine_types(document)\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; kp.spine_types(document, None)\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; kp.spine_types(document, headers=None)\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; kp.spine_types(document, headers=['**kern'])\n        ['**kern', '**kern', '**kern', '**kern']\n        &gt;&gt;&gt; kp.spine_types(document, headers=['**kern', '**root'])\n        ['**kern', '**kern', '**kern', '**kern', '**root']\n        &gt;&gt;&gt; kp.spine_types(document, headers=['**kern', '**root', '**harm'])\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; kp.spine_types(document, headers=[])\n        []\n    \"\"\"\n    return generic.Generic.get_spine_types(\n        document=document,\n        spine_types=headers\n    )\n</code></pre>"},{"location":"reference/#kernpy.store","title":"<code>store(document, path, options)</code>","text":"<p>Store a Document object to a file.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to store</p> required <code>path</code> <code>Union[str, Path]</code> <p>File path to store</p> required <code>options</code> <code>ExportOptions</code> <p>Export options</p> required <p>Returns: None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; options = kp.ExportOptions()\n&gt;&gt;&gt; kp.store(document, 'path/to/store.krn', options)\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'dump' instead.\")\ndef store(\n        document: Document,\n        path: Union[str, Path],\n        options: ExportOptions\n) -&gt; None:\n    \"\"\"\n    Store a Document object to a file.\n\n    Args:\n        document (Document): Document object to store\n        path (Union[str, Path]): File path to store\n        options (ExportOptions): Export options\n\n    Returns: None\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n        &gt;&gt;&gt; options = kp.ExportOptions()\n        &gt;&gt;&gt; kp.store(document, 'path/to/store.krn', options)\n\n    \"\"\"\n    Generic.store(\n        document=document,\n        path=Path(path),\n        options=options\n    )\n</code></pre>"},{"location":"reference/#kernpy.store_graph","title":"<code>store_graph(document, path)</code>","text":"<p>Create a graph representation of a Document object using Graphviz. Save the graph to a file.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to create graph from</p> required <code>path</code> <code>str</code> <p>File path to save the graph</p> required <p>Returns (None): None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; kp.store_graph(document, 'path/to/graph.dot')\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'graph' instead.\")\ndef store_graph(\n        document: Document,\n        path: Union[str, Path]\n) -&gt; None:\n    \"\"\"\n    Create a graph representation of a Document object using Graphviz. Save the graph to a file.\n\n    Args:\n        document (Document): Document object to create graph from\n        path (str): File path to save the graph\n\n    Returns (None): None\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n        &gt;&gt;&gt; kp.store_graph(document, 'path/to/graph.dot')\n    \"\"\"\n    return Generic.store_graph(\n        document=document,\n        path=Path(path)\n    )\n</code></pre>"},{"location":"reference/#kernpy.transpose","title":"<code>transpose(input_encoding, interval, input_format=NotationEncoding.HUMDRUM.value, output_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose a pitch by a given interval.</p> <p>The pitch must be in the American notation.</p> <p>Parameters:</p> Name Type Description Default <code>input_encoding</code> <code>str</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>input_format</code> <code>str</code> <p>The encoding format of the pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>output_format</code> <code>str</code> <p>The encoding format of the transposed pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>str</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', output_format='kern')\n'fff'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\n'fff'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\n'gg'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction=Direction.DOWN.value)\n'gg'\n&gt;&gt;&gt; transpose('ccc#', IntervalsByName['P4'])\n'fff#'\n&gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format='american')\n'Bb4'\n&gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format=NotationEncoding.AMERICAN.value)\n'Bb4'\n&gt;&gt;&gt; transpose('C3', IntervalsByName['P4'], input_format='american', direction='down')\n'G2'\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def transpose(\n        input_encoding: str,\n        interval: int,\n        input_format: str = NotationEncoding.HUMDRUM.value,\n        output_format: str = NotationEncoding.HUMDRUM.value,\n        direction: str = Direction.UP.value\n) -&gt; str:\n    \"\"\"\n    Transpose a pitch by a given interval.\n\n    The pitch must be in the American notation.\n\n    Args:\n        input_encoding (str): The pitch to transpose.\n        interval (int): The interval to transpose the pitch.\n        input_format (str): The encoding format of the pitch. Default is HUMDRUM.\n        output_format (str): The encoding format of the transposed pitch. Default is HUMDRUM.\n        direction (str): The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.\n\n    Returns:\n        str: The transposed pitch.\n\n    Examples:\n        &gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', output_format='kern')\n        'fff'\n        &gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\n        'fff'\n        &gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\n        'gg'\n        &gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction=Direction.DOWN.value)\n        'gg'\n        &gt;&gt;&gt; transpose('ccc#', IntervalsByName['P4'])\n        'fff#'\n        &gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format='american')\n        'Bb4'\n        &gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format=NotationEncoding.AMERICAN.value)\n        'Bb4'\n        &gt;&gt;&gt; transpose('C3', IntervalsByName['P4'], input_format='american', direction='down')\n        'G2'\n\n\n    \"\"\"\n    importer = PitchImporterFactory.create(input_format)\n    pitch: AgnosticPitch = importer.import_pitch(input_encoding)\n\n    transposed_pitch = transpose_agnostics(pitch, interval, direction=direction)\n\n    exporter = PitchExporterFactory.create(output_format)\n    content = exporter.export_pitch(transposed_pitch)\n\n    return content\n</code></pre>"},{"location":"reference/#kernpy.transpose_agnostic_to_encoding","title":"<code>transpose_agnostic_to_encoding(agnostic_pitch, interval, output_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose an AgnosticPitch by a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>agnostic_pitch</code> <code>AgnosticPitch</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>output_format</code> <code>Optional[str]</code> <p>The encoding format of the transposed pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>Optional[str]</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns (str):     str: The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'])\n'F4'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\n'G3'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C#', 4), IntervalsByName['P4'])\n'F#4'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\n'Bb4'\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def transpose_agnostic_to_encoding(\n        agnostic_pitch: AgnosticPitch,\n        interval: int,\n        output_format: str = NotationEncoding.HUMDRUM.value,\n        direction: str = Direction.UP.value\n) -&gt; str:\n    \"\"\"\n    Transpose an AgnosticPitch by a given interval.\n\n    Args:\n        agnostic_pitch (AgnosticPitch): The pitch to transpose.\n        interval (int): The interval to transpose the pitch.\n        output_format (Optional[str]): The encoding format of the transposed pitch. Default is HUMDRUM.\n        direction (Optional[str]): The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.\n\n    Returns (str):\n        str: The transposed pitch.\n\n    Examples:\n        &gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'])\n        'F4'\n        &gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\n        'G3'\n        &gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C#', 4), IntervalsByName['P4'])\n        'F#4'\n        &gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\n        'Bb4'\n    \"\"\"\n    exporter = PitchExporterFactory.create(output_format)\n    transposed_pitch = transpose_agnostics(agnostic_pitch, interval, direction=direction)\n    content = exporter.export_pitch(transposed_pitch)\n\n    return content\n</code></pre>"},{"location":"reference/#kernpy.transpose_agnostics","title":"<code>transpose_agnostics(input_pitch, interval, direction=Direction.UP.value)</code>","text":"<p>Transpose an AgnosticPitch by a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>input_pitch</code> <code>AgnosticPitch</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>direction</code> <code>str</code> <p>The direction of the transposition. 'UP' or 'DOWN'. Default is 'UP'.</p> <code>UP.value</code> Returns <p>AgnosticPitch: The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'])\nAgnosticPitch('F', 4)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\nAgnosticPitch('G', 3)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C#', 4), IntervalsByName['P4'])\nAgnosticPitch('F#', 4)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\nAgnosticPitch('Bb', 4)\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def transpose_agnostics(\n        input_pitch: AgnosticPitch,\n        interval: int,\n        direction: str = Direction.UP.value\n) -&gt; AgnosticPitch:\n    \"\"\"\n    Transpose an AgnosticPitch by a given interval.\n\n    Args:\n        input_pitch (AgnosticPitch): The pitch to transpose.\n        interval (int): The interval to transpose the pitch.\n        direction (str): The direction of the transposition. 'UP' or 'DOWN'. Default is 'UP'.\n\n    Returns :\n        AgnosticPitch: The transposed pitch.\n\n    Examples:\n        &gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'])\n        AgnosticPitch('F', 4)\n        &gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\n        AgnosticPitch('G', 3)\n        &gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C#', 4), IntervalsByName['P4'])\n        AgnosticPitch('F#', 4)\n        &gt;&gt;&gt; transpose_agnostics(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\n        AgnosticPitch('Bb', 4)\n\n    \"\"\"\n    return AgnosticPitch.to_transposed(input_pitch, interval, direction)\n</code></pre>"},{"location":"reference/#kernpy.transpose_encoding_to_agnostic","title":"<code>transpose_encoding_to_agnostic(input_encoding, interval, input_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose a pitch by a given interval.</p> <p>The pitch must be in the American notation.</p> <p>Parameters:</p> Name Type Description Default <code>input_encoding</code> <code>str</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>input_format</code> <code>str</code> <p>The encoding format of the pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>str</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns:</p> Name Type Description <code>AgnosticPitch</code> <code>AgnosticPitch</code> <p>The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern')\nAgnosticPitch('fff', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\nAgnosticPitch('fff', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\nAgnosticPitch('gg', 3)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc#', IntervalsByName['P4'])\nAgnosticPitch('fff#', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('G4', IntervalsByName['m3'], input_format='american')\nAgnosticPitch('Bb4', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('C3', IntervalsByName['P4'], input_format='american', direction='down')\nAgnosticPitch('G2', 2)\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def transpose_encoding_to_agnostic(\n        input_encoding: str,\n        interval: int,\n        input_format: str = NotationEncoding.HUMDRUM.value,\n        direction: str = Direction.UP.value\n) -&gt; AgnosticPitch:\n    \"\"\"\n    Transpose a pitch by a given interval.\n\n    The pitch must be in the American notation.\n\n    Args:\n        input_encoding (str): The pitch to transpose.\n        interval (int): The interval to transpose the pitch.\n        input_format (str): The encoding format of the pitch. Default is HUMDRUM.\n        direction (str): The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.\n\n    Returns:\n        AgnosticPitch: The transposed pitch.\n\n    Examples:\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern')\n        AgnosticPitch('fff', 4)\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\n        AgnosticPitch('fff', 4)\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\n        AgnosticPitch('gg', 3)\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('ccc#', IntervalsByName['P4'])\n        AgnosticPitch('fff#', 4)\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('G4', IntervalsByName['m3'], input_format='american')\n        AgnosticPitch('Bb4', 4)\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('C3', IntervalsByName['P4'], input_format='american', direction='down')\n        AgnosticPitch('G2', 2)\n\n    \"\"\"\n    importer = PitchImporterFactory.create(input_format)\n    pitch: AgnosticPitch = importer.import_pitch(input_encoding)\n\n    return transpose_agnostics(pitch, interval, direction=direction)\n</code></pre>"},{"location":"reference/#modules","title":"Modules","text":"<p>kernpy.core</p> <p>=====</p> <p>This module contains the core functionality of the <code>kernpy</code> package.</p> <p>kernpy.util</p> <p>=====</p> <p>This module contains utility functions for the kernpy package.</p>"},{"location":"reference/#kernpy.core.Intervals","title":"<code>Intervals = {-2: 'dd1', -1: 'd1', 0: 'P1', 1: 'A1', 2: 'AA1', 3: 'dd2', 4: 'd2', 5: 'm2', 6: 'M2', 7: 'A2', 8: 'AA2', 9: 'dd3', 10: 'd3', 11: 'm3', 12: 'M3', 13: 'A3', 14: 'AA3', 15: 'dd4', 16: 'd4', 17: 'P4', 18: 'A4', 19: 'AA4', 21: 'dd5', 22: 'd5', 23: 'P5', 24: 'A5', 25: 'AA5', 26: 'dd6', 27: 'd6', 28: 'm6', 29: 'M6', 30: 'A6', 31: 'AA6', 32: 'dd7', 33: 'd7', 34: 'm7', 35: 'M7', 36: 'A7', 37: 'AA7', 40: 'octave'}</code>  <code>module-attribute</code>","text":"<p>Base-40 interval classes (d=diminished, m=minor, M=major, P=perfect, A=augmented)</p>"},{"location":"reference/#kernpy.core.AbstractToken","title":"<code>AbstractToken</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class representing a token.</p> <p>This class serves as a blueprint for creating various types of tokens, which are categorized based on their TokenCategory.</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> <code>category</code> <code>TokenCategory</code> <p>The category of the token.</p> <code>hidden</code> <code>bool</code> <p>A flag indicating whether the token is hidden. Defaults to False.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class AbstractToken(ABC):\n    \"\"\"\n    An abstract base class representing a token.\n\n    This class serves as a blueprint for creating various types of tokens, which are\n    categorized based on their TokenCategory.\n\n    Attributes:\n        encoding (str): The original representation of the token.\n        category (TokenCategory): The category of the token.\n        hidden (bool): A flag indicating whether the token is hidden. Defaults to False.\n    \"\"\"\n\n    def __init__(self, encoding: str, category: TokenCategory):\n        \"\"\"\n        AbstractToken constructor\n\n        Args:\n            encoding (str): The original representation of the token.\n            category (TokenCategory): The category of the token.\n        \"\"\"\n        self.encoding = encoding\n        self.category = category\n        self.hidden = False\n\n    @abstractmethod\n    def export(self, **kwargs) -&gt; str:\n        \"\"\"\n        Exports the token.\n\n        Keyword Arguments:\n            filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n                indicating whether the token should be included in the export. If provided, only tokens for which the\n                function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n        Returns:\n            str: The encoded token representation, potentially filtered if a filter_categories function is provided.\n\n        Examples:\n            &gt;&gt;&gt; token = AbstractToken('*clefF4', TokenCategory.SIGNATURES)\n            &gt;&gt;&gt; token.export()\n            '*clefF4'\n            &gt;&gt;&gt; token.export(filter_categories=lambda cat: cat in {TokenCategory.SIGNATURES, TokenCategory.SIGNATURES.DURATION})\n            '*clefF4'\n        \"\"\"\n        pass\n\n\n    def __str__(self):\n        \"\"\"\n        Returns the string representation of the token.\n\n        Returns (str): The string representation of the token without processing.\n        \"\"\"\n        return self.export()\n\n    def __eq__(self, other):\n        \"\"\"\n        Compare two tokens.\n\n        Args:\n            other (AbstractToken): The other token to compare.\n        Returns (bool): True if the tokens are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, AbstractToken):\n            return False\n        return self.encoding == other.encoding and self.category == other.category\n\n    def __ne__(self, other):\n        \"\"\"\n        Compare two tokens.\n\n        Args:\n            other (AbstractToken): The other token to compare.\n        Returns (bool): True if the tokens are different, False otherwise.\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        \"\"\"\n        Returns the hash of the token.\n\n        Returns (int): The hash of the token.\n        \"\"\"\n        return hash((self.export(), self.category))\n</code></pre>"},{"location":"reference/#kernpy.core.AbstractToken.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two tokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>AbstractToken</code> <p>The other token to compare.</p> required <p>Returns (bool): True if the tokens are equal, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compare two tokens.\n\n    Args:\n        other (AbstractToken): The other token to compare.\n    Returns (bool): True if the tokens are equal, False otherwise.\n    \"\"\"\n    if not isinstance(other, AbstractToken):\n        return False\n    return self.encoding == other.encoding and self.category == other.category\n</code></pre>"},{"location":"reference/#kernpy.core.AbstractToken.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the token.</p> <p>Returns (int): The hash of the token.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Returns the hash of the token.\n\n    Returns (int): The hash of the token.\n    \"\"\"\n    return hash((self.export(), self.category))\n</code></pre>"},{"location":"reference/#kernpy.core.AbstractToken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>AbstractToken constructor</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>category</code> <code>TokenCategory</code> <p>The category of the token.</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding: str, category: TokenCategory):\n    \"\"\"\n    AbstractToken constructor\n\n    Args:\n        encoding (str): The original representation of the token.\n        category (TokenCategory): The category of the token.\n    \"\"\"\n    self.encoding = encoding\n    self.category = category\n    self.hidden = False\n</code></pre>"},{"location":"reference/#kernpy.core.AbstractToken.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two tokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>AbstractToken</code> <p>The other token to compare.</p> required <p>Returns (bool): True if the tokens are different, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ne__(self, other):\n    \"\"\"\n    Compare two tokens.\n\n    Args:\n        other (AbstractToken): The other token to compare.\n    Returns (bool): True if the tokens are different, False otherwise.\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.AbstractToken.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the token.</p> <p>Returns (str): The string representation of the token without processing.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Returns the string representation of the token.\n\n    Returns (str): The string representation of the token without processing.\n    \"\"\"\n    return self.export()\n</code></pre>"},{"location":"reference/#kernpy.core.AbstractToken.export","title":"<code>export(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The encoded token representation, potentially filtered if a filter_categories function is provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token = AbstractToken('*clefF4', TokenCategory.SIGNATURES)\n&gt;&gt;&gt; token.export()\n'*clefF4'\n&gt;&gt;&gt; token.export(filter_categories=lambda cat: cat in {TokenCategory.SIGNATURES, TokenCategory.SIGNATURES.DURATION})\n'*clefF4'\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@abstractmethod\ndef export(self, **kwargs) -&gt; str:\n    \"\"\"\n    Exports the token.\n\n    Keyword Arguments:\n        filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n            indicating whether the token should be included in the export. If provided, only tokens for which the\n            function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n    Returns:\n        str: The encoded token representation, potentially filtered if a filter_categories function is provided.\n\n    Examples:\n        &gt;&gt;&gt; token = AbstractToken('*clefF4', TokenCategory.SIGNATURES)\n        &gt;&gt;&gt; token.export()\n        '*clefF4'\n        &gt;&gt;&gt; token.export(filter_categories=lambda cat: cat in {TokenCategory.SIGNATURES, TokenCategory.SIGNATURES.DURATION})\n        '*clefF4'\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#kernpy.core.AgnosticPitch","title":"<code>AgnosticPitch</code>","text":"<p>Represents a pitch in a generic way, independent of the notation system used.</p> Source code in <code>kernpy/core/pitch_models.py</code> <pre><code>class AgnosticPitch:\n    \"\"\"\n    Represents a pitch in a generic way, independent of the notation system used.\n    \"\"\"\n\n    ASCENDANT_ACCIDENTAL_ALTERATION = '+'\n    DESCENDENT_ACCIDENTAL_ALTERATION = '-'\n    ACCIDENTAL_ALTERATIONS = {\n        ASCENDANT_ACCIDENTAL_ALTERATION,\n        DESCENDENT_ACCIDENTAL_ALTERATION\n    }\n\n\n    def __init__(self, name: str, octave: int):\n        \"\"\"\n        Initialize the AgnosticPitch object.\n\n        Args:\n            name (str): The name of the pitch (e.g., 'C', 'D#', 'Bb').\n            octave (int): The octave of the pitch (e.g., 4 for middle C).\n        \"\"\"\n        self.name = name\n        self.octave = octave\n\n    @property\n    def name(self):\n        return self.__name\n\n    @name.setter\n    def name(self, name):\n        accidentals = ''.join([c for c in name if c in ['-', '+']])\n        name = name.upper()\n        name = name.replace('#', '+').replace('b', '-')\n\n        check_name = name.replace('+', '').replace('-', '')\n        if check_name not in pitches:\n            raise ValueError(f\"Invalid pitch: {name}\")\n        if len(accidentals) &gt; 3:\n            raise ValueError(f\"Invalid pitch: {name}. Maximum of 3 accidentals allowed. \")\n        self.__name = name\n\n    @property\n    def octave(self):\n        return self.__octave\n\n    @octave.setter\n    def octave(self, octave):\n        if not isinstance(octave, int):\n            raise ValueError(f\"Invalid octave: {octave}\")\n        self.__octave = octave\n\n    def get_chroma(self):\n        return 40 * self.octave + Chromas[self.name]\n\n    @classmethod\n    def to_transposed(cls, agnostic_pitch: 'AgnosticPitch', raw_interval, direction: str = Direction.UP.value) -&gt; 'AgnosticPitch':\n        delta = raw_interval if direction == Direction.UP.value else - raw_interval\n        chroma = agnostic_pitch.get_chroma() + delta\n        name = ChromasByValue[chroma % 40]\n        octave = chroma // 40\n        return AgnosticPitch(name, octave)\n\n    @classmethod\n    def get_chroma_from_interval(cls, pitch_a: 'AgnosticPitch', pitch_b: 'AgnosticPitch'):\n        return pitch_b.get_chroma() - pitch_a.get_chroma()\n\n    def __str__(self):\n        return f\"&lt;{self.name}, {self.octave}&gt;\"\n\n    def __repr__(self):\n        return f\"{self.__name}(name={self.name}, octave={self.octave})\"\n\n    def __eq__(self, other):\n        if not isinstance(other, AgnosticPitch):\n            return False\n        return self.name == other.name and self.octave == other.octave\n\n    def __ne__(self, other):\n        if not isinstance(other, AgnosticPitch):\n            return True\n        return self.name != other.name or self.octave != other.octave\n\n    def __hash__(self):\n        return hash((self.name, self.octave))\n\n    def __lt__(self, other):\n        if not isinstance(other, AgnosticPitch):\n            return NotImplemented\n        if self.octave == other.octave:\n            return Chromas[self.name] &lt; Chromas[other.name]\n        return self.octave &lt; other.octave\n\n    def __gt__(self, other):\n        if not isinstance(other, AgnosticPitch):\n            return NotImplemented\n        if self.octave == other.octave:\n            return Chromas[self.name] &gt; Chromas[other.name]\n        return self.octave &gt; other.octave\n</code></pre>"},{"location":"reference/#kernpy.core.AgnosticPitch.__init__","title":"<code>__init__(name, octave)</code>","text":"<p>Initialize the AgnosticPitch object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the pitch (e.g., 'C', 'D#', 'Bb').</p> required <code>octave</code> <code>int</code> <p>The octave of the pitch (e.g., 4 for middle C).</p> required Source code in <code>kernpy/core/pitch_models.py</code> <pre><code>def __init__(self, name: str, octave: int):\n    \"\"\"\n    Initialize the AgnosticPitch object.\n\n    Args:\n        name (str): The name of the pitch (e.g., 'C', 'D#', 'Bb').\n        octave (int): The octave of the pitch (e.g., 4 for middle C).\n    \"\"\"\n    self.name = name\n    self.octave = octave\n</code></pre>"},{"location":"reference/#kernpy.core.Alteration","title":"<code>Alteration</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for the alteration of a pitch.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class Alteration(Enum):\n    \"\"\"\n    Enum for the alteration of a pitch.\n    \"\"\"\n    NONE = 0\n    SHARP = 1\n    FLAT = -1\n    DOUBLE_SHARP = 2\n    DOUBLE_FLAT = -2\n    TRIPLE_SHARP = 3\n    TRIPLE_FLAT = -3\n    HALF_SHARP = 0.5\n    HALF_FLAT = -0.5\n    QUARTER_SHARP = 0.25\n    QUARTER_FLAT = -0.25\n\n    def __str__(self) -&gt; str:\n        return self.name\n</code></pre>"},{"location":"reference/#kernpy.core.BarToken","title":"<code>BarToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>BarToken class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class BarToken(SimpleToken):\n    \"\"\"\n    BarToken class.\n    \"\"\"\n\n    def __init__(self, encoding):\n        super().__init__(encoding, TokenCategory.BARLINES)\n</code></pre>"},{"location":"reference/#kernpy.core.BasicSpineImporter","title":"<code>BasicSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/basic_spine_importer.py</code> <pre><code>class BasicSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()  # TODO: Create a custom functional listener for BasicSpineImporter\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.BARLINES,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if not any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.OTHER)\n\n        return token\n</code></pre>"},{"location":"reference/#kernpy.core.BasicSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/basic_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.core.BekernTokenizer","title":"<code>BekernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>BekernTokenizer converts a Token into a bekern (Basic Extended **kern) string representation. This format use a '@' separator for the     main tokens but discards all the decorations tokens.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class BekernTokenizer(Tokenizer):\n    \"\"\"\n    BekernTokenizer converts a Token into a bekern (Basic Extended **kern) string representation. This format use a '@' separator for the \\\n    main tokens but discards all the decorations tokens.\n    \"\"\"\n\n    def __init__(self, *, token_categories: Set['TokenCategory']):\n        \"\"\"\n        Create a new BekernTokenizer\n\n        Args:\n            token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n        \"\"\"\n        super().__init__(token_categories=token_categories)\n\n    def tokenize(self, token: Token) -&gt; str:\n        \"\"\"\n        Tokenize a token into a bekern string representation.\n        Args:\n            token (Token): Token to be tokenized.\n\n        Returns (str): bekern string representation.\n\n        Examples:\n            &gt;&gt;&gt; token.encoding\n            '2@.@bb@-\u00b7_\u00b7L'\n            &gt;&gt;&gt; BekernTokenizer().tokenize(token)\n            '2@.@bb@-'\n        \"\"\"\n        ekern_content = token.export(filter_categories=lambda cat: cat in self.token_categories)\n\n        if DECORATION_SEPARATOR not in ekern_content:\n            return ekern_content\n\n        reduced_content = ekern_content.split(DECORATION_SEPARATOR)[0]\n        if reduced_content.endswith(TOKEN_SEPARATOR):\n            reduced_content = reduced_content[:-1]\n\n        return reduced_content\n</code></pre>"},{"location":"reference/#kernpy.core.BekernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new BekernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def __init__(self, *, token_categories: Set['TokenCategory']):\n    \"\"\"\n    Create a new BekernTokenizer\n\n    Args:\n        token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n    \"\"\"\n    super().__init__(token_categories=token_categories)\n</code></pre>"},{"location":"reference/#kernpy.core.BekernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a bekern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): bekern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; BekernTokenizer().tokenize(token)\n'2@.@bb@-'\n</code></pre> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def tokenize(self, token: Token) -&gt; str:\n    \"\"\"\n    Tokenize a token into a bekern string representation.\n    Args:\n        token (Token): Token to be tokenized.\n\n    Returns (str): bekern string representation.\n\n    Examples:\n        &gt;&gt;&gt; token.encoding\n        '2@.@bb@-\u00b7_\u00b7L'\n        &gt;&gt;&gt; BekernTokenizer().tokenize(token)\n        '2@.@bb@-'\n    \"\"\"\n    ekern_content = token.export(filter_categories=lambda cat: cat in self.token_categories)\n\n    if DECORATION_SEPARATOR not in ekern_content:\n        return ekern_content\n\n    reduced_content = ekern_content.split(DECORATION_SEPARATOR)[0]\n    if reduced_content.endswith(TOKEN_SEPARATOR):\n        reduced_content = reduced_content[:-1]\n\n    return reduced_content\n</code></pre>"},{"location":"reference/#kernpy.core.BkernTokenizer","title":"<code>BkernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>BkernTokenizer converts a Token into a bkern (Basic kern) string representation. This format use     the main tokens but not the decorations tokens. This format is a lightweight version of the classic Humdrum kern format.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class BkernTokenizer(Tokenizer):\n    \"\"\"\n    BkernTokenizer converts a Token into a bkern (Basic **kern) string representation. This format use \\\n    the main tokens but not the decorations tokens. This format is a lightweight version of the classic\n    Humdrum **kern format.\n    \"\"\"\n\n    def __init__(self, *, token_categories: Set['TokenCategory']):\n        \"\"\"\n        Create a new BkernTokenizer\n\n        Args:\n            token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n        \"\"\"\n        super().__init__(token_categories=token_categories)\n\n\n    def tokenize(self, token: Token) -&gt; str:\n        \"\"\"\n        Tokenize a token into a bkern string representation.\n        Args:\n            token (Token): Token to be tokenized.\n\n        Returns (str): bkern string representation.\n\n        Examples:\n            &gt;&gt;&gt; token.encoding\n            '2@.@bb@-\u00b7_\u00b7L'\n            &gt;&gt;&gt; BkernTokenizer().tokenize(token)\n            '2.bb-'\n        \"\"\"\n        return BekernTokenizer(token_categories=self.token_categories).tokenize(token).replace(TOKEN_SEPARATOR, '')\n</code></pre>"},{"location":"reference/#kernpy.core.BkernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new BkernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def __init__(self, *, token_categories: Set['TokenCategory']):\n    \"\"\"\n    Create a new BkernTokenizer\n\n    Args:\n        token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n    \"\"\"\n    super().__init__(token_categories=token_categories)\n</code></pre>"},{"location":"reference/#kernpy.core.BkernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a bkern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): bkern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; BkernTokenizer().tokenize(token)\n'2.bb-'\n</code></pre> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def tokenize(self, token: Token) -&gt; str:\n    \"\"\"\n    Tokenize a token into a bkern string representation.\n    Args:\n        token (Token): Token to be tokenized.\n\n    Returns (str): bkern string representation.\n\n    Examples:\n        &gt;&gt;&gt; token.encoding\n        '2@.@bb@-\u00b7_\u00b7L'\n        &gt;&gt;&gt; BkernTokenizer().tokenize(token)\n        '2.bb-'\n    \"\"\"\n    return BekernTokenizer(token_categories=self.token_categories).tokenize(token).replace(TOKEN_SEPARATOR, '')\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBox","title":"<code>BoundingBox</code>","text":"<p>BoundingBox class.</p> <p>It contains the coordinates of the score bounding box. Useful for full-page tasks.</p> <p>Attributes:</p> Name Type Description <code>from_x</code> <code>int</code> <p>The x coordinate of the top left corner</p> <code>from_y</code> <code>int</code> <p>The y coordinate of the top left corner</p> <code>to_x</code> <code>int</code> <p>The x coordinate of the bottom right corner</p> <code>to_y</code> <code>int</code> <p>The y coordinate of the bottom right corner</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class BoundingBox:\n    \"\"\"\n    BoundingBox class.\n\n    It contains the coordinates of the score bounding box. Useful for full-page tasks.\n\n    Attributes:\n        from_x (int): The x coordinate of the top left corner\n        from_y (int): The y coordinate of the top left corner\n        to_x (int): The x coordinate of the bottom right corner\n        to_y (int): The y coordinate of the bottom right corner\n    \"\"\"\n\n    def __init__(self, x, y, w, h):\n        \"\"\"\n        BoundingBox constructor.\n\n        Args:\n            x (int): The x coordinate of the top left corner\n            y (int): The y coordinate of the top left corner\n            w (int): The width\n            h (int): The height\n        \"\"\"\n        self.from_x = x\n        self.from_y = y\n        self.to_x = x + w\n        self.to_y = y + h\n\n    def w(self) -&gt; int:\n        \"\"\"\n        Returns the width of the box\n\n        Returns:\n            int: The width of the box\n        \"\"\"\n        return self.to_x - self.from_x\n\n    def h(self) -&gt; int:\n        \"\"\"\n        Returns the height of the box\n\n        Returns:\n            int: The height of the box\n        return self.to_y - self.from_y\n        \"\"\"\n        return self.to_y - self.from_y\n\n    def extend(self, bounding_box) -&gt; None:\n        \"\"\"\n        Extends the bounding box. Modify the current object.\n\n        Args:\n            bounding_box (BoundingBox): The bounding box to extend\n\n        Returns:\n            None\n        \"\"\"\n        self.from_x = min(self.from_x, bounding_box.from_x)\n        self.from_y = min(self.from_y, bounding_box.from_y)\n        self.to_x = max(self.to_x, bounding_box.to_x)\n        self.to_y = max(self.to_y, bounding_box.to_y)\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a string representation of the bounding box\n\n        Returns (str): The string representation of the bounding box\n        \"\"\"\n        return f'(x={self.from_x}, y={self.from_y}, w={self.w()}, h={self.h()})'\n\n    def xywh(self) -&gt; str:\n        \"\"\"\n        Returns a string representation of the bounding box.\n\n        Returns:\n            str: The string representation of the bounding box\n        \"\"\"\n        return f'{self.from_x},{self.from_y},{self.w()},{self.h()}'\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBox.__init__","title":"<code>__init__(x, y, w, h)</code>","text":"<p>BoundingBox constructor.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>The x coordinate of the top left corner</p> required <code>y</code> <code>int</code> <p>The y coordinate of the top left corner</p> required <code>w</code> <code>int</code> <p>The width</p> required <code>h</code> <code>int</code> <p>The height</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, x, y, w, h):\n    \"\"\"\n    BoundingBox constructor.\n\n    Args:\n        x (int): The x coordinate of the top left corner\n        y (int): The y coordinate of the top left corner\n        w (int): The width\n        h (int): The height\n    \"\"\"\n    self.from_x = x\n    self.from_y = y\n    self.to_x = x + w\n    self.to_y = y + h\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBox.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the bounding box</p> <p>Returns (str): The string representation of the bounding box</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the bounding box\n\n    Returns (str): The string representation of the bounding box\n    \"\"\"\n    return f'(x={self.from_x}, y={self.from_y}, w={self.w()}, h={self.h()})'\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBox.extend","title":"<code>extend(bounding_box)</code>","text":"<p>Extends the bounding box. Modify the current object.</p> <p>Parameters:</p> Name Type Description Default <code>bounding_box</code> <code>BoundingBox</code> <p>The bounding box to extend</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def extend(self, bounding_box) -&gt; None:\n    \"\"\"\n    Extends the bounding box. Modify the current object.\n\n    Args:\n        bounding_box (BoundingBox): The bounding box to extend\n\n    Returns:\n        None\n    \"\"\"\n    self.from_x = min(self.from_x, bounding_box.from_x)\n    self.from_y = min(self.from_y, bounding_box.from_y)\n    self.to_x = max(self.to_x, bounding_box.to_x)\n    self.to_y = max(self.to_y, bounding_box.to_y)\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBox.h","title":"<code>h()</code>","text":"<p>Returns the height of the box</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The height of the box</p> <p>return self.to_y - self.from_y</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def h(self) -&gt; int:\n    \"\"\"\n    Returns the height of the box\n\n    Returns:\n        int: The height of the box\n    return self.to_y - self.from_y\n    \"\"\"\n    return self.to_y - self.from_y\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBox.w","title":"<code>w()</code>","text":"<p>Returns the width of the box</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The width of the box</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def w(self) -&gt; int:\n    \"\"\"\n    Returns the width of the box\n\n    Returns:\n        int: The width of the box\n    \"\"\"\n    return self.to_x - self.from_x\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBox.xywh","title":"<code>xywh()</code>","text":"<p>Returns a string representation of the bounding box.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation of the bounding box</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def xywh(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the bounding box.\n\n    Returns:\n        str: The string representation of the bounding box\n    \"\"\"\n    return f'{self.from_x},{self.from_y},{self.w()},{self.h()}'\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBoxMeasures","title":"<code>BoundingBoxMeasures</code>","text":"<p>BoundingBoxMeasures class.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>class BoundingBoxMeasures:\n    \"\"\"\n    BoundingBoxMeasures class.\n    \"\"\"\n\n    def __init__(\n            self,\n            bounding_box,\n            from_measure: int,\n            to_measure: int\n    ):\n        \"\"\"\n        Create an instance of BoundingBoxMeasures.\n\n        Args:\n            bounding_box: The bounding box object of the node.\n            from_measure (int): The first measure of the score in the BoundingBoxMeasures object.\n            to_measure (int): The last measure of the score in the BoundingBoxMeasures object.\n        \"\"\"\n        self.from_measure = from_measure\n        self.to_measure = to_measure\n        self.bounding_box = bounding_box\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBoxMeasures.__init__","title":"<code>__init__(bounding_box, from_measure, to_measure)</code>","text":"<p>Create an instance of BoundingBoxMeasures.</p> <p>Parameters:</p> Name Type Description Default <code>bounding_box</code> <p>The bounding box object of the node.</p> required <code>from_measure</code> <code>int</code> <p>The first measure of the score in the BoundingBoxMeasures object.</p> required <code>to_measure</code> <code>int</code> <p>The last measure of the score in the BoundingBoxMeasures object.</p> required Source code in <code>kernpy/core/document.py</code> <pre><code>def __init__(\n        self,\n        bounding_box,\n        from_measure: int,\n        to_measure: int\n):\n    \"\"\"\n    Create an instance of BoundingBoxMeasures.\n\n    Args:\n        bounding_box: The bounding box object of the node.\n        from_measure (int): The first measure of the score in the BoundingBoxMeasures object.\n        to_measure (int): The last measure of the score in the BoundingBoxMeasures object.\n    \"\"\"\n    self.from_measure = from_measure\n    self.to_measure = to_measure\n    self.bounding_box = bounding_box\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBoxToken","title":"<code>BoundingBoxToken</code>","text":"<p>               Bases: <code>Token</code></p> <p>BoundingBoxToken class.</p> <p>It contains the coordinates of the score bounding box. Useful for full-page tasks.</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> <code>page_number</code> <code>int</code> <p>The page number</p> <code>bounding_box</code> <code>BoundingBox</code> <p>The bounding box</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class BoundingBoxToken(Token):\n    \"\"\"\n    BoundingBoxToken class.\n\n    It contains the coordinates of the score bounding box. Useful for full-page tasks.\n\n    Attributes:\n        encoding (str): The complete unprocessed encoding\n        page_number (int): The page number\n        bounding_box (BoundingBox): The bounding box\n    \"\"\"\n\n    def __init__(\n            self,\n            encoding: str,\n            page_number: int,\n            bounding_box: BoundingBox\n    ):\n        \"\"\"\n        BoundingBoxToken constructor.\n\n        Args:\n            encoding (str): The complete unprocessed encoding\n            page_number (int): The page number\n            bounding_box (BoundingBox): The bounding box\n        \"\"\"\n        super().__init__(encoding, TokenCategory.BOUNDING_BOXES)\n        self.page_number = page_number\n        self.bounding_box = bounding_box\n\n    def export(self, **kwargs) -&gt; str:\n        return self.encoding\n</code></pre>"},{"location":"reference/#kernpy.core.BoundingBoxToken.__init__","title":"<code>__init__(encoding, page_number, bounding_box)</code>","text":"<p>BoundingBoxToken constructor.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>page_number</code> <code>int</code> <p>The page number</p> required <code>bounding_box</code> <code>BoundingBox</code> <p>The bounding box</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(\n        self,\n        encoding: str,\n        page_number: int,\n        bounding_box: BoundingBox\n):\n    \"\"\"\n    BoundingBoxToken constructor.\n\n    Args:\n        encoding (str): The complete unprocessed encoding\n        page_number (int): The page number\n        bounding_box (BoundingBox): The bounding box\n    \"\"\"\n    super().__init__(encoding, TokenCategory.BOUNDING_BOXES)\n    self.page_number = page_number\n    self.bounding_box = bounding_box\n</code></pre>"},{"location":"reference/#kernpy.core.C1Clef","title":"<code>C1Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class C1Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the C Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('C'), 1)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('C', 3)\n</code></pre>"},{"location":"reference/#kernpy.core.C1Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the C Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('C'), 1)\n</code></pre>"},{"location":"reference/#kernpy.core.C1Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('C', 3)\n</code></pre>"},{"location":"reference/#kernpy.core.C2Clef","title":"<code>C2Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class C2Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the C Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('A'), 2)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('A', 2)\n</code></pre>"},{"location":"reference/#kernpy.core.C2Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the C Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('A'), 2)\n</code></pre>"},{"location":"reference/#kernpy.core.C2Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('A', 2)\n</code></pre>"},{"location":"reference/#kernpy.core.C3Clef","title":"<code>C3Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class C3Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the C Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('C'), 3)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('B', 2)\n</code></pre>"},{"location":"reference/#kernpy.core.C3Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the C Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('C'), 3)\n</code></pre>"},{"location":"reference/#kernpy.core.C3Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('B', 2)\n</code></pre>"},{"location":"reference/#kernpy.core.C4Clef","title":"<code>C4Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class C4Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the C Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('C'), 4)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('D', 2)\n</code></pre>"},{"location":"reference/#kernpy.core.C4Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the C Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the C Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('C'), 4)\n</code></pre>"},{"location":"reference/#kernpy.core.C4Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('D', 2)\n</code></pre>"},{"location":"reference/#kernpy.core.ChordToken","title":"<code>ChordToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>ChordToken class.</p> <p>It contains a list of compound tokens</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class ChordToken(SimpleToken):\n    \"\"\"\n    ChordToken class.\n\n    It contains a list of compound tokens\n    \"\"\"\n\n    def __init__(self,\n                 encoding: str,\n                 category: TokenCategory,\n                 notes_tokens: Sequence[Token]\n                 ):\n        \"\"\"\n        ChordToken constructor.\n\n        Args:\n            encoding (str): The complete unprocessed encoding\n            category (TokenCategory): The token category, one of TokenCategory\n            notes_tokens (Sequence[Token]): The subtokens for the notes. Individual elements of the token, of type token\n        \"\"\"\n        super().__init__(encoding, category)\n        self.notes_tokens = notes_tokens\n\n    def export(self, **kwargs) -&gt; str:\n        result = ''\n        for note_token in self.notes_tokens:\n            if len(result) &gt; 0:\n                result += ' '\n\n            result += note_token.export()\n\n        return result\n</code></pre>"},{"location":"reference/#kernpy.core.ChordToken.__init__","title":"<code>__init__(encoding, category, notes_tokens)</code>","text":"<p>ChordToken constructor.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>category</code> <code>TokenCategory</code> <p>The token category, one of TokenCategory</p> required <code>notes_tokens</code> <code>Sequence[Token]</code> <p>The subtokens for the notes. Individual elements of the token, of type token</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self,\n             encoding: str,\n             category: TokenCategory,\n             notes_tokens: Sequence[Token]\n             ):\n    \"\"\"\n    ChordToken constructor.\n\n    Args:\n        encoding (str): The complete unprocessed encoding\n        category (TokenCategory): The token category, one of TokenCategory\n        notes_tokens (Sequence[Token]): The subtokens for the notes. Individual elements of the token, of type token\n    \"\"\"\n    super().__init__(encoding, category)\n    self.notes_tokens = notes_tokens\n</code></pre>"},{"location":"reference/#kernpy.core.Clef","title":"<code>Clef</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class representing a clef.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class Clef(ABC):\n    \"\"\"\n    Abstract class representing a clef.\n    \"\"\"\n\n    def __init__(self, diatonic_pitch: DiatonicPitch, on_line: int):\n        \"\"\"\n        Initializes the Clef object.\n        Args:\n            diatonic_pitch (DiatonicPitch): The diatonic pitch of the clef (e.g., 'C', 'G', 'F'). This value is used as a decorator.\n            on_line (int): The line number on which the clef is placed (1 for bottom line, 2 for 1st line from bottom, etc.). This value is used as a decorator.\n        \"\"\"\n        self.diatonic_pitch = diatonic_pitch\n        self.on_line = on_line\n\n    @abstractmethod\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        ...\n\n    def name(self):\n        \"\"\"\n        Returns the name of the clef.\n        \"\"\"\n        return f\"{self.diatonic_pitch} on line {self.on_line}\"\n\n    def reference_point(self) -&gt; PitchPositionReferenceSystem:\n        \"\"\"\n        Returns the reference point for the clef.\n        \"\"\"\n        return PitchPositionReferenceSystem(self.bottom_line())\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns:\n            str: The string representation of the clef.\n        \"\"\"\n        return f'{self.diatonic_pitch.encoding.upper()} on the {self.on_line}{self._ordinal_suffix(self.on_line)} line'\n\n    @staticmethod\n    def _ordinal_suffix(number: int) -&gt; str:\n        \"\"\"\n        Returns the ordinal suffix for a given integer (e.g. 'st', 'nd', 'rd', 'th').\n\n        Args:\n            number (int): The number to get the suffix for.\n\n        Returns:\n            str: The ordinal suffix.\n        \"\"\"\n        # 11, 12, 13 always take \u201cth\u201d\n        if 11 &lt;= (number % 100) &lt;= 13:\n            return 'th'\n        # otherwise use last digit\n        last = number % 10\n        if last == 1:\n            return 'st'\n        elif last == 2:\n            return 'nd'\n        elif last == 3:\n            return 'rd'\n        else:\n            return 'th'\n</code></pre>"},{"location":"reference/#kernpy.core.Clef.__init__","title":"<code>__init__(diatonic_pitch, on_line)</code>","text":"<p>Initializes the Clef object. Args:     diatonic_pitch (DiatonicPitch): The diatonic pitch of the clef (e.g., 'C', 'G', 'F'). This value is used as a decorator.     on_line (int): The line number on which the clef is placed (1 for bottom line, 2 for 1st line from bottom, etc.). This value is used as a decorator.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self, diatonic_pitch: DiatonicPitch, on_line: int):\n    \"\"\"\n    Initializes the Clef object.\n    Args:\n        diatonic_pitch (DiatonicPitch): The diatonic pitch of the clef (e.g., 'C', 'G', 'F'). This value is used as a decorator.\n        on_line (int): The line number on which the clef is placed (1 for bottom line, 2 for 1st line from bottom, etc.). This value is used as a decorator.\n    \"\"\"\n    self.diatonic_pitch = diatonic_pitch\n    self.on_line = on_line\n</code></pre>"},{"location":"reference/#kernpy.core.Clef.__str__","title":"<code>__str__()</code>","text":"<p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation of the clef.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns:\n        str: The string representation of the clef.\n    \"\"\"\n    return f'{self.diatonic_pitch.encoding.upper()} on the {self.on_line}{self._ordinal_suffix(self.on_line)} line'\n</code></pre>"},{"location":"reference/#kernpy.core.Clef.bottom_line","title":"<code>bottom_line()</code>  <code>abstractmethod</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>@abstractmethod\ndef bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/#kernpy.core.Clef.name","title":"<code>name()</code>","text":"<p>Returns the name of the clef.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def name(self):\n    \"\"\"\n    Returns the name of the clef.\n    \"\"\"\n    return f\"{self.diatonic_pitch} on line {self.on_line}\"\n</code></pre>"},{"location":"reference/#kernpy.core.Clef.reference_point","title":"<code>reference_point()</code>","text":"<p>Returns the reference point for the clef.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def reference_point(self) -&gt; PitchPositionReferenceSystem:\n    \"\"\"\n    Returns the reference point for the clef.\n    \"\"\"\n    return PitchPositionReferenceSystem(self.bottom_line())\n</code></pre>"},{"location":"reference/#kernpy.core.ClefFactory","title":"<code>ClefFactory</code>","text":"Source code in <code>kernpy/core/gkern.py</code> <pre><code>class ClefFactory:\n    CLEF_NAMES = { 'G', 'F', 'C' }\n    @classmethod\n    def create_clef(cls, encoding: str) -&gt; Clef:\n        \"\"\"\n        Creates a Clef object based on the given token.\n\n        Clefs are encoded in interpretation tokens that start with a single * followed by the string clef and then the shape and line position of the clef. For example, a treble clef is *clefG2, with G meaning a G-clef, and 2 meaning that the clef is centered on the second line up from the bottom of the staff. The bass clef is *clefF4 since it is an F-clef on the fourth line of the staff.\n        A vocal tenor clef is represented by *clefGv2, where the v means the music should be played an octave lower than the regular clef\u2019s sounding pitches. Try creating a vocal tenor clef in the above interactive example. The v operator also works on the other clefs (but these sorts of clefs are very rare). Another rare clef is *clefG^2 which is the opposite of *clefGv2, where the music is written an octave lower than actually sounding pitch for the normal form of the clef. You can also try to create exotic two-octave clefs by doubling the ^^ and vv markers.\n\n        Args:\n            encoding (str): The encoding of the clef token.\n\n        Returns:\n\n        \"\"\"\n        encoding = encoding.replace('*clef', '')\n\n        # at this point the encoding is like G2, F4,... or Gv2, F^4,... or G^^2, Fvv4,... or G^^...^^2, Fvvv4,...\n        name = list(filter(lambda x: x in cls.CLEF_NAMES, encoding))[0]\n        line = int(list(filter(lambda x: x.isdigit(), encoding))[0])\n        decorators = ''.join(filter(lambda x: x in ['^', 'v'], encoding))\n\n        if name not in cls.CLEF_NAMES:\n            raise ValueError(f\"Invalid clef name: {name}. Expected one of {cls.CLEF_NAMES}.\")\n\n        if name == 'G':\n            return GClef()\n        elif name == 'F':\n            if line == 3:\n                return F3Clef()\n            elif line == 4:\n                return F4Clef()\n            else:\n                raise ValueError(f\"Invalid F clef line: {line}. Expected 3 or 4.\")\n        elif name == 'C':\n            if line == 1:\n                return C1Clef()\n            elif line == 2:\n                return C2Clef()\n            elif line == 3:\n                return C3Clef()\n            elif line == 4:\n                return C4Clef()\n            else:\n                raise ValueError(f\"Invalid C clef line: {line}. Expected 1, 2, 3 or 4.\")\n        else:\n            raise ValueError(f\"Invalid clef name: {name}. Expected one of {cls.CLEF_NAMES}.\")\n</code></pre>"},{"location":"reference/#kernpy.core.ClefFactory.create_clef","title":"<code>create_clef(encoding)</code>  <code>classmethod</code>","text":"<p>Creates a Clef object based on the given token.</p> <p>Clefs are encoded in interpretation tokens that start with a single * followed by the string clef and then the shape and line position of the clef. For example, a treble clef is clefG2, with G meaning a G-clef, and 2 meaning that the clef is centered on the second line up from the bottom of the staff. The bass clef is clefF4 since it is an F-clef on the fourth line of the staff. A vocal tenor clef is represented by clefGv2, where the v means the music should be played an octave lower than the regular clef\u2019s sounding pitches. Try creating a vocal tenor clef in the above interactive example. The v operator also works on the other clefs (but these sorts of clefs are very rare). Another rare clef is clefG^2 which is the opposite of *clefGv2, where the music is written an octave lower than actually sounding pitch for the normal form of the clef. You can also try to create exotic two-octave clefs by doubling the ^^ and vv markers.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The encoding of the clef token.</p> required <p>Returns:</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>@classmethod\ndef create_clef(cls, encoding: str) -&gt; Clef:\n    \"\"\"\n    Creates a Clef object based on the given token.\n\n    Clefs are encoded in interpretation tokens that start with a single * followed by the string clef and then the shape and line position of the clef. For example, a treble clef is *clefG2, with G meaning a G-clef, and 2 meaning that the clef is centered on the second line up from the bottom of the staff. The bass clef is *clefF4 since it is an F-clef on the fourth line of the staff.\n    A vocal tenor clef is represented by *clefGv2, where the v means the music should be played an octave lower than the regular clef\u2019s sounding pitches. Try creating a vocal tenor clef in the above interactive example. The v operator also works on the other clefs (but these sorts of clefs are very rare). Another rare clef is *clefG^2 which is the opposite of *clefGv2, where the music is written an octave lower than actually sounding pitch for the normal form of the clef. You can also try to create exotic two-octave clefs by doubling the ^^ and vv markers.\n\n    Args:\n        encoding (str): The encoding of the clef token.\n\n    Returns:\n\n    \"\"\"\n    encoding = encoding.replace('*clef', '')\n\n    # at this point the encoding is like G2, F4,... or Gv2, F^4,... or G^^2, Fvv4,... or G^^...^^2, Fvvv4,...\n    name = list(filter(lambda x: x in cls.CLEF_NAMES, encoding))[0]\n    line = int(list(filter(lambda x: x.isdigit(), encoding))[0])\n    decorators = ''.join(filter(lambda x: x in ['^', 'v'], encoding))\n\n    if name not in cls.CLEF_NAMES:\n        raise ValueError(f\"Invalid clef name: {name}. Expected one of {cls.CLEF_NAMES}.\")\n\n    if name == 'G':\n        return GClef()\n    elif name == 'F':\n        if line == 3:\n            return F3Clef()\n        elif line == 4:\n            return F4Clef()\n        else:\n            raise ValueError(f\"Invalid F clef line: {line}. Expected 3 or 4.\")\n    elif name == 'C':\n        if line == 1:\n            return C1Clef()\n        elif line == 2:\n            return C2Clef()\n        elif line == 3:\n            return C3Clef()\n        elif line == 4:\n            return C4Clef()\n        else:\n            raise ValueError(f\"Invalid C clef line: {line}. Expected 1, 2, 3 or 4.\")\n    else:\n        raise ValueError(f\"Invalid clef name: {name}. Expected one of {cls.CLEF_NAMES}.\")\n</code></pre>"},{"location":"reference/#kernpy.core.ClefToken","title":"<code>ClefToken</code>","text":"<p>               Bases: <code>SignatureToken</code></p> <p>ClefToken class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class ClefToken(SignatureToken):\n    \"\"\"\n    ClefToken class.\n    \"\"\"\n\n    def __init__(self, encoding):\n        super().__init__(encoding, TokenCategory.CLEF)\n</code></pre>"},{"location":"reference/#kernpy.core.ComplexToken","title":"<code>ComplexToken</code>","text":"<p>               Bases: <code>Token</code>, <code>ABC</code></p> <p>Abstract ComplexToken class. This abstract class ensures that the subclasses implement the export method using     the 'filter_categories' parameter to filter the subtokens.</p> <p>Passing the argument 'filter_categories' by **kwargs don't break the compatibility with parent classes.</p> <p>Here we're trying to get the Liskov substitution principle done...</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class ComplexToken(Token, ABC):\n    \"\"\"\n    Abstract ComplexToken class. This abstract class ensures that the subclasses implement the export method using\\\n     the 'filter_categories' parameter to filter the subtokens.\n\n     Passing the argument 'filter_categories' by **kwargs don't break the compatibility with parent classes.\n\n     Here we're trying to get the Liskov substitution principle done...\n    \"\"\"\n    def __init__(self, encoding: str, category: TokenCategory):\n        \"\"\"\n        Constructor for the ComplexToken\n\n        Args:\n            encoding (str): The original representation of the token.\n            category (TokenCategory) : The category of the token.\n        \"\"\"\n        super().__init__(encoding, category)\n\n    @abstractmethod\n    def export(self, **kwargs) -&gt; str:\n        \"\"\"\n        Exports the token.\n\n        Keyword Arguments:\n            filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n                indicating whether the token should be included in the export. If provided, only tokens for which the\n                function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n        Returns (str): The exported token.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/#kernpy.core.ComplexToken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>Constructor for the ComplexToken</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>category</code> <code>TokenCategory) </code> <p>The category of the token.</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding: str, category: TokenCategory):\n    \"\"\"\n    Constructor for the ComplexToken\n\n    Args:\n        encoding (str): The original representation of the token.\n        category (TokenCategory) : The category of the token.\n    \"\"\"\n    super().__init__(encoding, category)\n</code></pre>"},{"location":"reference/#kernpy.core.ComplexToken.export","title":"<code>export(**kwargs)</code>  <code>abstractmethod</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@abstractmethod\ndef export(self, **kwargs) -&gt; str:\n    \"\"\"\n    Exports the token.\n\n    Keyword Arguments:\n        filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n            indicating whether the token should be included in the export. If provided, only tokens for which the\n            function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n    Returns (str): The exported token.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#kernpy.core.CompoundToken","title":"<code>CompoundToken</code>","text":"<p>               Bases: <code>ComplexToken</code></p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class CompoundToken(ComplexToken):\n    def __init__(self, encoding: str, category: TokenCategory, subtokens: List[Subtoken]):\n        \"\"\"\n        Args:\n            encoding (str): The complete unprocessed encoding\n            category (TokenCategory): The token category, one of 'TokenCategory'\n            subtokens (List[Subtoken]): The individual elements of the token. Also of type 'TokenCategory' but \\\n                in the hierarchy they must be children of the current token.\n        \"\"\"\n        super().__init__(encoding, category)\n\n        for subtoken in subtokens:\n            if not isinstance(subtoken, Subtoken):\n                raise ValueError(f'All subtokens must be instances of Subtoken. Found {type(subtoken)}')\n\n        self.subtokens = subtokens\n\n    def export(self, **kwargs) -&gt; str:\n        \"\"\"\n        Exports the token.\n\n        Keyword Arguments:\n            filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n                indicating whether the token should be included in the export. If provided, only tokens for which the\n                function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n        Returns (str): The exported token.\n        \"\"\"\n        filter_categories_fn = kwargs.get('filter_categories', None)\n        parts = []\n        for subtoken in self.subtokens:\n            # Only export the subtoken if it passes the filter_categories (if provided)\n            if filter_categories_fn is None or filter_categories_fn(subtoken.category):\n                # parts.append(subtoken.export(**kwargs)) in the future when SubTokens will be Tokens\n                parts.append(subtoken.encoding)\n        return TOKEN_SEPARATOR.join(parts) if len(parts) &gt; 0 else EMPTY_TOKEN\n</code></pre>"},{"location":"reference/#kernpy.core.CompoundToken.__init__","title":"<code>__init__(encoding, category, subtokens)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>category</code> <code>TokenCategory</code> <p>The token category, one of 'TokenCategory'</p> required <code>subtokens</code> <code>List[Subtoken]</code> <p>The individual elements of the token. Also of type 'TokenCategory' but                 in the hierarchy they must be children of the current token.</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding: str, category: TokenCategory, subtokens: List[Subtoken]):\n    \"\"\"\n    Args:\n        encoding (str): The complete unprocessed encoding\n        category (TokenCategory): The token category, one of 'TokenCategory'\n        subtokens (List[Subtoken]): The individual elements of the token. Also of type 'TokenCategory' but \\\n            in the hierarchy they must be children of the current token.\n    \"\"\"\n    super().__init__(encoding, category)\n\n    for subtoken in subtokens:\n        if not isinstance(subtoken, Subtoken):\n            raise ValueError(f'All subtokens must be instances of Subtoken. Found {type(subtoken)}')\n\n    self.subtokens = subtokens\n</code></pre>"},{"location":"reference/#kernpy.core.CompoundToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def export(self, **kwargs) -&gt; str:\n    \"\"\"\n    Exports the token.\n\n    Keyword Arguments:\n        filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n            indicating whether the token should be included in the export. If provided, only tokens for which the\n            function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n    Returns (str): The exported token.\n    \"\"\"\n    filter_categories_fn = kwargs.get('filter_categories', None)\n    parts = []\n    for subtoken in self.subtokens:\n        # Only export the subtoken if it passes the filter_categories (if provided)\n        if filter_categories_fn is None or filter_categories_fn(subtoken.category):\n            # parts.append(subtoken.export(**kwargs)) in the future when SubTokens will be Tokens\n            parts.append(subtoken.encoding)\n    return TOKEN_SEPARATOR.join(parts) if len(parts) &gt; 0 else EMPTY_TOKEN\n</code></pre>"},{"location":"reference/#kernpy.core.Document","title":"<code>Document</code>","text":"<p>Document class.</p> <p>This class store the score content using an agnostic tree structure.</p> <p>Attributes:</p> Name Type Description <code>tree</code> <code>MultistageTree</code> <p>The tree structure of the document where all the nodes are stored.             Each stage of the tree corresponds to a row in the Humdrum **kern file encoding.</p> <code>measure_start_tree_stages</code> <code>List[List[Node]]</code> <p>The list of nodes that corresponds to the measures.             Empty list by default. The index of the list is starting from 1. Rows after removing empty lines and line comments</p> <code>page_bounding_boxes</code> <code>Dict[int, BoundingBoxMeasures]</code> <p>The dictionary of page bounding boxes.             - key: page number - value: BoundingBoxMeasures object</p> <code>header_stage</code> <code>int</code> <p>The index of the stage that contains the headers. None by default.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>class Document:\n    \"\"\"\n    Document class.\n\n    This class store the score content using an agnostic tree structure.\n\n    Attributes:\n        tree (MultistageTree): The tree structure of the document where all the nodes are stored. \\\n            Each stage of the tree corresponds to a row in the Humdrum **kern file encoding.\n        measure_start_tree_stages (List[List[Node]]): The list of nodes that corresponds to the measures. \\\n            Empty list by default.\n            The index of the list is starting from 1. Rows after removing empty lines and line comments\n        page_bounding_boxes (Dict[int, BoundingBoxMeasures]): The dictionary of page bounding boxes. \\\n            - key: page number\n            - value: BoundingBoxMeasures object\n        header_stage (int): The index of the stage that contains the headers. None by default.\n    \"\"\"\n\n    def __init__(self, tree: MultistageTree):\n        \"\"\"\n        Constructor for Document class.\n\n        Args:\n            tree (MultistageTree): The tree structure of the document where all the nodes are stored.\n        \"\"\"\n        self.tree = tree  # TODO: ? Should we use copy.deepcopy() here?\n        self.measure_start_tree_stages = []\n        self.page_bounding_boxes = {}\n        self.header_stage = None\n\n    FIRST_MEASURE = 1\n\n    def get_header_stage(self) -&gt; Union[List[Node], List[List[Node]]]:\n        \"\"\"\n        Get the Node list of the header stage.\n\n        Returns: (Union[List[Node], List[List[Node]]]) The Node list of the header stage.\n\n        Raises: Exception - If the document has no header stage.\n        \"\"\"\n        if self.header_stage:\n            return self.tree.stages[self.header_stage]\n        else:\n            raise Exception('No header stage found')\n\n    def get_leaves(self) -&gt; List[Node]:\n        \"\"\"\n        Get the leaves of the tree.\n\n        Returns: (List[Node]) The leaves of the tree.\n        \"\"\"\n        return self.tree.stages[len(self.tree.stages) - 1]\n\n    def get_spine_count(self) -&gt; int:\n        \"\"\"\n        Get the number of spines in the document.\n\n        Returns (int): The number of spines in the document.\n        \"\"\"\n        return len(self.get_header_stage())  # TODO: test refactor\n\n    def get_first_measure(self) -&gt; int:\n        \"\"\"\n        Get the index of the first measure of the document.\n\n        Returns: (Int) The index of the first measure of the document.\n\n        Raises: Exception - If the document has no measures.\n\n        Examples:\n            &gt;&gt;&gt; import kernpy as kp\n            &gt;&gt;&gt; document, err = kp.read('score.krn')\n            &gt;&gt;&gt; document.get_first_measure()\n            1\n        \"\"\"\n        if len(self.measure_start_tree_stages) == 0:\n            raise Exception('No measures found')\n\n        return self.FIRST_MEASURE\n\n    def measures_count(self) -&gt; int:\n        \"\"\"\n        Get the index of the last measure of the document.\n\n        Returns: (Int) The index of the last measure of the document.\n\n        Raises: Exception - If the document has no measures.\n\n        Examples:\n            &gt;&gt;&gt; document, _ = kernpy.read('score.krn')\n            &gt;&gt;&gt; document.measures_count()\n            10\n            &gt;&gt;&gt; for i in range(document.get_first_measure(), document.measures_count() + 1):\n            &gt;&gt;&gt;   options = kernpy.ExportOptions(from_measure=i, to_measure=i+4)\n        \"\"\"\n        if len(self.measure_start_tree_stages) == 0:\n            raise Exception('No measures found')\n\n        return len(self.measure_start_tree_stages)\n\n    def get_metacomments(self, KeyComment: Optional[str] = None, clear: bool = False) -&gt; List[str]:\n        \"\"\"\n        Get all metacomments in the document\n\n        Args:\n            KeyComment: Filter by a specific metacomment key: e.g. Use 'COM' to get only comments starting with\\\n                '!!!COM: '. If None, all metacomments are returned.\n            clear: If True, the metacomment key is removed from the comment. E.g. '!!!COM: Coltrane' -&gt; 'Coltrane'.\\\n                If False, the metacomment key is kept. E.g. '!!!COM: Coltrane' -&gt; '!!!COM: Coltrane'. \\\n                The clear functionality is equivalent to the following code:\n                ```python\n                comment = '!!!COM: Coltrane'\n                clean_comment = comment.replace(f\"!!!{KeyComment}: \", \"\")\n                ```\n                Other formats are not supported.\n\n        Returns: A list of metacomments.\n\n        Examples:\n            &gt;&gt;&gt; document.get_metacomments()\n            ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n            &gt;&gt;&gt; document.get_metacomments(KeyComment='COM')\n            ['!!!COM: Coltrane']\n            &gt;&gt;&gt; document.get_metacomments(KeyComment='COM', clear=True)\n            ['Coltrane']\n            &gt;&gt;&gt; document.get_metacomments(KeyComment='non_existing_key')\n            []\n        \"\"\"\n        traversal = MetacommentsTraversal()\n        self.tree.dfs_iterative(traversal)\n        result = []\n        for metacomment in traversal.metacomments:\n            if KeyComment is None or metacomment.encoding.startswith(f\"!!!{KeyComment}\"):\n                new_comment = metacomment.encoding\n                if clear:\n                    new_comment = metacomment.encoding.replace(f\"!!!{KeyComment}: \", \"\")\n                result.append(new_comment)\n\n        return result\n\n    @classmethod\n    def tokens_to_encodings(cls, tokens: Sequence[AbstractToken]):\n        \"\"\"\n        Get the encodings of a list of tokens.\n\n        The method is equivalent to the following code:\n            &gt;&gt;&gt; tokens = kp.get_all_tokens()\n            &gt;&gt;&gt; [token.encoding for token in tokens if token.encoding is not None]\n\n        Args:\n            tokens (Sequence[AbstractToken]): list - A list of tokens.\n\n        Returns: List[str] - A list of token encodings.\n\n        Examples:\n            &gt;&gt;&gt; tokens = document.get_all_tokens()\n            &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n            ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n        \"\"\"\n        encodings = [token.encoding for token in tokens if token.encoding is not None]\n        return encodings\n\n    def get_all_tokens(self, filter_by_categories: Optional[Sequence[TokenCategory]] = None) -&gt; List[AbstractToken]:\n        \"\"\"\n        Args:\n            filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n        Returns:\n            List[AbstractToken] - A list of all tokens.\n\n        Examples:\n            &gt;&gt;&gt; tokens = document.get_all_tokens()\n            &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n            &gt;&gt;&gt; [type(t) for t in tokens]\n            [&lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;]\n        \"\"\"\n        computed_categories = TokenCategory.valid(include=filter_by_categories)\n        traversal = TokensTraversal(False, computed_categories)\n        self.tree.dfs_iterative(traversal)\n        return traversal.tokens\n\n    def get_all_tokens_encodings(\n            self,\n            filter_by_categories: Optional[Sequence[TokenCategory]] = None\n    ) -&gt; List[str]:\n        \"\"\"\n        Args:\n            filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n\n        Returns:\n            list[str] - A list of all token encodings.\n\n        Examples:\n            &gt;&gt;&gt; tokens = document.get_all_tokens_encodings()\n            &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n            ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n        \"\"\"\n        tokens = self.get_all_tokens(filter_by_categories)\n        return Document.tokens_to_encodings(tokens)\n\n    def get_unique_tokens(\n            self,\n            filter_by_categories: Optional[Sequence[TokenCategory]] = None\n    ) -&gt; List[AbstractToken]:\n        \"\"\"\n        Get unique tokens.\n\n        Args:\n            filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n        Returns:\n            List[AbstractToken] - A list of unique tokens.\n\n        \"\"\"\n        computed_categories = TokenCategory.valid(include=filter_by_categories)\n        traversal = TokensTraversal(True, computed_categories)\n        self.tree.dfs_iterative(traversal)\n        return traversal.tokens\n\n    def get_unique_token_encodings(\n            self,\n            filter_by_categories: Optional[Sequence[TokenCategory]] = None\n    ) -&gt; List[str]:\n        \"\"\"\n        Get unique token encodings.\n\n        Args:\n            filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n        Returns: List[str] - A list of unique token encodings.\n\n        \"\"\"\n        tokens = self.get_unique_tokens(filter_by_categories)\n        return Document.tokens_to_encodings(tokens)\n\n    def get_voices(self, clean: bool = False):\n        \"\"\"\n        Get the voices of the document.\n\n        Args\n            clean (bool): Remove the first '!' from the voice name.\n\n        Returns: A list of voices.\n\n        Examples:\n            &gt;&gt;&gt; document.get_voices()\n            ['!sax', '!piano', '!bass']\n            &gt;&gt;&gt; document.get_voices(clean=True)\n            ['sax', 'piano', 'bass']\n            &gt;&gt;&gt; document.get_voices(clean=False)\n            ['!sax', '!piano', '!bass']\n        \"\"\"\n        from kernpy.core import TokenCategory\n        voices = self.get_all_tokens(filter_by_categories=[TokenCategory.INSTRUMENTS])\n\n        if clean:\n            voices = [voice[1:] for voice in voices]\n        return voices\n\n    def clone(self):\n        \"\"\"\n        Create a deep copy of the Document instance.\n\n        Returns: A new instance of Document with the tree copied.\n\n        \"\"\"\n        result = Document(copy(self.tree))\n        result.measure_start_tree_stages = copy(self.measure_start_tree_stages)\n        result.page_bounding_boxes = copy(self.page_bounding_boxes)\n        result.header_stage = copy(self.header_stage)\n\n        return result\n\n    def append_spines(self, spines) -&gt; None:\n        \"\"\"\n        Append the spines directly to current document tree.\n\n        Args:\n            spines(list): A list of spines to append.\n\n        Returns: None\n\n        Examples:\n            &gt;&gt;&gt; import kernpy as kp\n            &gt;&gt;&gt; doc, _ = kp.read('score.krn')\n            &gt;&gt;&gt; spines = [\n            &gt;&gt;&gt; '4e\\t4f\\t4g\\t4a\\n4b\\t4c\\t4d\\t4e\\n=\\t=\\t=\\t=\\n',\n            &gt;&gt;&gt; '4c\\t4d\\t4e\\t4f\\n4g\\t4a\\t4b\\t4c\\n=\\t=\\t=\\t=\\n',\n           &gt;&gt;&gt; ]\n           &gt;&gt;&gt; doc.append_spines(spines)\n           None\n        \"\"\"\n        raise NotImplementedError()\n        if len(spines) != self.get_spine_count():\n            raise Exception(f\"Spines count mismatch: {len(spines)} != {self.get_spine_count()}\")\n\n        for spine in spines:\n            return\n\n    def add(self, other: 'Document', *, check_core_spines_only: Optional[bool] = False) -&gt; 'Document':\n        \"\"\"\n        Concatenate one document to the current document: Modify the current object!\n\n        Args:\n            other: The document to concatenate.\n            check_core_spines_only: If True, only the core spines (**kern and **mens) are checked. If False, all spines are checked.\n\n        Returns ('Document'): The current document (self) with the other document concatenated.\n        \"\"\"\n        if not Document.match(self, other, check_core_spines_only=check_core_spines_only):\n            raise Exception(f'Documents are not compatible for addition. '\n                            f'Headers do not match with check_core_spines_only={check_core_spines_only}. '\n                            f'self: {self.get_header_nodes()}, other: {other.get_header_nodes()}. ')\n\n        current_header_nodes = self.get_header_stage()\n        other_header_nodes = other.get_header_stage()\n\n        current_leaf_nodes = self.get_leaves()\n        flatten = lambda lst: [item for sublist in lst for item in sublist]\n        other_first_level_children = [flatten(c.children) for c in other_header_nodes]  # avoid header stage\n\n        for current_leaf, other_first_level_child in zip(current_leaf_nodes, other_first_level_children, strict=False):\n            # Ignore extra spines from other document.\n            # But if there are extra spines in the current document, it will raise an exception.\n            if current_leaf.token.encoding == TERMINATOR:\n                # remove the '*-' token from the current document\n                current_leaf_index = current_leaf.parent.children.index(current_leaf)\n                current_leaf.parent.children.pop(current_leaf_index)\n                current_leaf.parent.children.insert(current_leaf_index, other_first_level_child)\n\n            self.tree.add_node(\n                stage=len(self.tree.stages) - 1,  # TODO: check offset 0, +1, -1 ????\n                parent=current_leaf,\n                token=other_first_level_child.token,\n                last_spine_operator_node=other_first_level_child.last_spine_operator_node,\n                previous_signature_nodes=other_first_level_child.last_signature_nodes,\n                header_node=other_first_level_child.header_node\n            )\n\n        return self\n\n    def get_header_nodes(self) -&gt; List[HeaderToken]:\n        \"\"\"\n        Get the header nodes of the current document.\n\n        Returns: List[HeaderToken]: A list with the header nodes of the current document.\n        \"\"\"\n        return [token for token in self.get_all_tokens(filter_by_categories=None) if isinstance(token, HeaderToken)]\n\n    def get_spine_ids(self) -&gt; List[int]:\n        \"\"\"\n                Get the indexes of the current document.\n\n                Returns List[int]: A list with the indexes of the current document.\n\n                Examples:\n                    &gt;&gt;&gt; document.get_all_spine_indexes()\n                    [0, 1, 2, 3, 4]\n                \"\"\"\n        header_nodes = self.get_header_nodes()\n        return [node.spine_id for node in header_nodes]\n\n    def frequencies(self, token_categories: Optional[Sequence[TokenCategory]] = None) -&gt; Dict:\n        \"\"\"\n        Frequency of tokens in the document.\n\n\n        Args:\n            token_categories (Optional[Sequence[TokenCategory]]): If None, all tokens are considered.\n        Returns (Dict):\n            A dictionary with the category and the number of occurrences of each token.\n\n        \"\"\"\n        tokens = self.get_all_tokens(filter_by_categories=token_categories)\n        frequencies = {}\n        for t in tokens:\n            if t.encoding in frequencies:\n                frequencies[t.encoding]['occurrences'] += 1\n            else:\n                frequencies[t.encoding] = {\n                    'occurrences': 1,\n                    'category': t.category.name,\n                }\n\n        return frequencies\n\n    def split(self) -&gt; List['Document']:\n        \"\"\"\n        Split the current document into a list of documents, one for each **kern spine.\n        Each resulting document will contain one **kern spine along with all non-kern spines.\n\n        Returns:\n            List['Document']: A list of documents, where each document contains one **kern spine\n            and all non-kern spines from the original document.\n\n        Examples:\n            &gt;&gt;&gt; document.split()\n            [&lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;]\n        \"\"\"\n        raise NotImplementedError\n        new_documents = []\n        self_document_copy = deepcopy(self)\n        kern_header_nodes = [node for node in self_document_copy.get_header_nodes() if node.encoding == '**kern']\n        other_header_nodes = [node for node in self_document_copy.get_header_nodes() if node.encoding != '**kern']\n        spine_ids = self_document_copy.get_spine_ids()\n\n        for header_node in kern_header_nodes:\n            if header_node.spine_id not in spine_ids:\n                continue\n\n            spine_ids.remove(header_node.spine_id)\n\n            new_tree = deepcopy(self.tree)\n            prev_node = new_tree.root\n            while not isinstance(prev_node, HeaderToken):\n                prev_node = prev_node.children[0]\n\n            if not prev_node or not isinstance(prev_node, HeaderToken):\n                raise Exception(f'Header node not found: {prev_node} in {header_node}')\n\n            new_children = list(filter(lambda x: x.spine_id == header_node.spine_id, prev_node.children))\n            new_tree.root = new_children\n\n            new_document = Document(new_tree)\n\n            new_documents.append(new_document)\n\n        return new_documents\n\n    @classmethod\n    def to_concat(cls, first_doc: 'Document', second_doc: 'Document', deep_copy: bool = True) -&gt; 'Document':\n        \"\"\"\n        Concatenate two documents.\n\n        Args:\n            first_doc (Document): The first document.\n            second_doc (Document: The second document.\n            deep_copy (bool): If True, the documents are deep copied. If False, the documents are shallow copied.\n\n        Returns: A new instance of Document with the documents concatenated.\n        \"\"\"\n        first_doc = first_doc.clone() if deep_copy else first_doc\n        second_doc = second_doc.clone() if deep_copy else second_doc\n        first_doc.add(second_doc)\n\n        return first_doc\n\n    @classmethod\n    def match(cls, a: 'Document', b: 'Document', *, check_core_spines_only: Optional[bool] = False) -&gt; bool:\n        \"\"\"\n        Match two documents. Two documents match if they have the same spine structure.\n\n        Args:\n            a (Document): The first document.\n            b (Document): The second document.\n            check_core_spines_only (Optional[bool]): If True, only the core spines (**kern and **mens) are checked. If False, all spines are checked.\n\n        Returns: True if the documents match, False otherwise.\n\n        Examples:\n\n        \"\"\"\n        if check_core_spines_only:\n            return [token.encoding for token in a.get_header_nodes() if token.encoding in CORE_HEADERS] \\\n                == [token.encoding for token in b.get_header_nodes() if token.encoding in CORE_HEADERS]\n        else:\n            return [token.encoding for token in a.get_header_nodes()] \\\n                == [token.encoding for token in b.get_header_nodes()]\n\n\n    def to_transposed(self, interval: str, direction: str = Direction.UP.value) -&gt; 'Document':\n        \"\"\"\n        Create a new document with the transposed notes without modifying the original document.\n\n        Args:\n            interval (str): The name of the interval to transpose. It can be 'P4', 'P5', 'M2', etc. Check the \\\n             kp.AVAILABLE_INTERVALS for the available intervals.\n            direction (str): The direction to transpose. It can be 'up' or 'down'.\n\n        Returns:\n\n        \"\"\"\n        if interval not in AVAILABLE_INTERVALS:\n            raise ValueError(\n                f\"Interval {interval!r} is not available. \"\n                f\"Available intervals are: {AVAILABLE_INTERVALS}\"\n            )\n\n        if direction not in (Direction.UP.value, Direction.DOWN.value):\n            raise ValueError(\n                f\"Direction {direction!r} is not available. \"\n                f\"Available directions are: \"\n                f\"{Direction.UP.value!r}, {Direction.DOWN.value!r}\"\n            )\n\n        new_document = self.clone()\n\n        # BFS through the tree\n        root = new_document.tree.root\n        queue = Queue()\n        queue.put(root)\n\n        while not queue.empty():\n            node = queue.get()\n\n            if isinstance(node.token, NoteRestToken):\n                orig_token = node.token\n\n                new_subtokens = []\n                transposed_pitch_encoding = None\n\n                # Transpose each pitch subtoken in the pitch\u2013duration list\n                for subtoken in orig_token.pitch_duration_subtokens:\n                    if subtoken.category == TokenCategory.PITCH:\n                        # transpose() returns a new pitch subtoken\n                        tp = transpose(\n                            input_encoding=subtoken.encoding,\n                            interval=IntervalsByName[interval],\n                            direction=direction,\n                            input_format=NotationEncoding.HUMDRUM.value,\n                            output_format=NotationEncoding.HUMDRUM.value,\n                        )\n                        new_subtokens.append(Subtoken(tp, subtoken.category))\n                        transposed_pitch_encoding = tp\n                    else:\n                        # leave duration subtokens untouched\n                        new_subtokens.append(Subtoken(subtoken.encoding, subtoken.category))\n\n                # Replace the node\u2019s token with a new NoteRestToken\n                node.token = NoteRestToken(\n                    encoding=transposed_pitch_encoding,\n                    pitch_duration_subtokens=new_subtokens,\n                    decoration_subtokens=orig_token.decoration_subtokens,\n                )\n\n            # enqueue children\n            for child in node.children:\n                queue.put(child)\n\n        # Return the transposed clone\n        return new_document\n\n\n    def __iter__(self):\n        \"\"\"\n        Get the indexes to export all the document.\n\n        Returns: An iterator with the indexes to export the document.\n        \"\"\"\n        return iter(range(self.get_first_measure(), self.measures_count() + 1))\n\n    def __next__(self):\n        \"\"\"\n        Get the next index to export the document.\n\n        Returns: The next index to export the document.\n        \"\"\"\n        return next(iter(range(self.get_first_measure(), self.measures_count() + 1)))\n</code></pre>"},{"location":"reference/#kernpy.core.Document.__init__","title":"<code>__init__(tree)</code>","text":"<p>Constructor for Document class.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>MultistageTree</code> <p>The tree structure of the document where all the nodes are stored.</p> required Source code in <code>kernpy/core/document.py</code> <pre><code>def __init__(self, tree: MultistageTree):\n    \"\"\"\n    Constructor for Document class.\n\n    Args:\n        tree (MultistageTree): The tree structure of the document where all the nodes are stored.\n    \"\"\"\n    self.tree = tree  # TODO: ? Should we use copy.deepcopy() here?\n    self.measure_start_tree_stages = []\n    self.page_bounding_boxes = {}\n    self.header_stage = None\n</code></pre>"},{"location":"reference/#kernpy.core.Document.__iter__","title":"<code>__iter__()</code>","text":"<p>Get the indexes to export all the document.</p> <p>Returns: An iterator with the indexes to export the document.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def __iter__(self):\n    \"\"\"\n    Get the indexes to export all the document.\n\n    Returns: An iterator with the indexes to export the document.\n    \"\"\"\n    return iter(range(self.get_first_measure(), self.measures_count() + 1))\n</code></pre>"},{"location":"reference/#kernpy.core.Document.__next__","title":"<code>__next__()</code>","text":"<p>Get the next index to export the document.</p> <p>Returns: The next index to export the document.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def __next__(self):\n    \"\"\"\n    Get the next index to export the document.\n\n    Returns: The next index to export the document.\n    \"\"\"\n    return next(iter(range(self.get_first_measure(), self.measures_count() + 1)))\n</code></pre>"},{"location":"reference/#kernpy.core.Document.add","title":"<code>add(other, *, check_core_spines_only=False)</code>","text":"<p>Concatenate one document to the current document: Modify the current object!</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'Document'</code> <p>The document to concatenate.</p> required <code>check_core_spines_only</code> <code>Optional[bool]</code> <p>If True, only the core spines (kern and mens) are checked. If False, all spines are checked.</p> <code>False</code> <p>Returns ('Document'): The current document (self) with the other document concatenated.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def add(self, other: 'Document', *, check_core_spines_only: Optional[bool] = False) -&gt; 'Document':\n    \"\"\"\n    Concatenate one document to the current document: Modify the current object!\n\n    Args:\n        other: The document to concatenate.\n        check_core_spines_only: If True, only the core spines (**kern and **mens) are checked. If False, all spines are checked.\n\n    Returns ('Document'): The current document (self) with the other document concatenated.\n    \"\"\"\n    if not Document.match(self, other, check_core_spines_only=check_core_spines_only):\n        raise Exception(f'Documents are not compatible for addition. '\n                        f'Headers do not match with check_core_spines_only={check_core_spines_only}. '\n                        f'self: {self.get_header_nodes()}, other: {other.get_header_nodes()}. ')\n\n    current_header_nodes = self.get_header_stage()\n    other_header_nodes = other.get_header_stage()\n\n    current_leaf_nodes = self.get_leaves()\n    flatten = lambda lst: [item for sublist in lst for item in sublist]\n    other_first_level_children = [flatten(c.children) for c in other_header_nodes]  # avoid header stage\n\n    for current_leaf, other_first_level_child in zip(current_leaf_nodes, other_first_level_children, strict=False):\n        # Ignore extra spines from other document.\n        # But if there are extra spines in the current document, it will raise an exception.\n        if current_leaf.token.encoding == TERMINATOR:\n            # remove the '*-' token from the current document\n            current_leaf_index = current_leaf.parent.children.index(current_leaf)\n            current_leaf.parent.children.pop(current_leaf_index)\n            current_leaf.parent.children.insert(current_leaf_index, other_first_level_child)\n\n        self.tree.add_node(\n            stage=len(self.tree.stages) - 1,  # TODO: check offset 0, +1, -1 ????\n            parent=current_leaf,\n            token=other_first_level_child.token,\n            last_spine_operator_node=other_first_level_child.last_spine_operator_node,\n            previous_signature_nodes=other_first_level_child.last_signature_nodes,\n            header_node=other_first_level_child.header_node\n        )\n\n    return self\n</code></pre>"},{"location":"reference/#kernpy.core.Document.append_spines","title":"<code>append_spines(spines)</code>","text":"<pre><code>    Append the spines directly to current document tree.\n\n    Args:\n        spines(list): A list of spines to append.\n\n    Returns: None\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; doc, _ = kp.read('score.krn')\n        &gt;&gt;&gt; spines = [\n        &gt;&gt;&gt; '4e     4f      4g      4a\n</code></pre> <p>4b      4c      4d      4e =       =       =       = ',             &gt;&gt;&gt; '4c     4d      4e      4f 4g      4a      4b      4c =       =       =       = ',            &gt;&gt;&gt; ]            &gt;&gt;&gt; doc.append_spines(spines)            None</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def append_spines(self, spines) -&gt; None:\n    \"\"\"\n    Append the spines directly to current document tree.\n\n    Args:\n        spines(list): A list of spines to append.\n\n    Returns: None\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; doc, _ = kp.read('score.krn')\n        &gt;&gt;&gt; spines = [\n        &gt;&gt;&gt; '4e\\t4f\\t4g\\t4a\\n4b\\t4c\\t4d\\t4e\\n=\\t=\\t=\\t=\\n',\n        &gt;&gt;&gt; '4c\\t4d\\t4e\\t4f\\n4g\\t4a\\t4b\\t4c\\n=\\t=\\t=\\t=\\n',\n       &gt;&gt;&gt; ]\n       &gt;&gt;&gt; doc.append_spines(spines)\n       None\n    \"\"\"\n    raise NotImplementedError()\n    if len(spines) != self.get_spine_count():\n        raise Exception(f\"Spines count mismatch: {len(spines)} != {self.get_spine_count()}\")\n\n    for spine in spines:\n        return\n</code></pre>"},{"location":"reference/#kernpy.core.Document.clone","title":"<code>clone()</code>","text":"<p>Create a deep copy of the Document instance.</p> <p>Returns: A new instance of Document with the tree copied.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def clone(self):\n    \"\"\"\n    Create a deep copy of the Document instance.\n\n    Returns: A new instance of Document with the tree copied.\n\n    \"\"\"\n    result = Document(copy(self.tree))\n    result.measure_start_tree_stages = copy(self.measure_start_tree_stages)\n    result.page_bounding_boxes = copy(self.page_bounding_boxes)\n    result.header_stage = copy(self.header_stage)\n\n    return result\n</code></pre>"},{"location":"reference/#kernpy.core.Document.frequencies","title":"<code>frequencies(token_categories=None)</code>","text":"<p>Frequency of tokens in the document.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>If None, all tokens are considered.</p> <code>None</code> <p>Returns (Dict):     A dictionary with the category and the number of occurrences of each token.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def frequencies(self, token_categories: Optional[Sequence[TokenCategory]] = None) -&gt; Dict:\n    \"\"\"\n    Frequency of tokens in the document.\n\n\n    Args:\n        token_categories (Optional[Sequence[TokenCategory]]): If None, all tokens are considered.\n    Returns (Dict):\n        A dictionary with the category and the number of occurrences of each token.\n\n    \"\"\"\n    tokens = self.get_all_tokens(filter_by_categories=token_categories)\n    frequencies = {}\n    for t in tokens:\n        if t.encoding in frequencies:\n            frequencies[t.encoding]['occurrences'] += 1\n        else:\n            frequencies[t.encoding] = {\n                'occurrences': 1,\n                'category': t.category.name,\n            }\n\n    return frequencies\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_all_tokens","title":"<code>get_all_tokens(filter_by_categories=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AbstractToken]</code> <p>List[AbstractToken] - A list of all tokens.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n&gt;&gt;&gt; [type(t) for t in tokens]\n[&lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;]\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_all_tokens(self, filter_by_categories: Optional[Sequence[TokenCategory]] = None) -&gt; List[AbstractToken]:\n    \"\"\"\n    Args:\n        filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n    Returns:\n        List[AbstractToken] - A list of all tokens.\n\n    Examples:\n        &gt;&gt;&gt; tokens = document.get_all_tokens()\n        &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n        &gt;&gt;&gt; [type(t) for t in tokens]\n        [&lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;, &lt;class 'kernpy.core.token.Token'&gt;]\n    \"\"\"\n    computed_categories = TokenCategory.valid(include=filter_by_categories)\n    traversal = TokensTraversal(False, computed_categories)\n    self.tree.dfs_iterative(traversal)\n    return traversal.tokens\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_all_tokens_encodings","title":"<code>get_all_tokens_encodings(filter_by_categories=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str] - A list of all token encodings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens_encodings()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_all_tokens_encodings(\n        self,\n        filter_by_categories: Optional[Sequence[TokenCategory]] = None\n) -&gt; List[str]:\n    \"\"\"\n    Args:\n        filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n\n    Returns:\n        list[str] - A list of all token encodings.\n\n    Examples:\n        &gt;&gt;&gt; tokens = document.get_all_tokens_encodings()\n        &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n        ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n    \"\"\"\n    tokens = self.get_all_tokens(filter_by_categories)\n    return Document.tokens_to_encodings(tokens)\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_first_measure","title":"<code>get_first_measure()</code>","text":"<p>Get the index of the first measure of the document.</p> <p>Returns: (Int) The index of the first measure of the document.</p> <p>Raises: Exception - If the document has no measures.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, err = kp.read('score.krn')\n&gt;&gt;&gt; document.get_first_measure()\n1\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_first_measure(self) -&gt; int:\n    \"\"\"\n    Get the index of the first measure of the document.\n\n    Returns: (Int) The index of the first measure of the document.\n\n    Raises: Exception - If the document has no measures.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, err = kp.read('score.krn')\n        &gt;&gt;&gt; document.get_first_measure()\n        1\n    \"\"\"\n    if len(self.measure_start_tree_stages) == 0:\n        raise Exception('No measures found')\n\n    return self.FIRST_MEASURE\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_header_nodes","title":"<code>get_header_nodes()</code>","text":"<p>Get the header nodes of the current document.</p> <p>Returns: List[HeaderToken]: A list with the header nodes of the current document.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_header_nodes(self) -&gt; List[HeaderToken]:\n    \"\"\"\n    Get the header nodes of the current document.\n\n    Returns: List[HeaderToken]: A list with the header nodes of the current document.\n    \"\"\"\n    return [token for token in self.get_all_tokens(filter_by_categories=None) if isinstance(token, HeaderToken)]\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_header_stage","title":"<code>get_header_stage()</code>","text":"<p>Get the Node list of the header stage.</p> <p>Returns: (Union[List[Node], List[List[Node]]]) The Node list of the header stage.</p> <p>Raises: Exception - If the document has no header stage.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_header_stage(self) -&gt; Union[List[Node], List[List[Node]]]:\n    \"\"\"\n    Get the Node list of the header stage.\n\n    Returns: (Union[List[Node], List[List[Node]]]) The Node list of the header stage.\n\n    Raises: Exception - If the document has no header stage.\n    \"\"\"\n    if self.header_stage:\n        return self.tree.stages[self.header_stage]\n    else:\n        raise Exception('No header stage found')\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_leaves","title":"<code>get_leaves()</code>","text":"<p>Get the leaves of the tree.</p> <p>Returns: (List[Node]) The leaves of the tree.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_leaves(self) -&gt; List[Node]:\n    \"\"\"\n    Get the leaves of the tree.\n\n    Returns: (List[Node]) The leaves of the tree.\n    \"\"\"\n    return self.tree.stages[len(self.tree.stages) - 1]\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_metacomments","title":"<code>get_metacomments(KeyComment=None, clear=False)</code>","text":"<p>Get all metacomments in the document</p> <p>Parameters:</p> Name Type Description Default <code>KeyComment</code> <code>Optional[str]</code> <p>Filter by a specific metacomment key: e.g. Use 'COM' to get only comments starting with                '!!!COM: '. If None, all metacomments are returned.</p> <code>None</code> <code>clear</code> <code>bool</code> <p>If True, the metacomment key is removed from the comment. E.g. '!!!COM: Coltrane' -&gt; 'Coltrane'.                If False, the metacomment key is kept. E.g. '!!!COM: Coltrane' -&gt; '!!!COM: Coltrane'.                 The clear functionality is equivalent to the following code:</p> <pre><code>comment = '!!!COM: Coltrane'\nclean_comment = comment.replace(f\"!!!{KeyComment}: \", \"\")\n</code></pre> <p>Other formats are not supported.</p> <code>False</code> <p>Returns: A list of metacomments.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_metacomments()\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='COM')\n['!!!COM: Coltrane']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='COM', clear=True)\n['Coltrane']\n&gt;&gt;&gt; document.get_metacomments(KeyComment='non_existing_key')\n[]\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_metacomments(self, KeyComment: Optional[str] = None, clear: bool = False) -&gt; List[str]:\n    \"\"\"\n    Get all metacomments in the document\n\n    Args:\n        KeyComment: Filter by a specific metacomment key: e.g. Use 'COM' to get only comments starting with\\\n            '!!!COM: '. If None, all metacomments are returned.\n        clear: If True, the metacomment key is removed from the comment. E.g. '!!!COM: Coltrane' -&gt; 'Coltrane'.\\\n            If False, the metacomment key is kept. E.g. '!!!COM: Coltrane' -&gt; '!!!COM: Coltrane'. \\\n            The clear functionality is equivalent to the following code:\n            ```python\n            comment = '!!!COM: Coltrane'\n            clean_comment = comment.replace(f\"!!!{KeyComment}: \", \"\")\n            ```\n            Other formats are not supported.\n\n    Returns: A list of metacomments.\n\n    Examples:\n        &gt;&gt;&gt; document.get_metacomments()\n        ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n        &gt;&gt;&gt; document.get_metacomments(KeyComment='COM')\n        ['!!!COM: Coltrane']\n        &gt;&gt;&gt; document.get_metacomments(KeyComment='COM', clear=True)\n        ['Coltrane']\n        &gt;&gt;&gt; document.get_metacomments(KeyComment='non_existing_key')\n        []\n    \"\"\"\n    traversal = MetacommentsTraversal()\n    self.tree.dfs_iterative(traversal)\n    result = []\n    for metacomment in traversal.metacomments:\n        if KeyComment is None or metacomment.encoding.startswith(f\"!!!{KeyComment}\"):\n            new_comment = metacomment.encoding\n            if clear:\n                new_comment = metacomment.encoding.replace(f\"!!!{KeyComment}: \", \"\")\n            result.append(new_comment)\n\n    return result\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_spine_count","title":"<code>get_spine_count()</code>","text":"<p>Get the number of spines in the document.</p> <p>Returns (int): The number of spines in the document.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_spine_count(self) -&gt; int:\n    \"\"\"\n    Get the number of spines in the document.\n\n    Returns (int): The number of spines in the document.\n    \"\"\"\n    return len(self.get_header_stage())  # TODO: test refactor\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_spine_ids","title":"<code>get_spine_ids()</code>","text":"<p>Get the indexes of the current document.</p> <p>Returns List[int]: A list with the indexes of the current document.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_all_spine_indexes()\n[0, 1, 2, 3, 4]\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_spine_ids(self) -&gt; List[int]:\n    \"\"\"\n            Get the indexes of the current document.\n\n            Returns List[int]: A list with the indexes of the current document.\n\n            Examples:\n                &gt;&gt;&gt; document.get_all_spine_indexes()\n                [0, 1, 2, 3, 4]\n            \"\"\"\n    header_nodes = self.get_header_nodes()\n    return [node.spine_id for node in header_nodes]\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_unique_token_encodings","title":"<code>get_unique_token_encodings(filter_by_categories=None)</code>","text":"<p>Get unique token encodings.</p> <p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns: List[str] - A list of unique token encodings.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_unique_token_encodings(\n        self,\n        filter_by_categories: Optional[Sequence[TokenCategory]] = None\n) -&gt; List[str]:\n    \"\"\"\n    Get unique token encodings.\n\n    Args:\n        filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n    Returns: List[str] - A list of unique token encodings.\n\n    \"\"\"\n    tokens = self.get_unique_tokens(filter_by_categories)\n    return Document.tokens_to_encodings(tokens)\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_unique_tokens","title":"<code>get_unique_tokens(filter_by_categories=None)</code>","text":"<p>Get unique tokens.</p> <p>Parameters:</p> Name Type Description Default <code>filter_by_categories</code> <code>Optional[Sequence[TokenCategory]]</code> <p>A list of categories to filter the tokens. If None, all tokens are returned.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[AbstractToken]</code> <p>List[AbstractToken] - A list of unique tokens.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_unique_tokens(\n        self,\n        filter_by_categories: Optional[Sequence[TokenCategory]] = None\n) -&gt; List[AbstractToken]:\n    \"\"\"\n    Get unique tokens.\n\n    Args:\n        filter_by_categories (Optional[Sequence[TokenCategory]]): A list of categories to filter the tokens. If None, all tokens are returned.\n\n    Returns:\n        List[AbstractToken] - A list of unique tokens.\n\n    \"\"\"\n    computed_categories = TokenCategory.valid(include=filter_by_categories)\n    traversal = TokensTraversal(True, computed_categories)\n    self.tree.dfs_iterative(traversal)\n    return traversal.tokens\n</code></pre>"},{"location":"reference/#kernpy.core.Document.get_voices","title":"<code>get_voices(clean=False)</code>","text":"<p>Get the voices of the document.</p> <p>Args     clean (bool): Remove the first '!' from the voice name.</p> <p>Returns: A list of voices.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.get_voices()\n['!sax', '!piano', '!bass']\n&gt;&gt;&gt; document.get_voices(clean=True)\n['sax', 'piano', 'bass']\n&gt;&gt;&gt; document.get_voices(clean=False)\n['!sax', '!piano', '!bass']\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def get_voices(self, clean: bool = False):\n    \"\"\"\n    Get the voices of the document.\n\n    Args\n        clean (bool): Remove the first '!' from the voice name.\n\n    Returns: A list of voices.\n\n    Examples:\n        &gt;&gt;&gt; document.get_voices()\n        ['!sax', '!piano', '!bass']\n        &gt;&gt;&gt; document.get_voices(clean=True)\n        ['sax', 'piano', 'bass']\n        &gt;&gt;&gt; document.get_voices(clean=False)\n        ['!sax', '!piano', '!bass']\n    \"\"\"\n    from kernpy.core import TokenCategory\n    voices = self.get_all_tokens(filter_by_categories=[TokenCategory.INSTRUMENTS])\n\n    if clean:\n        voices = [voice[1:] for voice in voices]\n    return voices\n</code></pre>"},{"location":"reference/#kernpy.core.Document.match","title":"<code>match(a, b, *, check_core_spines_only=False)</code>  <code>classmethod</code>","text":"<p>Match two documents. Two documents match if they have the same spine structure.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Document</code> <p>The first document.</p> required <code>b</code> <code>Document</code> <p>The second document.</p> required <code>check_core_spines_only</code> <code>Optional[bool]</code> <p>If True, only the core spines (kern and mens) are checked. If False, all spines are checked.</p> <code>False</code> <p>Returns: True if the documents match, False otherwise.</p> <p>Examples:</p> Source code in <code>kernpy/core/document.py</code> <pre><code>@classmethod\ndef match(cls, a: 'Document', b: 'Document', *, check_core_spines_only: Optional[bool] = False) -&gt; bool:\n    \"\"\"\n    Match two documents. Two documents match if they have the same spine structure.\n\n    Args:\n        a (Document): The first document.\n        b (Document): The second document.\n        check_core_spines_only (Optional[bool]): If True, only the core spines (**kern and **mens) are checked. If False, all spines are checked.\n\n    Returns: True if the documents match, False otherwise.\n\n    Examples:\n\n    \"\"\"\n    if check_core_spines_only:\n        return [token.encoding for token in a.get_header_nodes() if token.encoding in CORE_HEADERS] \\\n            == [token.encoding for token in b.get_header_nodes() if token.encoding in CORE_HEADERS]\n    else:\n        return [token.encoding for token in a.get_header_nodes()] \\\n            == [token.encoding for token in b.get_header_nodes()]\n</code></pre>"},{"location":"reference/#kernpy.core.Document.measures_count","title":"<code>measures_count()</code>","text":"<p>Get the index of the last measure of the document.</p> <p>Returns: (Int) The index of the last measure of the document.</p> <p>Raises: Exception - If the document has no measures.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document, _ = kernpy.read('score.krn')\n&gt;&gt;&gt; document.measures_count()\n10\n&gt;&gt;&gt; for i in range(document.get_first_measure(), document.measures_count() + 1):\n&gt;&gt;&gt;   options = kernpy.ExportOptions(from_measure=i, to_measure=i+4)\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def measures_count(self) -&gt; int:\n    \"\"\"\n    Get the index of the last measure of the document.\n\n    Returns: (Int) The index of the last measure of the document.\n\n    Raises: Exception - If the document has no measures.\n\n    Examples:\n        &gt;&gt;&gt; document, _ = kernpy.read('score.krn')\n        &gt;&gt;&gt; document.measures_count()\n        10\n        &gt;&gt;&gt; for i in range(document.get_first_measure(), document.measures_count() + 1):\n        &gt;&gt;&gt;   options = kernpy.ExportOptions(from_measure=i, to_measure=i+4)\n    \"\"\"\n    if len(self.measure_start_tree_stages) == 0:\n        raise Exception('No measures found')\n\n    return len(self.measure_start_tree_stages)\n</code></pre>"},{"location":"reference/#kernpy.core.Document.split","title":"<code>split()</code>","text":"<p>Split the current document into a list of documents, one for each kern spine. Each resulting document will contain one kern spine along with all non-kern spines.</p> <p>Returns:</p> Type Description <code>List['Document']</code> <p>List['Document']: A list of documents, where each document contains one **kern spine</p> <code>List['Document']</code> <p>and all non-kern spines from the original document.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; document.split()\n[&lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;]\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def split(self) -&gt; List['Document']:\n    \"\"\"\n    Split the current document into a list of documents, one for each **kern spine.\n    Each resulting document will contain one **kern spine along with all non-kern spines.\n\n    Returns:\n        List['Document']: A list of documents, where each document contains one **kern spine\n        and all non-kern spines from the original document.\n\n    Examples:\n        &gt;&gt;&gt; document.split()\n        [&lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;, &lt;Document: score.krn&gt;]\n    \"\"\"\n    raise NotImplementedError\n    new_documents = []\n    self_document_copy = deepcopy(self)\n    kern_header_nodes = [node for node in self_document_copy.get_header_nodes() if node.encoding == '**kern']\n    other_header_nodes = [node for node in self_document_copy.get_header_nodes() if node.encoding != '**kern']\n    spine_ids = self_document_copy.get_spine_ids()\n\n    for header_node in kern_header_nodes:\n        if header_node.spine_id not in spine_ids:\n            continue\n\n        spine_ids.remove(header_node.spine_id)\n\n        new_tree = deepcopy(self.tree)\n        prev_node = new_tree.root\n        while not isinstance(prev_node, HeaderToken):\n            prev_node = prev_node.children[0]\n\n        if not prev_node or not isinstance(prev_node, HeaderToken):\n            raise Exception(f'Header node not found: {prev_node} in {header_node}')\n\n        new_children = list(filter(lambda x: x.spine_id == header_node.spine_id, prev_node.children))\n        new_tree.root = new_children\n\n        new_document = Document(new_tree)\n\n        new_documents.append(new_document)\n\n    return new_documents\n</code></pre>"},{"location":"reference/#kernpy.core.Document.to_concat","title":"<code>to_concat(first_doc, second_doc, deep_copy=True)</code>  <code>classmethod</code>","text":"<p>Concatenate two documents.</p> <p>Parameters:</p> Name Type Description Default <code>first_doc</code> <code>Document</code> <p>The first document.</p> required <code>second_doc</code> <code>Document</code> <p>The second document.</p> required <code>deep_copy</code> <code>bool</code> <p>If True, the documents are deep copied. If False, the documents are shallow copied.</p> <code>True</code> <p>Returns: A new instance of Document with the documents concatenated.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>@classmethod\ndef to_concat(cls, first_doc: 'Document', second_doc: 'Document', deep_copy: bool = True) -&gt; 'Document':\n    \"\"\"\n    Concatenate two documents.\n\n    Args:\n        first_doc (Document): The first document.\n        second_doc (Document: The second document.\n        deep_copy (bool): If True, the documents are deep copied. If False, the documents are shallow copied.\n\n    Returns: A new instance of Document with the documents concatenated.\n    \"\"\"\n    first_doc = first_doc.clone() if deep_copy else first_doc\n    second_doc = second_doc.clone() if deep_copy else second_doc\n    first_doc.add(second_doc)\n\n    return first_doc\n</code></pre>"},{"location":"reference/#kernpy.core.Document.to_transposed","title":"<code>to_transposed(interval, direction=Direction.UP.value)</code>","text":"<p>Create a new document with the transposed notes without modifying the original document.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>str</code> <p>The name of the interval to transpose. It can be 'P4', 'P5', 'M2', etc. Check the              kp.AVAILABLE_INTERVALS for the available intervals.</p> required <code>direction</code> <code>str</code> <p>The direction to transpose. It can be 'up' or 'down'.</p> <code>UP.value</code> <p>Returns:</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def to_transposed(self, interval: str, direction: str = Direction.UP.value) -&gt; 'Document':\n    \"\"\"\n    Create a new document with the transposed notes without modifying the original document.\n\n    Args:\n        interval (str): The name of the interval to transpose. It can be 'P4', 'P5', 'M2', etc. Check the \\\n         kp.AVAILABLE_INTERVALS for the available intervals.\n        direction (str): The direction to transpose. It can be 'up' or 'down'.\n\n    Returns:\n\n    \"\"\"\n    if interval not in AVAILABLE_INTERVALS:\n        raise ValueError(\n            f\"Interval {interval!r} is not available. \"\n            f\"Available intervals are: {AVAILABLE_INTERVALS}\"\n        )\n\n    if direction not in (Direction.UP.value, Direction.DOWN.value):\n        raise ValueError(\n            f\"Direction {direction!r} is not available. \"\n            f\"Available directions are: \"\n            f\"{Direction.UP.value!r}, {Direction.DOWN.value!r}\"\n        )\n\n    new_document = self.clone()\n\n    # BFS through the tree\n    root = new_document.tree.root\n    queue = Queue()\n    queue.put(root)\n\n    while not queue.empty():\n        node = queue.get()\n\n        if isinstance(node.token, NoteRestToken):\n            orig_token = node.token\n\n            new_subtokens = []\n            transposed_pitch_encoding = None\n\n            # Transpose each pitch subtoken in the pitch\u2013duration list\n            for subtoken in orig_token.pitch_duration_subtokens:\n                if subtoken.category == TokenCategory.PITCH:\n                    # transpose() returns a new pitch subtoken\n                    tp = transpose(\n                        input_encoding=subtoken.encoding,\n                        interval=IntervalsByName[interval],\n                        direction=direction,\n                        input_format=NotationEncoding.HUMDRUM.value,\n                        output_format=NotationEncoding.HUMDRUM.value,\n                    )\n                    new_subtokens.append(Subtoken(tp, subtoken.category))\n                    transposed_pitch_encoding = tp\n                else:\n                    # leave duration subtokens untouched\n                    new_subtokens.append(Subtoken(subtoken.encoding, subtoken.category))\n\n            # Replace the node\u2019s token with a new NoteRestToken\n            node.token = NoteRestToken(\n                encoding=transposed_pitch_encoding,\n                pitch_duration_subtokens=new_subtokens,\n                decoration_subtokens=orig_token.decoration_subtokens,\n            )\n\n        # enqueue children\n        for child in node.children:\n            queue.put(child)\n\n    # Return the transposed clone\n    return new_document\n</code></pre>"},{"location":"reference/#kernpy.core.Document.tokens_to_encodings","title":"<code>tokens_to_encodings(tokens)</code>  <code>classmethod</code>","text":"<p>Get the encodings of a list of tokens.</p> The method is equivalent to the following code <p>tokens = kp.get_all_tokens() [token.encoding for token in tokens if token.encoding is not None]</p> <p>Parameters:</p> Name Type Description Default <code>tokens</code> <code>Sequence[AbstractToken]</code> <p>list - A list of tokens.</p> required <p>Returns: List[str] - A list of token encodings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tokens = document.get_all_tokens()\n&gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>@classmethod\ndef tokens_to_encodings(cls, tokens: Sequence[AbstractToken]):\n    \"\"\"\n    Get the encodings of a list of tokens.\n\n    The method is equivalent to the following code:\n        &gt;&gt;&gt; tokens = kp.get_all_tokens()\n        &gt;&gt;&gt; [token.encoding for token in tokens if token.encoding is not None]\n\n    Args:\n        tokens (Sequence[AbstractToken]): list - A list of tokens.\n\n    Returns: List[str] - A list of token encodings.\n\n    Examples:\n        &gt;&gt;&gt; tokens = document.get_all_tokens()\n        &gt;&gt;&gt; Document.tokens_to_encodings(tokens)\n        ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\n    \"\"\"\n    encodings = [token.encoding for token in tokens if token.encoding is not None]\n    return encodings\n</code></pre>"},{"location":"reference/#kernpy.core.Duration","title":"<code>Duration</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Represents the duration of a note or a rest.</p> <p>The duration is represented using the Humdrum Kern format. The duration is a number that represents the number of units of the duration.</p> <p>The duration of a whole note is 1, half note is 2, quarter note is 4, eighth note is 8, etc.</p> <p>The duration of a note is represented by a number. The duration of a rest is also represented by a number.</p> <p>This class do not limit the duration ranges.</p> <p>In the following example, the duration is represented by the number '2'.</p> <pre><code>**kern\n*clefG2\n2c          // whole note\n4c          // half note\n8c          // quarter note\n16c         // eighth note\n*-\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class Duration(ABC):\n    \"\"\"\n    Represents the duration of a note or a rest.\n\n    The duration is represented using the Humdrum Kern format.\n    The duration is a number that represents the number of units of the duration.\n\n    The duration of a whole note is 1, half note is 2, quarter note is 4, eighth note is 8, etc.\n\n    The duration of a note is represented by a number. The duration of a rest is also represented by a number.\n\n    This class do not limit the duration ranges.\n\n    In the following example, the duration is represented by the number '2'.\n    ```\n    **kern\n    *clefG2\n    2c          // whole note\n    4c          // half note\n    8c          // quarter note\n    16c         // eighth note\n    *-\n    ```\n    \"\"\"\n\n    def __init__(self, raw_duration):\n        self.encoding = str(raw_duration)\n\n    @abstractmethod\n    def modify(self, ratio: int):\n        pass\n\n    @abstractmethod\n    def __deepcopy__(self, memo=None):\n        pass\n\n    @abstractmethod\n    def __eq__(self, other):\n        pass\n\n    @abstractmethod\n    def __ne__(self, other):\n        pass\n\n    @abstractmethod\n    def __gt__(self, other):\n        pass\n\n    @abstractmethod\n    def __lt__(self, other):\n        pass\n\n    @abstractmethod\n    def __ge__(self, other):\n        pass\n\n    @abstractmethod\n    def __le__(self, other):\n        pass\n\n    @abstractmethod\n    def __str__(self):\n        pass\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical","title":"<code>DurationClassical</code>","text":"<p>               Bases: <code>Duration</code></p> <p>Represents the duration in classical notation of a note or a rest.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class DurationClassical(Duration):\n    \"\"\"\n    Represents the duration in classical notation of a note or a rest.\n    \"\"\"\n\n    def __init__(self, duration: int):\n        \"\"\"\n        Create a new Duration object.\n\n        Args:\n            duration (str): duration representation in Humdrum Kern format\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            True\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            True\n            &gt;&gt;&gt; duration = DurationClassical(32)\n            True\n            &gt;&gt;&gt; duration = DurationClassical(1)\n            True\n            &gt;&gt;&gt; duration = DurationClassical(0)\n            False\n            &gt;&gt;&gt; duration = DurationClassical(-2)\n            False\n            &gt;&gt;&gt; duration = DurationClassical(3)\n            False\n            &gt;&gt;&gt; duration = DurationClassical(7)\n            False\n        \"\"\"\n        super().__init__(duration)\n        if not DurationClassical.__is_valid_duration(duration):\n            raise ValueError(f'Bad duration: {duration} was provided.')\n\n        self.duration = int(duration)\n\n    def modify(self, ratio: int):\n        \"\"\"\n        Modify the duration of a note or a rest of the current object.\n\n        Args:\n            ratio (int): The factor to modify the duration. The factor must be greater than 0.\n\n        Returns (DurationClassical): The new duration object with the modified duration.\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; new_duration = duration.modify(2)\n            &gt;&gt;&gt; new_duration.duration\n            4\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; new_duration = duration.modify(0)\n            Traceback (most recent call last):\n            ...\n            ValueError: Invalid factor provided: 0. The factor must be greater than 0.\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; new_duration = duration.modify(-2)\n            Traceback (most recent call last):\n            ...\n            ValueError: Invalid factor provided: -2. The factor must be greater than 0.\n        \"\"\"\n        if not isinstance(ratio, int):\n            raise ValueError(f'Invalid factor provided: {ratio}. The factor must be an integer.')\n        if ratio &lt;= 0:\n            raise ValueError(f'Invalid factor provided: {ratio}. The factor must be greater than 0.')\n\n        return copy.deepcopy(DurationClassical(self.duration * ratio))\n\n    def __deepcopy__(self, memo=None):\n        if memo is None:\n            memo = {}\n\n        new_instance = DurationClassical(self.duration)\n        new_instance.duration = self.duration\n        return new_instance\n\n    def __str__(self):\n        return f'{self.duration}'\n\n    def __eq__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other (DurationClassical): The other duration to compare\n\n        Returns (bool): True if the durations are equal, False otherwise\n\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration == duration2\n            True\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration == duration2\n            False\n        \"\"\"\n        if not isinstance(other, DurationClassical):\n            return False\n        return self.duration == other.duration\n\n    def __ne__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other (DurationClassical): The other duration to compare\n\n        Returns (bool):\n            True if the durations are different, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration != duration2\n            False\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration != duration2\n            True\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __gt__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other: The other duration to compare\n\n        Returns (bool):\n            True if this duration is higher than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &gt; duration2\n            False\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration &gt; duration2\n            True\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &gt; duration2\n            False\n        \"\"\"\n        if not isinstance(other, DurationClassical):\n            raise ValueError(f'Invalid comparison: &gt; operator can not be used to compare duration with {type(other)}')\n        return self.duration &gt; other.duration\n\n    def __lt__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other (DurationClassical): The other duration to compare\n\n        Returns (bool):\n            True if this duration is lower than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &lt; duration2\n            True\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration &lt; duration2\n            False\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &lt; duration2\n            False\n        \"\"\"\n        if not isinstance(other, DurationClassical):\n            raise ValueError(f'Invalid comparison: &lt; operator can not be used to compare duration with {type(other)}')\n        return self.duration &lt; other.duration\n\n    def __ge__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other (DurationClassical): The other duration to compare\n\n        Returns (bool):\n            True if this duration is higher or equal than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &gt;= duration2\n            False\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration &gt;= duration2\n            True\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &gt;= duration2\n            True\n        \"\"\"\n        return self.__gt__(other) or self.__eq__(other)\n\n    def __le__(self, other: 'DurationClassical') -&gt; bool:\n        \"\"\"\n        Compare two durations.\n\n        Args:\n            other (DurationClassical): The other duration to compare\n\n        Returns:\n            True if this duration is lower or equal than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; duration = DurationClassical(2)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &lt;= duration2\n            True\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(2)\n            &gt;&gt;&gt; duration &lt;= duration2\n            False\n            &gt;&gt;&gt; duration = DurationClassical(4)\n            &gt;&gt;&gt; duration2 = DurationClassical(4)\n            &gt;&gt;&gt; duration &lt;= duration2\n            True\n        \"\"\"\n        return self.__lt__(other) or self.__eq__(other)\n\n    @classmethod\n    def __is_valid_duration(cls, duration: int) -&gt; bool:\n        try:\n            duration = int(duration)\n            if duration is None or duration &lt;= 0:\n                return False\n\n            return duration &gt; 0 and (duration % 2 == 0 or duration == 1)\n        except ValueError:\n            return False\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool): True if the durations are equal, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration == duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration == duration2\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __eq__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other (DurationClassical): The other duration to compare\n\n    Returns (bool): True if the durations are equal, False otherwise\n\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration == duration2\n        True\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration == duration2\n        False\n    \"\"\"\n    if not isinstance(other, DurationClassical):\n        return False\n    return self.duration == other.duration\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is higher or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt;= duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &gt;= duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt;= duration2\nTrue\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ge__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other (DurationClassical): The other duration to compare\n\n    Returns (bool):\n        True if this duration is higher or equal than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &gt;= duration2\n        False\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration &gt;= duration2\n        True\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &gt;= duration2\n        True\n    \"\"\"\n    return self.__gt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'DurationClassical'</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is higher than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt; duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &gt; duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &gt; duration2\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __gt__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other: The other duration to compare\n\n    Returns (bool):\n        True if this duration is higher than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &gt; duration2\n        False\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration &gt; duration2\n        True\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &gt; duration2\n        False\n    \"\"\"\n    if not isinstance(other, DurationClassical):\n        raise ValueError(f'Invalid comparison: &gt; operator can not be used to compare duration with {type(other)}')\n    return self.duration &gt; other.duration\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__init__","title":"<code>__init__(duration)</code>","text":"<p>Create a new Duration object.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>str</code> <p>duration representation in Humdrum Kern format</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(32)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(1)\nTrue\n&gt;&gt;&gt; duration = DurationClassical(0)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(-2)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(3)\nFalse\n&gt;&gt;&gt; duration = DurationClassical(7)\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, duration: int):\n    \"\"\"\n    Create a new Duration object.\n\n    Args:\n        duration (str): duration representation in Humdrum Kern format\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        True\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        True\n        &gt;&gt;&gt; duration = DurationClassical(32)\n        True\n        &gt;&gt;&gt; duration = DurationClassical(1)\n        True\n        &gt;&gt;&gt; duration = DurationClassical(0)\n        False\n        &gt;&gt;&gt; duration = DurationClassical(-2)\n        False\n        &gt;&gt;&gt; duration = DurationClassical(3)\n        False\n        &gt;&gt;&gt; duration = DurationClassical(7)\n        False\n    \"\"\"\n    super().__init__(duration)\n    if not DurationClassical.__is_valid_duration(duration):\n        raise ValueError(f'Bad duration: {duration} was provided.')\n\n    self.duration = int(duration)\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__le__","title":"<code>__le__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this duration is lower or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt;= duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &lt;= duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt;= duration2\nTrue\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __le__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other (DurationClassical): The other duration to compare\n\n    Returns:\n        True if this duration is lower or equal than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &lt;= duration2\n        True\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration &lt;= duration2\n        False\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &lt;= duration2\n        True\n    \"\"\"\n    return self.__lt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if this duration is lower than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt; duration2\nTrue\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration &lt; duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(4)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration &lt; duration2\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __lt__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other (DurationClassical): The other duration to compare\n\n    Returns (bool):\n        True if this duration is lower than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &lt; duration2\n        True\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration &lt; duration2\n        False\n        &gt;&gt;&gt; duration = DurationClassical(4)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration &lt; duration2\n        False\n    \"\"\"\n    if not isinstance(other, DurationClassical):\n        raise ValueError(f'Invalid comparison: &lt; operator can not be used to compare duration with {type(other)}')\n    return self.duration &lt; other.duration\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two durations.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>DurationClassical</code> <p>The other duration to compare</p> required <p>Returns (bool):     True if the durations are different, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(2)\n&gt;&gt;&gt; duration != duration2\nFalse\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; duration2 = DurationClassical(4)\n&gt;&gt;&gt; duration != duration2\nTrue\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ne__(self, other: 'DurationClassical') -&gt; bool:\n    \"\"\"\n    Compare two durations.\n\n    Args:\n        other (DurationClassical): The other duration to compare\n\n    Returns (bool):\n        True if the durations are different, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(2)\n        &gt;&gt;&gt; duration != duration2\n        False\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; duration2 = DurationClassical(4)\n        &gt;&gt;&gt; duration != duration2\n        True\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.DurationClassical.modify","title":"<code>modify(ratio)</code>","text":"<p>Modify the duration of a note or a rest of the current object.</p> <p>Parameters:</p> Name Type Description Default <code>ratio</code> <code>int</code> <p>The factor to modify the duration. The factor must be greater than 0.</p> required <p>Returns (DurationClassical): The new duration object with the modified duration.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(2)\n&gt;&gt;&gt; new_duration.duration\n4\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(0)\nTraceback (most recent call last):\n...\nValueError: Invalid factor provided: 0. The factor must be greater than 0.\n&gt;&gt;&gt; duration = DurationClassical(2)\n&gt;&gt;&gt; new_duration = duration.modify(-2)\nTraceback (most recent call last):\n...\nValueError: Invalid factor provided: -2. The factor must be greater than 0.\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def modify(self, ratio: int):\n    \"\"\"\n    Modify the duration of a note or a rest of the current object.\n\n    Args:\n        ratio (int): The factor to modify the duration. The factor must be greater than 0.\n\n    Returns (DurationClassical): The new duration object with the modified duration.\n\n    Examples:\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; new_duration = duration.modify(2)\n        &gt;&gt;&gt; new_duration.duration\n        4\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; new_duration = duration.modify(0)\n        Traceback (most recent call last):\n        ...\n        ValueError: Invalid factor provided: 0. The factor must be greater than 0.\n        &gt;&gt;&gt; duration = DurationClassical(2)\n        &gt;&gt;&gt; new_duration = duration.modify(-2)\n        Traceback (most recent call last):\n        ...\n        ValueError: Invalid factor provided: -2. The factor must be greater than 0.\n    \"\"\"\n    if not isinstance(ratio, int):\n        raise ValueError(f'Invalid factor provided: {ratio}. The factor must be an integer.')\n    if ratio &lt;= 0:\n        raise ValueError(f'Invalid factor provided: {ratio}. The factor must be greater than 0.')\n\n    return copy.deepcopy(DurationClassical(self.duration * ratio))\n</code></pre>"},{"location":"reference/#kernpy.core.DurationMensural","title":"<code>DurationMensural</code>","text":"<p>               Bases: <code>Duration</code></p> <p>Represents the duration in mensural notation of a note or a rest.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class DurationMensural(Duration):\n    \"\"\"\n    Represents the duration in mensural notation of a note or a rest.\n    \"\"\"\n\n    def __init__(self, duration):\n        super().__init__(duration)\n        self.duration = duration\n\n    def __eq__(self, other):\n        raise NotImplementedError()\n\n    def modify(self, ratio: int):\n        raise NotImplementedError()\n\n    def __deepcopy__(self, memo=None):\n        raise NotImplementedError()\n\n    def __gt__(self, other):\n        raise NotImplementedError()\n\n    def __lt__(self, other):\n        raise NotImplementedError()\n\n    def __le__(self, other):\n        raise NotImplementedError()\n\n    def __str__(self):\n        raise NotImplementedError()\n\n    def __ge__(self, other):\n        raise NotImplementedError()\n\n    def __ne__(self, other):\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/#kernpy.core.DynSpineImporter","title":"<code>DynSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/dyn_importer.py</code> <pre><code>class DynSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()\n\n    def import_token(self, encoding: str) -&gt; Token:\n        # TODO: Find out differences between **dyn vs **dynam and change this class. Using the same dor both for now.\n        dynam_importer = DynamSpineImporter()\n        return dynam_importer.import_token(encoding)\n</code></pre>"},{"location":"reference/#kernpy.core.DynSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/dyn_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.core.DynamSpineImporter","title":"<code>DynamSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/dynam_spine_importer.py</code> <pre><code>class DynamSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()  # TODO: Create a custom functional listener for DynamSpineImporter\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if not any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.DYNAMICS)\n\n        return token\n</code></pre>"},{"location":"reference/#kernpy.core.DynamSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/dynam_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.core.EkernTokenizer","title":"<code>EkernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>EkernTokenizer converts a Token into an eKern (Extended **kern) string representation. This format use a '@' separator for the     main tokens and a '\u00b7' separator for the decorations tokens.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class EkernTokenizer(Tokenizer):\n    \"\"\"\n    EkernTokenizer converts a Token into an eKern (Extended **kern) string representation. This format use a '@' separator for the \\\n    main tokens and a '\u00b7' separator for the decorations tokens.\n    \"\"\"\n\n    def __init__(self, *, token_categories: Set['TokenCategory']):\n        \"\"\"\n        Create a new EkernTokenizer\n\n        Args:\n            token_categories (List[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n        \"\"\"\n        super().__init__(token_categories=token_categories)\n\n    def tokenize(self, token: Token) -&gt; str:\n        \"\"\"\n        Tokenize a token into an eKern string representation.\n        Args:\n            token (Token): Token to be tokenized.\n\n        Returns (str): eKern string representation.\n\n        Examples:\n            &gt;&gt;&gt; token.encoding\n            '2@.@bb@-\u00b7_\u00b7L'\n            &gt;&gt;&gt; EkernTokenizer().tokenize(token)\n            '2@.@bb@-\u00b7_\u00b7L'\n\n        \"\"\"\n        return token.export(filter_categories=lambda cat: cat in self.token_categories)\n</code></pre>"},{"location":"reference/#kernpy.core.EkernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new EkernTokenizer</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>List[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def __init__(self, *, token_categories: Set['TokenCategory']):\n    \"\"\"\n    Create a new EkernTokenizer\n\n    Args:\n        token_categories (List[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n    \"\"\"\n    super().__init__(token_categories=token_categories)\n</code></pre>"},{"location":"reference/#kernpy.core.EkernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into an eKern string representation. Args:     token (Token): Token to be tokenized.</p> <p>Returns (str): eKern string representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; EkernTokenizer().tokenize(token)\n'2@.@bb@-\u00b7_\u00b7L'\n</code></pre> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def tokenize(self, token: Token) -&gt; str:\n    \"\"\"\n    Tokenize a token into an eKern string representation.\n    Args:\n        token (Token): Token to be tokenized.\n\n    Returns (str): eKern string representation.\n\n    Examples:\n        &gt;&gt;&gt; token.encoding\n        '2@.@bb@-\u00b7_\u00b7L'\n        &gt;&gt;&gt; EkernTokenizer().tokenize(token)\n        '2@.@bb@-\u00b7_\u00b7L'\n\n    \"\"\"\n    return token.export(filter_categories=lambda cat: cat in self.token_categories)\n</code></pre>"},{"location":"reference/#kernpy.core.Encoding","title":"<code>Encoding</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Options for exporting a kern file.</p> Example <p>import kernpy as kp</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class Encoding(Enum):  # TODO: Eventually, polymorphism will be used to export different types of kern files\n    \"\"\"\n    Options for exporting a kern file.\n\n    Example:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; # Load a file\n        &gt;&gt;&gt; doc, _ = kp.load('path/to/file.krn')\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Save the file using the specified encoding\n        &gt;&gt;&gt; exported_content = kp.dumps(tokenizer=kp.Encoding.normalizedKern)\n    \"\"\"\n    eKern = 'ekern'\n    normalizedKern = 'kern'\n    bKern = 'bkern'\n    bEkern = 'bekern'\n\n    def prefix(self) -&gt; str:\n        \"\"\"\n        Get the prefix of the kern type.\n\n        Returns (str): Prefix of the kern type.\n        \"\"\"\n        if self == Encoding.eKern:\n            return 'e'\n        elif self == Encoding.normalizedKern:\n            return ''\n        elif self == Encoding.bKern:\n            return 'b'\n        elif self == Encoding.bEkern:\n            return 'be'\n        else:\n            raise ValueError(f'Unknown kern type: {self}. '\n                             f'Supported types are: '\n                             f\"{'-'.join([kern_type.name for kern_type in Encoding.__members__.values()])}\")\n</code></pre>"},{"location":"reference/#kernpy.core.Encoding--load-a-file","title":"Load a file","text":"<p>doc, _ = kp.load('path/to/file.krn')</p>"},{"location":"reference/#kernpy.core.Encoding--save-the-file-using-the-specified-encoding","title":"Save the file using the specified encoding","text":"<p>exported_content = kp.dumps(tokenizer=kp.Encoding.normalizedKern)</p>"},{"location":"reference/#kernpy.core.Encoding.prefix","title":"<code>prefix()</code>","text":"<p>Get the prefix of the kern type.</p> <p>Returns (str): Prefix of the kern type.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def prefix(self) -&gt; str:\n    \"\"\"\n    Get the prefix of the kern type.\n\n    Returns (str): Prefix of the kern type.\n    \"\"\"\n    if self == Encoding.eKern:\n        return 'e'\n    elif self == Encoding.normalizedKern:\n        return ''\n    elif self == Encoding.bKern:\n        return 'b'\n    elif self == Encoding.bEkern:\n        return 'be'\n    else:\n        raise ValueError(f'Unknown kern type: {self}. '\n                         f'Supported types are: '\n                         f\"{'-'.join([kern_type.name for kern_type in Encoding.__members__.values()])}\")\n</code></pre>"},{"location":"reference/#kernpy.core.ErrorListener","title":"<code>ErrorListener</code>","text":"<p>               Bases: <code>ConsoleErrorListener</code></p> Source code in <code>kernpy/core/error_listener.py</code> <pre><code>class ErrorListener(ConsoleErrorListener):\n    def __init__(self, *, verbose: Optional[bool] = False):\n        \"\"\"\n        ErrorListener constructor.\n        Args:\n            verbose (bool): If True, the error messages will be printed to the console using \\\n            the `ConsoleErrorListener` interface.\n        \"\"\"\n        super().__init__()\n        self.errors = []\n        self.verbose = verbose\n\n    def syntaxError(self, recognizer, offendingSymbol, line, charPositionInLine, msg, e):\n        if self.verbose:\n            self.syntaxError(recognizer, offendingSymbol, line, charPositionInLine, msg, e)\n\n        self.errors.append(ParseError(offendingSymbol, charPositionInLine, msg, e))\n\n    def getNumberErrorsFound(self):\n        return len(self.errors)\n\n    def __str__(self):\n        sb = \"\"\n        for error in self.errors:\n            sb += str(error) + \"\\n\"\n        return sb\n</code></pre>"},{"location":"reference/#kernpy.core.ErrorListener.__init__","title":"<code>__init__(*, verbose=False)</code>","text":"<p>ErrorListener constructor. Args:     verbose (bool): If True, the error messages will be printed to the console using             the <code>ConsoleErrorListener</code> interface.</p> Source code in <code>kernpy/core/error_listener.py</code> <pre><code>def __init__(self, *, verbose: Optional[bool] = False):\n    \"\"\"\n    ErrorListener constructor.\n    Args:\n        verbose (bool): If True, the error messages will be printed to the console using \\\n        the `ConsoleErrorListener` interface.\n    \"\"\"\n    super().__init__()\n    self.errors = []\n    self.verbose = verbose\n</code></pre>"},{"location":"reference/#kernpy.core.ErrorToken","title":"<code>ErrorToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>Used to wrap tokens that have not been parsed.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class ErrorToken(SimpleToken):\n    \"\"\"\n    Used to wrap tokens that have not been parsed.\n    \"\"\"\n\n    def __init__(\n            self,\n            encoding: str,\n            line: int,\n            error: str\n    ):\n        \"\"\"\n        ErrorToken constructor\n\n        Args:\n            encoding (str): The original representation of the token.\n            line (int): The line number of the token in the score.\n            error (str): The error message thrown by the parser.\n        \"\"\"\n        super().__init__(encoding, TokenCategory.ERROR)\n        self.error = error\n        self.line = line\n\n    def export(self, **kwargs) -&gt; str:\n        \"\"\"\n        Exports the error token.\n\n        Returns (str): A string representation of the error token.\n        \"\"\"\n        # return ERROR_TOKEN\n        return self.encoding  # TODO: add a constant for the error token\n\n    def __str__(self):\n        \"\"\"\n        Information about the error token.\n\n        Returns (str) The information about the error token.\n        \"\"\"\n        return f'Error token found at line {self.line} with encoding \"{self.encoding}\". Description: {self.error}'\n</code></pre>"},{"location":"reference/#kernpy.core.ErrorToken.__init__","title":"<code>__init__(encoding, line, error)</code>","text":"<p>ErrorToken constructor</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>line</code> <code>int</code> <p>The line number of the token in the score.</p> required <code>error</code> <code>str</code> <p>The error message thrown by the parser.</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(\n        self,\n        encoding: str,\n        line: int,\n        error: str\n):\n    \"\"\"\n    ErrorToken constructor\n\n    Args:\n        encoding (str): The original representation of the token.\n        line (int): The line number of the token in the score.\n        error (str): The error message thrown by the parser.\n    \"\"\"\n    super().__init__(encoding, TokenCategory.ERROR)\n    self.error = error\n    self.line = line\n</code></pre>"},{"location":"reference/#kernpy.core.ErrorToken.__str__","title":"<code>__str__()</code>","text":"<p>Information about the error token.</p> <p>Returns (str) The information about the error token.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Information about the error token.\n\n    Returns (str) The information about the error token.\n    \"\"\"\n    return f'Error token found at line {self.line} with encoding \"{self.encoding}\". Description: {self.error}'\n</code></pre>"},{"location":"reference/#kernpy.core.ErrorToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the error token.</p> <p>Returns (str): A string representation of the error token.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def export(self, **kwargs) -&gt; str:\n    \"\"\"\n    Exports the error token.\n\n    Returns (str): A string representation of the error token.\n    \"\"\"\n    # return ERROR_TOKEN\n    return self.encoding  # TODO: add a constant for the error token\n</code></pre>"},{"location":"reference/#kernpy.core.ExportOptions","title":"<code>ExportOptions</code>","text":"<p><code>ExportOptions</code> class.</p> <p>Store the options to export a **kern file.</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>class ExportOptions:\n    \"\"\"\n    `ExportOptions` class.\n\n    Store the options to export a **kern file.\n    \"\"\"\n\n    def __init__(\n            self,\n            spine_types: [] = None,\n            token_categories: [] = None,\n            from_measure: int = None,\n            to_measure: int = None,\n            kern_type: Encoding = Encoding.normalizedKern,\n            instruments: [] = None,\n            show_measure_numbers: bool = False,\n            spine_ids: [int] = None\n    ):\n        \"\"\"\n        Create a new ExportOptions object.\n\n        Args:\n            spine_types (Iterable): **kern, **mens, etc...\n            token_categories (Iterable): TokenCategory\n            from_measure (int): The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1\n            to_measure (int): The measure to end exporting. When None, the exporter will end at the end of the file.\n            kern_type (Encoding): The type of the kern file to export.\n            instruments (Iterable): The instruments to export. When None, all the instruments will be exported.\n            show_measure_numbers (Bool): Show the measure numbers in the exported file.\n            spine_ids (Iterable): The ids of the spines to export. When None, all the spines will be exported. Spines ids start from 0 and they are increased by 1.\n\n        Example:\n            &gt;&gt;&gt; import kernpy\n\n            Create the importer and read the file\n            &gt;&gt;&gt; hi = Importer()\n            &gt;&gt;&gt; document = hi.import_file('file.krn')\n            &gt;&gt;&gt; exporter = Exporter()\n\n            Export the file with the specified options\n            &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n            Export only the lyrics\n            &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LYRICS])\n            &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n            Export the comments\n            &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LINE_COMMENTS, TokenCategory.FIELD_COMMENTS])\n            &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n            Export using the eKern version\n            &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES, kern_type=Encoding.eKern)\n            &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n        \"\"\"\n        self.spine_types = spine_types if spine_types is not None else deepcopy(HEADERS)\n        self.from_measure = from_measure\n        self.to_measure = to_measure\n        self.token_categories = token_categories if token_categories is not None else [c for c in TokenCategory]\n        self.kern_type = kern_type\n        self.instruments = instruments\n        self.show_measure_numbers = show_measure_numbers\n        self.spine_ids = spine_ids  # When exporting, if spine_ids=None all the spines will be exported.\n\n    def __eq__(self, other: 'ExportOptions') -&gt; bool:\n        \"\"\"\n        Compare two ExportOptions objects.\n\n        Args:\n            other: The other ExportOptions object to compare.\n\n        Returns (bool):\n            True if the objects are equal, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options1 == options2\n            True\n\n            &gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options1 == options3\n            False\n        \"\"\"\n        return self.spine_types == other.spine_types and \\\n            self.token_categories == other.token_categories and \\\n            self.from_measure == other.from_measure and \\\n            self.to_measure == other.to_measure and \\\n            self.kern_type == other.kern_type and \\\n            self.instruments == other.instruments and \\\n            self.show_measure_numbers == other.show_measure_numbers and \\\n            self.spine_ids == other.spine_ids\n\n    def __ne__(self, other: 'ExportOptions') -&gt; bool:\n        \"\"\"\n        Compare two ExportOptions objects.\n\n        Args:\n            other (ExportOptions): The other ExportOptions object to compare.\n\n        Returns (bool):\n            True if the objects are not equal, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options1 != options2\n            False\n\n            &gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n            &gt;&gt;&gt; options1 != options3\n            True\n        \"\"\"\n        return not self.__eq__(other)\n\n    @classmethod\n    def default(cls):\n        return cls(\n            spine_types=deepcopy(HEADERS),\n            token_categories=[c for c in TokenCategory],\n            from_measure=None,\n            to_measure=None,\n            kern_type=Encoding.normalizedKern,\n            instruments=None,\n            show_measure_numbers=False,\n            spine_ids=None\n        )\n</code></pre>"},{"location":"reference/#kernpy.core.ExportOptions.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two ExportOptions objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'ExportOptions'</code> <p>The other ExportOptions object to compare.</p> required <p>Returns (bool):     True if the objects are equal, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 == options2\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 == options3\nFalse\n</code></pre> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def __eq__(self, other: 'ExportOptions') -&gt; bool:\n    \"\"\"\n    Compare two ExportOptions objects.\n\n    Args:\n        other: The other ExportOptions object to compare.\n\n    Returns (bool):\n        True if the objects are equal, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options1 == options2\n        True\n\n        &gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options1 == options3\n        False\n    \"\"\"\n    return self.spine_types == other.spine_types and \\\n        self.token_categories == other.token_categories and \\\n        self.from_measure == other.from_measure and \\\n        self.to_measure == other.to_measure and \\\n        self.kern_type == other.kern_type and \\\n        self.instruments == other.instruments and \\\n        self.show_measure_numbers == other.show_measure_numbers and \\\n        self.spine_ids == other.spine_ids\n</code></pre>"},{"location":"reference/#kernpy.core.ExportOptions.__init__","title":"<code>__init__(spine_types=None, token_categories=None, from_measure=None, to_measure=None, kern_type=Encoding.normalizedKern, instruments=None, show_measure_numbers=False, spine_ids=None)</code>","text":"<p>Create a new ExportOptions object.</p> <p>Parameters:</p> Name Type Description Default <code>spine_types</code> <code>Iterable</code> <p>kern, mens, etc...</p> <code>None</code> <code>token_categories</code> <code>Iterable</code> <p>TokenCategory</p> <code>None</code> <code>from_measure</code> <code>int</code> <p>The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1</p> <code>None</code> <code>to_measure</code> <code>int</code> <p>The measure to end exporting. When None, the exporter will end at the end of the file.</p> <code>None</code> <code>kern_type</code> <code>Encoding</code> <p>The type of the kern file to export.</p> <code>normalizedKern</code> <code>instruments</code> <code>Iterable</code> <p>The instruments to export. When None, all the instruments will be exported.</p> <code>None</code> <code>show_measure_numbers</code> <code>Bool</code> <p>Show the measure numbers in the exported file.</p> <code>False</code> <code>spine_ids</code> <code>Iterable</code> <p>The ids of the spines to export. When None, all the spines will be exported. Spines ids start from 0 and they are increased by 1.</p> <code>None</code> Example <p>import kernpy</p> <p>Create the importer and read the file</p> <p>hi = Importer() document = hi.import_file('file.krn') exporter = Exporter()</p> <p>Export the file with the specified options</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES) exported_data = exporter.export_string(document, options)</p> <p>Export only the lyrics</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LYRICS]) exported_data = exporter.export_string(document, options)</p> <p>Export the comments</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LINE_COMMENTS, TokenCategory.FIELD_COMMENTS]) exported_data = exporter.export_string(document, options)</p> <p>Export using the eKern version</p> <p>options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES, kern_type=Encoding.eKern) exported_data = exporter.export_string(document, options)</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def __init__(\n        self,\n        spine_types: [] = None,\n        token_categories: [] = None,\n        from_measure: int = None,\n        to_measure: int = None,\n        kern_type: Encoding = Encoding.normalizedKern,\n        instruments: [] = None,\n        show_measure_numbers: bool = False,\n        spine_ids: [int] = None\n):\n    \"\"\"\n    Create a new ExportOptions object.\n\n    Args:\n        spine_types (Iterable): **kern, **mens, etc...\n        token_categories (Iterable): TokenCategory\n        from_measure (int): The measure to start exporting. When None, the exporter will start from the beginning of the file. The first measure is 1\n        to_measure (int): The measure to end exporting. When None, the exporter will end at the end of the file.\n        kern_type (Encoding): The type of the kern file to export.\n        instruments (Iterable): The instruments to export. When None, all the instruments will be exported.\n        show_measure_numbers (Bool): Show the measure numbers in the exported file.\n        spine_ids (Iterable): The ids of the spines to export. When None, all the spines will be exported. Spines ids start from 0 and they are increased by 1.\n\n    Example:\n        &gt;&gt;&gt; import kernpy\n\n        Create the importer and read the file\n        &gt;&gt;&gt; hi = Importer()\n        &gt;&gt;&gt; document = hi.import_file('file.krn')\n        &gt;&gt;&gt; exporter = Exporter()\n\n        Export the file with the specified options\n        &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n        Export only the lyrics\n        &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LYRICS])\n        &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n        Export the comments\n        &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=[TokenCategory.LINE_COMMENTS, TokenCategory.FIELD_COMMENTS])\n        &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n        Export using the eKern version\n        &gt;&gt;&gt; options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES, kern_type=Encoding.eKern)\n        &gt;&gt;&gt; exported_data = exporter.export_string(document, options)\n\n    \"\"\"\n    self.spine_types = spine_types if spine_types is not None else deepcopy(HEADERS)\n    self.from_measure = from_measure\n    self.to_measure = to_measure\n    self.token_categories = token_categories if token_categories is not None else [c for c in TokenCategory]\n    self.kern_type = kern_type\n    self.instruments = instruments\n    self.show_measure_numbers = show_measure_numbers\n    self.spine_ids = spine_ids  # When exporting, if spine_ids=None all the spines will be exported.\n</code></pre>"},{"location":"reference/#kernpy.core.ExportOptions.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two ExportOptions objects.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>ExportOptions</code> <p>The other ExportOptions object to compare.</p> required <p>Returns (bool):     True if the objects are not equal, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 != options2\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n&gt;&gt;&gt; options1 != options3\nTrue\n</code></pre> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def __ne__(self, other: 'ExportOptions') -&gt; bool:\n    \"\"\"\n    Compare two ExportOptions objects.\n\n    Args:\n        other (ExportOptions): The other ExportOptions object to compare.\n\n    Returns (bool):\n        True if the objects are not equal, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; options1 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options2 = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options1 != options2\n        False\n\n        &gt;&gt;&gt; options3 = ExportOptions(spine_types=['**kern', '**harm'], token_categories=BEKERN_CATEGORIES)\n        &gt;&gt;&gt; options1 != options3\n        True\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.Exporter","title":"<code>Exporter</code>","text":"Source code in <code>kernpy/core/exporter.py</code> <pre><code>class Exporter:\n    def export_string(self, document: Document, options: ExportOptions) -&gt; str:\n        self.export_options_validator(document, options)\n\n        rows = []\n\n        if options.to_measure is not None and options.to_measure &lt; len(document.measure_start_tree_stages):\n\n            if options.to_measure &lt; len(document.measure_start_tree_stages) - 1:\n                to_stage = document.measure_start_tree_stages[\n                    options.to_measure]  # take the barlines from the next coming measure\n            else:\n                to_stage = len(document.tree.stages) - 1  # all stages\n        else:\n            to_stage = len(document.tree.stages) - 1  # all stages\n\n        if options.from_measure:\n            # In case of beginning not from the first measure, we recover the spine creation and the headers\n            # Traversed in reverse order to only include the active spines at the given measure...\n            from_stage = document.measure_start_tree_stages[options.from_measure - 1]\n            next_nodes = document.tree.stages[from_stage]\n            while next_nodes and len(next_nodes) &gt; 0 and next_nodes[0] != document.tree.root:\n                row = []\n                new_next_nodes = []\n                non_place_holder_in_row = False\n                spine_operation_row = False\n                for node in next_nodes:\n                    if isinstance(node.token, SpineOperationToken):\n                        spine_operation_row = True\n                        break\n\n                for node in next_nodes:\n                    content = ''\n                    if isinstance(node.token, HeaderToken) and node.token.encoding in options.spine_types:\n                        content = self.export_token(node.token, options)\n                        non_place_holder_in_row = True\n                    elif spine_operation_row:\n                        # either if it is the split operator that has been cancelled, or the join one\n                        if isinstance(node.token, SpineOperationToken) and (node.token.is_cancelled_at(\n                                from_stage) or node.last_spine_operator_node and node.last_spine_operator_node.token.cancelled_at_stage == node.stage):\n                            content = '*'\n                        else:\n                            content = self.export_token(node.token, options)\n                            non_place_holder_in_row = True\n                    if content:\n                        row.append(content)\n                    new_next_nodes.append(node.parent)\n                next_nodes = new_next_nodes\n                if non_place_holder_in_row:  # if the row contains just place holders due to an ommitted place holder, don't add it\n                    rows.insert(0, row)\n\n            # now, export the signatures\n            node_signatures = None\n            for node in document.tree.stages[from_stage]:\n                node_signature_rows = []\n                for signature_node in node.last_signature_nodes.nodes.values():\n                    if not self.is_signature_cancelled(signature_node, node, from_stage, to_stage):\n                        node_signature_rows.append(self.export_token(signature_node.token, options))\n                if len(node_signature_rows) &gt; 0:\n                    if not node_signatures:\n                        node_signatures = []  # an array for each spine\n                    else:\n                        if len(node_signatures[0]) != len(node_signature_rows):\n                            raise Exception(f'Node signature mismatch: multiple spines with signatures at measure {len(rows)}')  # TODO better message\n                    node_signatures.append(node_signature_rows)\n\n            if node_signatures:\n                for irow in range(len(node_signatures[0])):  # all spines have the same number of rows\n                    row = []\n                    for icol in range(len(node_signatures)):  #len(node_signatures) = number of spines\n                        row.append(node_signatures[icol][irow])\n                    rows.append(row)\n\n        else:\n            from_stage = 0\n            rows = []\n\n        #if not node.token.category == TokenCategory.LINE_COMMENTS and not node.token.category == TokenCategory.FIELD_COMMENTS:\n        for stage in range(from_stage, to_stage + 1):  # to_stage included\n            row = []\n            for node in document.tree.stages[stage]:\n                self.append_row(document=document, node=node, options=options, row=row)\n\n            if len(row) &gt; 0:\n                rows.append(row)\n\n        # now, add the spine terminate row\n        if options.to_measure is not None and len(rows) &gt; 0 and rows[len(rows) - 1][\n            0] != '*-':  # if the terminate is not added yet\n            spine_count = len(rows[len(rows) - 1])\n            row = []\n            for i in range(spine_count):\n                row.append('*-')\n            rows.append(row)\n\n        result = \"\"\n        for row in rows:\n            if not empty_row(row):\n                result += '\\t'.join(row) + '\\n'\n        return result\n\n    def compute_header_type(self, node) -&gt; Optional[HeaderToken]:\n        \"\"\"\n        Compute the header type of the node.\n\n        Args:\n            node (Node): The node to compute.\n\n        Returns (Optional[Token]): The header type `Node`object. None if the current node is the header.\n\n        \"\"\"\n        if isinstance(node.token, HeaderToken):\n            header_type = node.token\n        elif node.header_node:\n            header_type = node.header_node.token\n        else:\n            header_type = None\n        return header_type\n\n    def export_token(self, token: Token, options: ExportOptions) -&gt; str:\n        if isinstance(token, HeaderToken):\n            new_token = HeaderTokenGenerator.new(token=token, type=options.kern_type)\n        else:\n            new_token = token\n        return (TokenizerFactory\n                .create(options.kern_type.value, token_categories=options.token_categories)\n                .tokenize(new_token))\n\n    def append_row(self, document: Document, node, options: ExportOptions, row: list) -&gt; bool:\n        \"\"\"\n        Append a row to the row list if the node accomplishes the requirements.\n        Args:\n            document (Document): The document with the spines.\n            node (Node): The node to append.\n            options (ExportOptions): The export options to filter the token.\n            row (list): The row to append.\n\n        Returns (bool): True if the row was appended. False if the row was not appended.\n        \"\"\"\n        header_type = self.compute_header_type(node)\n\n        if (header_type is not None\n                and header_type.encoding in options.spine_types\n                and not node.token.hidden\n                and (isinstance(node.token, ComplexToken) or node.token.category in options.token_categories)\n                and (options.spine_ids is None or header_type.spine_id in options.spine_ids)\n        # If None, all the spines will be exported. TODO: put all the spines as spine_ids = None\n        ):\n            row.append(self.export_token(node.token, options))\n            return True\n\n        return False\n\n    def get_spine_types(self, document: Document, spine_types: list = None):\n        \"\"\"\n        Get the spine types from the document.\n\n        Args:\n            document (Document): The document with the spines.\n            spine_types (list): The spine types to export. If None, all the spine types will be exported.\n\n        Returns: A list with the spine types.\n\n        Examples:\n            &gt;&gt;&gt; exporter = Exporter()\n            &gt;&gt;&gt; exporter.get_spine_types(document)\n            ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n            &gt;&gt;&gt; exporter.get_spine_types(document, None)\n            ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n            &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern'])\n            ['**kern', '**kern', '**kern', '**kern']\n            &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root'])\n            ['**kern', '**kern', '**kern', '**kern', '**root']\n            &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root', '**harm'])\n            ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n            &gt;&gt;&gt; exporter.get_spine_types(document, [])\n            []\n        \"\"\"\n        if spine_types is not None and len(spine_types) == 0:\n            return []\n\n        options = ExportOptions(spine_types=spine_types, token_categories=[TokenCategory.HEADER])\n        content = self.export_string(document, options)\n\n        # Remove all after the first line: **kern, **mens, etc... are always in the first row\n        lines = content.split('\\n')\n        first_line = lines[0:1]\n        tokens = first_line[0].split('\\t')\n\n        return tokens if tokens not in [[], ['']] else []\n\n\n    @classmethod\n    def export_options_validator(cls, document: Document, options: ExportOptions) -&gt; None:\n        \"\"\"\n        Validate the export options. Raise an exception if the options are invalid.\n\n        Args:\n            document: `Document` - The document to export.\n            options: `ExportOptions` - The options to export the document.\n\n        Returns: None\n\n        Example:\n            &gt;&gt;&gt; export_options_validator(document, options)\n            ValueError: option from_measure must be &gt;=0 but -1 was found.\n            &gt;&gt;&gt; export_options_validator(document, options2)\n            None\n        \"\"\"\n        if options.from_measure is not None and options.from_measure &lt; 0:\n            raise ValueError(f'option from_measure must be &gt;=0 but {options.from_measure} was found. ')\n        if options.to_measure is not None and options.to_measure &gt; len(document.measure_start_tree_stages):\n            # \"TODO: DAVID, check options.to_measure bounds. len(document.measure_start_tree_stages) or len(document.measure_start_tree_stages) - 1\"\n            raise ValueError(\n                f'option to_measure must be &lt;= {len(document.measure_start_tree_stages)} but {options.to_measure} was found. ')\n        if options.to_measure is not None and options.from_measure is not None and options.to_measure &lt; options.from_measure:\n            raise ValueError(\n                f'option to_measure must be &gt;= from_measure but {options.to_measure} &lt; {options.from_measure} was found. ')\n\n    def is_signature_cancelled(self, signature_node, node, from_stage, to_stage) -&gt; bool:\n        if node.token.__class__ == signature_node.token.__class__:\n            return True\n        elif isinstance(node.token, NoteRestToken):\n            return False\n        elif from_stage &lt; to_stage:\n            for child in node.children:\n                if self.is_signature_cancelled(signature_node, child, from_stage + 1, to_stage):\n                    return True\n            return False\n</code></pre>"},{"location":"reference/#kernpy.core.Exporter.append_row","title":"<code>append_row(document, node, options, row)</code>","text":"<p>Append a row to the row list if the node accomplishes the requirements. Args:     document (Document): The document with the spines.     node (Node): The node to append.     options (ExportOptions): The export options to filter the token.     row (list): The row to append.</p> <p>Returns (bool): True if the row was appended. False if the row was not appended.</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def append_row(self, document: Document, node, options: ExportOptions, row: list) -&gt; bool:\n    \"\"\"\n    Append a row to the row list if the node accomplishes the requirements.\n    Args:\n        document (Document): The document with the spines.\n        node (Node): The node to append.\n        options (ExportOptions): The export options to filter the token.\n        row (list): The row to append.\n\n    Returns (bool): True if the row was appended. False if the row was not appended.\n    \"\"\"\n    header_type = self.compute_header_type(node)\n\n    if (header_type is not None\n            and header_type.encoding in options.spine_types\n            and not node.token.hidden\n            and (isinstance(node.token, ComplexToken) or node.token.category in options.token_categories)\n            and (options.spine_ids is None or header_type.spine_id in options.spine_ids)\n    # If None, all the spines will be exported. TODO: put all the spines as spine_ids = None\n    ):\n        row.append(self.export_token(node.token, options))\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/#kernpy.core.Exporter.compute_header_type","title":"<code>compute_header_type(node)</code>","text":"<p>Compute the header type of the node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>The node to compute.</p> required <p>Returns (Optional[Token]): The header type <code>Node</code>object. None if the current node is the header.</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def compute_header_type(self, node) -&gt; Optional[HeaderToken]:\n    \"\"\"\n    Compute the header type of the node.\n\n    Args:\n        node (Node): The node to compute.\n\n    Returns (Optional[Token]): The header type `Node`object. None if the current node is the header.\n\n    \"\"\"\n    if isinstance(node.token, HeaderToken):\n        header_type = node.token\n    elif node.header_node:\n        header_type = node.header_node.token\n    else:\n        header_type = None\n    return header_type\n</code></pre>"},{"location":"reference/#kernpy.core.Exporter.export_options_validator","title":"<code>export_options_validator(document, options)</code>  <code>classmethod</code>","text":"<p>Validate the export options. Raise an exception if the options are invalid.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p><code>Document</code> - The document to export.</p> required <code>options</code> <code>ExportOptions</code> <p><code>ExportOptions</code> - The options to export the document.</p> required <p>Returns: None</p> Example <p>export_options_validator(document, options) ValueError: option from_measure must be &gt;=0 but -1 was found. export_options_validator(document, options2) None</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>@classmethod\ndef export_options_validator(cls, document: Document, options: ExportOptions) -&gt; None:\n    \"\"\"\n    Validate the export options. Raise an exception if the options are invalid.\n\n    Args:\n        document: `Document` - The document to export.\n        options: `ExportOptions` - The options to export the document.\n\n    Returns: None\n\n    Example:\n        &gt;&gt;&gt; export_options_validator(document, options)\n        ValueError: option from_measure must be &gt;=0 but -1 was found.\n        &gt;&gt;&gt; export_options_validator(document, options2)\n        None\n    \"\"\"\n    if options.from_measure is not None and options.from_measure &lt; 0:\n        raise ValueError(f'option from_measure must be &gt;=0 but {options.from_measure} was found. ')\n    if options.to_measure is not None and options.to_measure &gt; len(document.measure_start_tree_stages):\n        # \"TODO: DAVID, check options.to_measure bounds. len(document.measure_start_tree_stages) or len(document.measure_start_tree_stages) - 1\"\n        raise ValueError(\n            f'option to_measure must be &lt;= {len(document.measure_start_tree_stages)} but {options.to_measure} was found. ')\n    if options.to_measure is not None and options.from_measure is not None and options.to_measure &lt; options.from_measure:\n        raise ValueError(\n            f'option to_measure must be &gt;= from_measure but {options.to_measure} &lt; {options.from_measure} was found. ')\n</code></pre>"},{"location":"reference/#kernpy.core.Exporter.get_spine_types","title":"<code>get_spine_types(document, spine_types=None)</code>","text":"<p>Get the spine types from the document.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>The document with the spines.</p> required <code>spine_types</code> <code>list</code> <p>The spine types to export. If None, all the spine types will be exported.</p> <code>None</code> <p>Returns: A list with the spine types.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; exporter = Exporter()\n&gt;&gt;&gt; exporter.get_spine_types(document)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern'])\n['**kern', '**kern', '**kern', '**kern']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root'])\n['**kern', '**kern', '**kern', '**kern', '**root']\n&gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root', '**harm'])\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; exporter.get_spine_types(document, [])\n[]\n</code></pre> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def get_spine_types(self, document: Document, spine_types: list = None):\n    \"\"\"\n    Get the spine types from the document.\n\n    Args:\n        document (Document): The document with the spines.\n        spine_types (list): The spine types to export. If None, all the spine types will be exported.\n\n    Returns: A list with the spine types.\n\n    Examples:\n        &gt;&gt;&gt; exporter = Exporter()\n        &gt;&gt;&gt; exporter.get_spine_types(document)\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; exporter.get_spine_types(document, None)\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern'])\n        ['**kern', '**kern', '**kern', '**kern']\n        &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root'])\n        ['**kern', '**kern', '**kern', '**kern', '**root']\n        &gt;&gt;&gt; exporter.get_spine_types(document, ['**kern', '**root', '**harm'])\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; exporter.get_spine_types(document, [])\n        []\n    \"\"\"\n    if spine_types is not None and len(spine_types) == 0:\n        return []\n\n    options = ExportOptions(spine_types=spine_types, token_categories=[TokenCategory.HEADER])\n    content = self.export_string(document, options)\n\n    # Remove all after the first line: **kern, **mens, etc... are always in the first row\n    lines = content.split('\\n')\n    first_line = lines[0:1]\n    tokens = first_line[0].split('\\t')\n\n    return tokens if tokens not in [[], ['']] else []\n</code></pre>"},{"location":"reference/#kernpy.core.F3Clef","title":"<code>F3Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class F3Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the F Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('F'), 3)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('B', 3)\n</code></pre>"},{"location":"reference/#kernpy.core.F3Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the F Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the F Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('F'), 3)\n</code></pre>"},{"location":"reference/#kernpy.core.F3Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('B', 3)\n</code></pre>"},{"location":"reference/#kernpy.core.F4Clef","title":"<code>F4Clef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class F4Clef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the F Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('F'), 4)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('G', 2)\n</code></pre>"},{"location":"reference/#kernpy.core.F4Clef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the F Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the F Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('F'), 4)\n</code></pre>"},{"location":"reference/#kernpy.core.F4Clef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('G', 2)\n</code></pre>"},{"location":"reference/#kernpy.core.FieldCommentToken","title":"<code>FieldCommentToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>FieldCommentToken class stores the metacomments of the score. Usually these are comments starting with <code>!!!</code>.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class FieldCommentToken(SimpleToken):\n    \"\"\"\n    FieldCommentToken class stores the metacomments of the score.\n    Usually these are comments starting with `!!!`.\n\n    \"\"\"\n\n    def __init__(self, encoding):\n        super().__init__(encoding, TokenCategory.FIELD_COMMENTS)\n</code></pre>"},{"location":"reference/#kernpy.core.FingSpineImporter","title":"<code>FingSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/fing_spine_importer.py</code> <pre><code>class FingSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()\n\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if not any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.FINGERING)\n\n        return token\n</code></pre>"},{"location":"reference/#kernpy.core.FingSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/fing_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.core.GClef","title":"<code>GClef</code>","text":"<p>               Bases: <code>Clef</code></p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>class GClef(Clef):\n    def __init__(self):\n        \"\"\"\n        Initializes the G Clef object.\n        \"\"\"\n        super().__init__(DiatonicPitch('G'), 2)\n\n    def bottom_line(self) -&gt; AgnosticPitch:\n        \"\"\"\n        Returns the pitch of the bottom line of the staff.\n        \"\"\"\n        return AgnosticPitch('E', 4)\n</code></pre>"},{"location":"reference/#kernpy.core.GClef.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the G Clef object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the G Clef object.\n    \"\"\"\n    super().__init__(DiatonicPitch('G'), 2)\n</code></pre>"},{"location":"reference/#kernpy.core.GClef.bottom_line","title":"<code>bottom_line()</code>","text":"<p>Returns the pitch of the bottom line of the staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def bottom_line(self) -&gt; AgnosticPitch:\n    \"\"\"\n    Returns the pitch of the bottom line of the staff.\n    \"\"\"\n    return AgnosticPitch('E', 4)\n</code></pre>"},{"location":"reference/#kernpy.core.GKernExporter","title":"<code>GKernExporter</code>","text":"Source code in <code>kernpy/core/gkern.py</code> <pre><code>class GKernExporter:\n    def __init__(self, clef: Clef):\n        self.clef = clef\n\n    def export(self, staff: Staff, pitch: AgnosticPitch) -&gt; str:\n        \"\"\"\n        Exports the given pitch to a graphic **kern encoding.\n        \"\"\"\n        position = self.agnostic_position(staff, pitch)\n        return f\"{GRAPHIC_TOKEN_SEPARATOR}{str(position)}\"\n\n    def agnostic_position(self, staff: Staff, pitch: AgnosticPitch) -&gt; PositionInStaff:\n        \"\"\"\n        Returns the agnostic position in staff for the given pitch.\n        \"\"\"\n        return staff.position_in_staff(clef=self.clef, pitch=pitch)\n</code></pre>"},{"location":"reference/#kernpy.core.GKernExporter.agnostic_position","title":"<code>agnostic_position(staff, pitch)</code>","text":"<p>Returns the agnostic position in staff for the given pitch.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def agnostic_position(self, staff: Staff, pitch: AgnosticPitch) -&gt; PositionInStaff:\n    \"\"\"\n    Returns the agnostic position in staff for the given pitch.\n    \"\"\"\n    return staff.position_in_staff(clef=self.clef, pitch=pitch)\n</code></pre>"},{"location":"reference/#kernpy.core.GKernExporter.export","title":"<code>export(staff, pitch)</code>","text":"<p>Exports the given pitch to a graphic **kern encoding.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def export(self, staff: Staff, pitch: AgnosticPitch) -&gt; str:\n    \"\"\"\n    Exports the given pitch to a graphic **kern encoding.\n    \"\"\"\n    position = self.agnostic_position(staff, pitch)\n    return f\"{GRAPHIC_TOKEN_SEPARATOR}{str(position)}\"\n</code></pre>"},{"location":"reference/#kernpy.core.Generic","title":"<code>Generic</code>","text":"<p>Generic class.</p> <p>This class provides support to the public API for KernPy.</p> <p>The main functions implementation are provided here.</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>class Generic:\n    \"\"\"\n    Generic class.\n\n    This class provides support to the public API for KernPy.\n\n    The main functions implementation are provided here.\n    \"\"\"\n\n    @classmethod\n    def read(\n            cls,\n            path: Path,\n            strict: Optional[bool] = False\n    ) -&gt; (Document, List[str]):\n        \"\"\"\n\n        Args:\n            path:\n            strict:\n\n        Returns:\n\n        \"\"\"\n        importer = Importer()\n        document = importer.import_file(path)\n        errors = importer.errors\n\n        if strict and len(errors) &gt; 0:\n            raise Exception(importer.get_error_messages())\n\n        return document, errors\n\n    @classmethod\n    def create(\n            cls,\n            content: str,\n            strict: Optional[bool] = False\n    ) -&gt; (Document, List[str]):\n        \"\"\"\n\n        Args:\n            content:\n            strict:\n\n        Returns:\n\n        \"\"\"\n        importer = Importer()\n        document = importer.import_string(content)\n        errors = importer.errors\n\n        if strict and len(errors) &gt; 0:\n            raise Exception(importer.get_error_messages())\n\n        return document, errors\n\n    @classmethod\n    def export(\n            cls,\n            document: Document,\n            options: ExportOptions\n    ) -&gt; str:\n        \"\"\"\n\n        Args:\n            document:\n            options:\n\n        Returns:\n\n        \"\"\"\n        exporter = Exporter()\n        return exporter.export_string(document, options)\n\n    @classmethod\n    def store(\n            cls,\n            document: Document,\n            path: Path,\n            options: ExportOptions\n    ) -&gt; None:\n        \"\"\"\n\n        Args:\n            document:\n            path:\n            options:\n\n        Returns:\n        \"\"\"\n        content = cls.export(document, options)\n        _write(path, content)\n\n    @classmethod\n    def store_graph(\n            cls,\n            document: Document,\n            path: Path\n    ) -&gt; None:\n        \"\"\"\n\n        Args:\n            document:\n            path:\n\n        Returns:\n        \"\"\"\n        graph_exporter = GraphvizExporter()\n        graph_exporter.export_to_dot(document.tree, path)\n\n    @classmethod\n    def get_spine_types(\n            cls,\n            document: Document,\n            spine_types: Optional[Sequence[str]] = None\n    ) -&gt; List[str]:\n        \"\"\"\n\n        Args:\n            document:\n            spine_types:\n\n        Returns:\n\n        \"\"\"\n        exporter = Exporter()\n        return exporter.get_spine_types(document, spine_types)\n\n    @classmethod\n    def merge(\n            cls,\n            contents: Sequence[str],\n            strict: Optional[bool] = False\n    ) -&gt; Tuple[Document, List[Tuple[int, int]]]:\n        \"\"\"\n\n        Args:\n            contents:\n            strict:\n\n        Returns:\n\n        \"\"\"\n        if len(contents) &lt; 2:\n            raise ValueError(f\"Concatenation action requires at least two documents to concatenate.\"\n                             f\"But {len(contents)} was given.\")\n\n        raise NotImplementedError(\"The merge function is not implemented yet.\")\n\n        doc_a, err_a = cls.create(contents[0], strict=strict)\n        for i, content in enumerate(contents[1:]):\n            doc_b, err_b = cls.create(content, strict=strict)\n\n            if strict and (len(err_a) &gt; 0 or len(err_b) &gt; 0):\n                raise Exception(f\"Errors were found during the creation of the documents \"\n                                f\"while using the strict=True option. \"\n                                f\"Description: concatenating: {err_a if len(err_a) &gt; 0 else err_b}\")\n\n            doc_a.add(doc_b)\n        return cls.export(\n            document=doc_a,\n            options=options\n        )\n\n    @classmethod\n    def concat(\n            cls,\n            contents: Sequence[str],\n            separator: Optional[str] = None\n    ) -&gt; Tuple[Document, List[Tuple[int, int]]]:\n        \"\"\"\n\n        Args:\n            contents:\n            separator:\n\n        Returns:\n\n        \"\"\"\n        # Raw kern content\n        if separator is None:\n            separator = '\\n'\n\n        if len(contents) == 0:\n            raise ValueError(\"No contents to merge. At least one content is required.\")\n\n        raw_kern = ''\n        document = None\n        indexes = []\n        low_index = 0\n        high_index = 0\n\n        # Merge all fragments\n        for content in contents:\n            raw_kern += separator + content\n            document, _ = create(raw_kern)\n            high_index = document.measures_count()\n            indexes.append((low_index, high_index))\n\n            low_index = high_index + 1  # Next fragment start is the previous fragment end + 1\n\n        if document is None:\n            raise Exception(\"Failed to merge the contents. The document is None.\")\n\n        return document, indexes\n\n    @classmethod\n    def parse_options_to_ExportOptions(\n            cls,\n            **kwargs: Any\n    ) -&gt; ExportOptions:\n        \"\"\"\n\n        Args:\n            **kwargs:\n\n        Returns:\n\n        \"\"\"\n        options = ExportOptions.default()\n\n        # Compute the valid token categories\n        options.token_categories = TokenCategoryHierarchyMapper.valid(\n            include=kwargs.get('include', None),\n            exclude=kwargs.get('exclude', None)\n        )\n\n        # Use kwargs to update the ExportOptions object\n        for key, value in kwargs.items():\n            if key in ['include', 'exclude', 'token_categories']:  # Skip these keys: generated manually\n                continue\n\n            if value is not None:\n                setattr(options, key, value)\n\n        return options\n</code></pre>"},{"location":"reference/#kernpy.core.Generic.concat","title":"<code>concat(contents, separator=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Sequence[str]</code> required <code>separator</code> <code>Optional[str]</code> <code>None</code> <p>Returns:</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>@classmethod\ndef concat(\n        cls,\n        contents: Sequence[str],\n        separator: Optional[str] = None\n) -&gt; Tuple[Document, List[Tuple[int, int]]]:\n    \"\"\"\n\n    Args:\n        contents:\n        separator:\n\n    Returns:\n\n    \"\"\"\n    # Raw kern content\n    if separator is None:\n        separator = '\\n'\n\n    if len(contents) == 0:\n        raise ValueError(\"No contents to merge. At least one content is required.\")\n\n    raw_kern = ''\n    document = None\n    indexes = []\n    low_index = 0\n    high_index = 0\n\n    # Merge all fragments\n    for content in contents:\n        raw_kern += separator + content\n        document, _ = create(raw_kern)\n        high_index = document.measures_count()\n        indexes.append((low_index, high_index))\n\n        low_index = high_index + 1  # Next fragment start is the previous fragment end + 1\n\n    if document is None:\n        raise Exception(\"Failed to merge the contents. The document is None.\")\n\n    return document, indexes\n</code></pre>"},{"location":"reference/#kernpy.core.Generic.create","title":"<code>create(content, strict=False)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> required <code>strict</code> <code>Optional[bool]</code> <code>False</code> <p>Returns:</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>@classmethod\ndef create(\n        cls,\n        content: str,\n        strict: Optional[bool] = False\n) -&gt; (Document, List[str]):\n    \"\"\"\n\n    Args:\n        content:\n        strict:\n\n    Returns:\n\n    \"\"\"\n    importer = Importer()\n    document = importer.import_string(content)\n    errors = importer.errors\n\n    if strict and len(errors) &gt; 0:\n        raise Exception(importer.get_error_messages())\n\n    return document, errors\n</code></pre>"},{"location":"reference/#kernpy.core.Generic.export","title":"<code>export(document, options)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> required <code>options</code> <code>ExportOptions</code> required <p>Returns:</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>@classmethod\ndef export(\n        cls,\n        document: Document,\n        options: ExportOptions\n) -&gt; str:\n    \"\"\"\n\n    Args:\n        document:\n        options:\n\n    Returns:\n\n    \"\"\"\n    exporter = Exporter()\n    return exporter.export_string(document, options)\n</code></pre>"},{"location":"reference/#kernpy.core.Generic.get_spine_types","title":"<code>get_spine_types(document, spine_types=None)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> required <code>spine_types</code> <code>Optional[Sequence[str]]</code> <code>None</code> <p>Returns:</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>@classmethod\ndef get_spine_types(\n        cls,\n        document: Document,\n        spine_types: Optional[Sequence[str]] = None\n) -&gt; List[str]:\n    \"\"\"\n\n    Args:\n        document:\n        spine_types:\n\n    Returns:\n\n    \"\"\"\n    exporter = Exporter()\n    return exporter.get_spine_types(document, spine_types)\n</code></pre>"},{"location":"reference/#kernpy.core.Generic.merge","title":"<code>merge(contents, strict=False)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Sequence[str]</code> required <code>strict</code> <code>Optional[bool]</code> <code>False</code> <p>Returns:</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>@classmethod\ndef merge(\n        cls,\n        contents: Sequence[str],\n        strict: Optional[bool] = False\n) -&gt; Tuple[Document, List[Tuple[int, int]]]:\n    \"\"\"\n\n    Args:\n        contents:\n        strict:\n\n    Returns:\n\n    \"\"\"\n    if len(contents) &lt; 2:\n        raise ValueError(f\"Concatenation action requires at least two documents to concatenate.\"\n                         f\"But {len(contents)} was given.\")\n\n    raise NotImplementedError(\"The merge function is not implemented yet.\")\n\n    doc_a, err_a = cls.create(contents[0], strict=strict)\n    for i, content in enumerate(contents[1:]):\n        doc_b, err_b = cls.create(content, strict=strict)\n\n        if strict and (len(err_a) &gt; 0 or len(err_b) &gt; 0):\n            raise Exception(f\"Errors were found during the creation of the documents \"\n                            f\"while using the strict=True option. \"\n                            f\"Description: concatenating: {err_a if len(err_a) &gt; 0 else err_b}\")\n\n        doc_a.add(doc_b)\n    return cls.export(\n        document=doc_a,\n        options=options\n    )\n</code></pre>"},{"location":"reference/#kernpy.core.Generic.parse_options_to_ExportOptions","title":"<code>parse_options_to_ExportOptions(**kwargs)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <code>{}</code> <p>Returns:</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>@classmethod\ndef parse_options_to_ExportOptions(\n        cls,\n        **kwargs: Any\n) -&gt; ExportOptions:\n    \"\"\"\n\n    Args:\n        **kwargs:\n\n    Returns:\n\n    \"\"\"\n    options = ExportOptions.default()\n\n    # Compute the valid token categories\n    options.token_categories = TokenCategoryHierarchyMapper.valid(\n        include=kwargs.get('include', None),\n        exclude=kwargs.get('exclude', None)\n    )\n\n    # Use kwargs to update the ExportOptions object\n    for key, value in kwargs.items():\n        if key in ['include', 'exclude', 'token_categories']:  # Skip these keys: generated manually\n            continue\n\n        if value is not None:\n            setattr(options, key, value)\n\n    return options\n</code></pre>"},{"location":"reference/#kernpy.core.Generic.read","title":"<code>read(path, strict=False)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> required <code>strict</code> <code>Optional[bool]</code> <code>False</code> <p>Returns:</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>@classmethod\ndef read(\n        cls,\n        path: Path,\n        strict: Optional[bool] = False\n) -&gt; (Document, List[str]):\n    \"\"\"\n\n    Args:\n        path:\n        strict:\n\n    Returns:\n\n    \"\"\"\n    importer = Importer()\n    document = importer.import_file(path)\n    errors = importer.errors\n\n    if strict and len(errors) &gt; 0:\n        raise Exception(importer.get_error_messages())\n\n    return document, errors\n</code></pre>"},{"location":"reference/#kernpy.core.Generic.store","title":"<code>store(document, path, options)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> required <code>path</code> <code>Path</code> required <code>options</code> <code>ExportOptions</code> required <p>Returns:</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>@classmethod\ndef store(\n        cls,\n        document: Document,\n        path: Path,\n        options: ExportOptions\n) -&gt; None:\n    \"\"\"\n\n    Args:\n        document:\n        path:\n        options:\n\n    Returns:\n    \"\"\"\n    content = cls.export(document, options)\n    _write(path, content)\n</code></pre>"},{"location":"reference/#kernpy.core.Generic.store_graph","title":"<code>store_graph(document, path)</code>  <code>classmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> required <code>path</code> <code>Path</code> required <p>Returns:</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>@classmethod\ndef store_graph(\n        cls,\n        document: Document,\n        path: Path\n) -&gt; None:\n    \"\"\"\n\n    Args:\n        document:\n        path:\n\n    Returns:\n    \"\"\"\n    graph_exporter = GraphvizExporter()\n    graph_exporter.export_to_dot(document.tree, path)\n</code></pre>"},{"location":"reference/#kernpy.core.GraphvizExporter","title":"<code>GraphvizExporter</code>","text":"Source code in <code>kernpy/core/graphviz_exporter.py</code> <pre><code>class GraphvizExporter:\n    def export_token(self, token: Token):\n        if token is None or token.encoding is None:\n            return ''\n        else:\n            return token.encoding.replace('\\\"', '\\\\\"').replace('\\\\', '\\\\\\\\')\n\n    @staticmethod\n    def node_id(node: Node):\n        return f\"node{id(node)}\"\n\n    def export_to_dot(self, tree: MultistageTree, filename: Path = None):\n        \"\"\"\n        Export the given MultistageTree to DOT format.\n\n        Args:\n            tree (MultistageTree): The tree to export.\n            filename (Path or None): The output file path. If None, prints to stdout.\n        \"\"\"\n        file = sys.stdout if filename is None else open(filename, 'w')\n\n        try:\n            file.write('digraph G {\\n')\n            file.write('    node [shape=record];\\n')\n            file.write('    rankdir=TB;\\n')  # Ensure top-to-bottom layout\n\n            # Create subgraphs for each stage\n            for stage_index, stage in enumerate(tree.stages):\n                if stage:\n                    file.write('  {rank=same; ')\n                    for node in stage:\n                        file.write(f'\"{self.node_id(node)}\"; ')\n                    file.write('}\\n')\n\n            # Write nodes and their connections\n            self._write_nodes_iterative(tree.root, file)\n            self._write_edges_iterative(tree.root, file)\n\n            file.write('}\\n')\n\n        finally:\n            if filename is not None:\n                file.close()  # Close only if we explicitly opened a file\n\n    def _write_nodes_iterative(self, root, file):\n        stack = [root]\n\n        while stack:\n            node = stack.pop()\n            header_label = f'header #{node.header_node.id}' if node.header_node else ''\n            last_spine_operator_label = f'last spine op. #{node.last_spine_operator_node.id}' if node.last_spine_operator_node else ''\n            category_name = getattr(getattr(getattr(node, \"token\", None), \"category\", None), \"_name_\", \"Non defined category\")\n\n\n            top_record_label = f'{{ #{node.id}| stage {node.stage} | {header_label} | {last_spine_operator_label} | {category_name} }}'\n            signatures_label = ''\n            if node.last_signature_nodes and node.last_signature_nodes.nodes:\n                for k, v in node.last_signature_nodes.nodes.items():\n                    if signatures_label:\n                        signatures_label += '|'\n                    signatures_label += f'{k} #{v.id}'\n\n            if isinstance(node.token, SpineOperationToken) and node.token.cancelled_at_stage:\n                signatures_label += f'| {{ cancelled at stage {node.token.cancelled_at_stage} }}'\n\n            file.write(f'  \"{self.node_id(node)}\" [label=\"{{ {top_record_label} | {signatures_label} | {self.export_token(node.token)} }}\"];\\n')\n\n            # Add children to the stack to be processed\n            for child in reversed(node.children):\n                stack.append(child)\n\n    def _write_edges_iterative(self, root, file):\n        stack = [root]\n\n        while stack:\n            node = stack.pop()\n            for child in node.children:\n                file.write(f'  \"{self.node_id(node)}\" -&gt; \"{self.node_id(child)}\";\\n')\n                stack.append(child)\n</code></pre>"},{"location":"reference/#kernpy.core.GraphvizExporter.export_to_dot","title":"<code>export_to_dot(tree, filename=None)</code>","text":"<p>Export the given MultistageTree to DOT format.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>MultistageTree</code> <p>The tree to export.</p> required <code>filename</code> <code>Path or None</code> <p>The output file path. If None, prints to stdout.</p> <code>None</code> Source code in <code>kernpy/core/graphviz_exporter.py</code> <pre><code>def export_to_dot(self, tree: MultistageTree, filename: Path = None):\n    \"\"\"\n    Export the given MultistageTree to DOT format.\n\n    Args:\n        tree (MultistageTree): The tree to export.\n        filename (Path or None): The output file path. If None, prints to stdout.\n    \"\"\"\n    file = sys.stdout if filename is None else open(filename, 'w')\n\n    try:\n        file.write('digraph G {\\n')\n        file.write('    node [shape=record];\\n')\n        file.write('    rankdir=TB;\\n')  # Ensure top-to-bottom layout\n\n        # Create subgraphs for each stage\n        for stage_index, stage in enumerate(tree.stages):\n            if stage:\n                file.write('  {rank=same; ')\n                for node in stage:\n                    file.write(f'\"{self.node_id(node)}\"; ')\n                file.write('}\\n')\n\n        # Write nodes and their connections\n        self._write_nodes_iterative(tree.root, file)\n        self._write_edges_iterative(tree.root, file)\n\n        file.write('}\\n')\n\n    finally:\n        if filename is not None:\n            file.close()  # Close only if we explicitly opened a file\n</code></pre>"},{"location":"reference/#kernpy.core.HarmSpineImporter","title":"<code>HarmSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/harm_spine_importer.py</code> <pre><code>class HarmSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if not any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.HARMONY)\n\n        return token\n</code></pre>"},{"location":"reference/#kernpy.core.HarmSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/harm_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.core.HeaderToken","title":"<code>HeaderToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>HeaderTokens class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class HeaderToken(SimpleToken):\n    \"\"\"\n    HeaderTokens class.\n    \"\"\"\n\n    def __init__(self, encoding, spine_id: int):\n        \"\"\"\n        Constructor for the HeaderToken class.\n\n        Args:\n            encoding (str): The original representation of the token.\n            spine_id (int): The spine id of the token. The spine id is used to identify the token in the score.\\\n                The spine_id starts from 0 and increases by 1 for each new spine like the following example:\n                **kern  **kern  **kern **dyn **text\n                0   1   2   3   4\n        \"\"\"\n        super().__init__(encoding, TokenCategory.HEADER)\n        self.spine_id = spine_id\n\n    def export(self, **kwargs) -&gt; str:\n        return self.encoding\n</code></pre>"},{"location":"reference/#kernpy.core.HeaderToken.__init__","title":"<code>__init__(encoding, spine_id)</code>","text":"<p>Constructor for the HeaderToken class.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required <code>spine_id</code> <code>int</code> <p>The spine id of the token. The spine id is used to identify the token in the score.                The spine_id starts from 0 and increases by 1 for each new spine like the following example: kern  kern  kern dyn **text 0   1   2   3   4</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding, spine_id: int):\n    \"\"\"\n    Constructor for the HeaderToken class.\n\n    Args:\n        encoding (str): The original representation of the token.\n        spine_id (int): The spine id of the token. The spine id is used to identify the token in the score.\\\n            The spine_id starts from 0 and increases by 1 for each new spine like the following example:\n            **kern  **kern  **kern **dyn **text\n            0   1   2   3   4\n    \"\"\"\n    super().__init__(encoding, TokenCategory.HEADER)\n    self.spine_id = spine_id\n</code></pre>"},{"location":"reference/#kernpy.core.HeaderTokenGenerator","title":"<code>HeaderTokenGenerator</code>","text":"<p>HeaderTokenGenerator class.</p> <p>This class is used to translate the HeaderTokens to the specific tokenizer format.</p> Source code in <code>kernpy/core/exporter.py</code> <pre><code>class HeaderTokenGenerator:\n    \"\"\"\n    HeaderTokenGenerator class.\n\n    This class is used to translate the HeaderTokens to the specific tokenizer format.\n    \"\"\"\n    @classmethod\n    def new(cls, *, token: HeaderToken, type: Encoding):\n        \"\"\"\n        Create a new HeaderTokenGenerator object. Only accepts stardized Humdrum **kern encodings. \n\n        Args:\n            token (HeaderToken): The HeaderToken to be translated.\n            type (Encoding): The tokenizer to be used.\n\n        Examples:\n            &gt;&gt;&gt; header = HeaderToken('**kern', 0)\n            &gt;&gt;&gt; header.encoding\n            '**kern'\n            &gt;&gt;&gt; new_header = HeaderTokenGenerator.new(token=header, type=Encoding.eKern)\n            &gt;&gt;&gt; new_header.encoding\n            '**ekern'\n        \"\"\"\n        new_encoding = f'**{type.prefix()}{token.encoding[2:]}'\n        new_token = HeaderToken(new_encoding, token.spine_id)\n\n        return new_token\n</code></pre>"},{"location":"reference/#kernpy.core.HeaderTokenGenerator.new","title":"<code>new(*, token, type)</code>  <code>classmethod</code>","text":"<p>Create a new HeaderTokenGenerator object. Only accepts stardized Humdrum **kern encodings. </p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>HeaderToken</code> <p>The HeaderToken to be translated.</p> required <code>type</code> <code>Encoding</code> <p>The tokenizer to be used.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; header = HeaderToken('**kern', 0)\n&gt;&gt;&gt; header.encoding\n'**kern'\n&gt;&gt;&gt; new_header = HeaderTokenGenerator.new(token=header, type=Encoding.eKern)\n&gt;&gt;&gt; new_header.encoding\n'**ekern'\n</code></pre> Source code in <code>kernpy/core/exporter.py</code> <pre><code>@classmethod\ndef new(cls, *, token: HeaderToken, type: Encoding):\n    \"\"\"\n    Create a new HeaderTokenGenerator object. Only accepts stardized Humdrum **kern encodings. \n\n    Args:\n        token (HeaderToken): The HeaderToken to be translated.\n        type (Encoding): The tokenizer to be used.\n\n    Examples:\n        &gt;&gt;&gt; header = HeaderToken('**kern', 0)\n        &gt;&gt;&gt; header.encoding\n        '**kern'\n        &gt;&gt;&gt; new_header = HeaderTokenGenerator.new(token=header, type=Encoding.eKern)\n        &gt;&gt;&gt; new_header.encoding\n        '**ekern'\n    \"\"\"\n    new_encoding = f'**{type.prefix()}{token.encoding[2:]}'\n    new_token = HeaderToken(new_encoding, token.spine_id)\n\n    return new_token\n</code></pre>"},{"location":"reference/#kernpy.core.HumdrumPitchImporter","title":"<code>HumdrumPitchImporter</code>","text":"<p>               Bases: <code>PitchImporter</code></p> <p>Represents the pitch in the Humdrum Kern format.</p> <p>The name is represented using the International Standard Organization (ISO) name notation. The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.</p> <p>The Humdrum Kern format uses the following name representation: 'c' = C4 'cc' = C5 'ccc' = C6 'cccc' = C7</p> <p>'C' = C3 'CC' = C2 'CCC' = C1</p> <p>This class do not limit the name ranges.</p> <p>In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.</p> <pre><code>**kern\n*clefG2\n2c          // C4\n2cc         // C5\n2ccc        // C6\n2C          // C3\n2CC         // C2\n2CCC        // C1\n*-\n</code></pre> Source code in <code>kernpy/core/pitch_models.py</code> <pre><code>class HumdrumPitchImporter(PitchImporter):\n    \"\"\"\n    Represents the pitch in the Humdrum Kern format.\n\n    The name is represented using the International Standard Organization (ISO) name notation.\n    The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.\n\n    The Humdrum Kern format uses the following name representation:\n    'c' = C4\n    'cc' = C5\n    'ccc' = C6\n    'cccc' = C7\n\n    'C' = C3\n    'CC' = C2\n    'CCC' = C1\n\n    This class do not limit the name ranges.\n\n    In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.\n    ```\n    **kern\n    *clefG2\n    2c          // C4\n    2cc         // C5\n    2ccc        // C6\n    2C          // C3\n    2CC         // C2\n    2CCC        // C1\n    *-\n    ```\n    \"\"\"\n    C4_PITCH_LOWERCASE = 'c'\n    C4_OCATAVE = 4\n    C3_PITCH_UPPERCASE = 'C'\n    C3_OCATAVE = 3\n    VALID_PITCHES = 'abcdefg' + 'ABCDEFG'\n\n    def __init__(self):\n        super().__init__()\n\n    def import_pitch(self, encoding: str) -&gt; AgnosticPitch:\n        self.name, self.octave = self._parse_pitch(encoding)\n        return AgnosticPitch(self.name, self.octave)\n\n    def _parse_pitch(self, encoding: str) -&gt; tuple:\n        accidentals = ''.join([c for c in encoding if c in ['#', '-']])\n        accidentals = accidentals.replace('#', '+')\n        encoding = encoding.replace('#', '').replace('-', '')\n        pitch = encoding[0].lower()\n        octave = None\n        if encoding[0].islower():\n            min_octave = HumdrumPitchImporter.C4_OCATAVE\n            octave = min_octave + (len(encoding) - 1)\n        elif encoding[0].isupper():\n            max_octave = HumdrumPitchImporter.C3_OCATAVE\n            octave = max_octave - (len(encoding) - 1)\n        name = f\"{pitch}{accidentals}\"\n        return name, octave\n</code></pre>"},{"location":"reference/#kernpy.core.Importer","title":"<code>Importer</code>","text":"<p>Importer class.</p> <p>Use this class to import the content from a file or a string to a <code>Document</code> object.</p> Source code in <code>kernpy/core/importer.py</code> <pre><code>class Importer:\n    \"\"\"\n    Importer class.\n\n    Use this class to import the content from a file or a string to a `Document` object.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Create an instance of the importer.\n\n        Raises:\n            Exception: If the importer content is not a valid **kern file.\n\n        Examples:\n            # Create the importer\n            &gt;&gt;&gt; importer = Importer()\n\n            # Import the content from a file\n            &gt;&gt;&gt; document = importer.import_file('file.krn')\n\n            # Import the content from a string\n            &gt;&gt;&gt; document = importer.import_string(\"**kern\\n*clefF4\\nc4\\n4d\\n4e\\n4f\\n*-\")\n        \"\"\"\n        self.last_measure_number = None\n        self.last_bounding_box = None\n        self.errors = []\n\n        self._tree = MultistageTree()\n        self._document = Document(self._tree)\n        self._importers = {}\n        self._header_row_number = None\n        self._row_number = 1\n        self._tree_stage = 0\n        self._next_stage_parents = None\n        self._prev_stage_parents = None\n        self._last_node_previous_to_header = self._tree.root\n\n    @staticmethod\n    def get_last_spine_operator(parent):\n        if parent is None:\n            return None\n        elif isinstance(parent.token, SpineOperationToken):\n            return parent\n        else:\n            return parent.last_spine_operator_node\n\n    #TODO Documentar c\u00f3mo propagamos los header_node y last_spine_operator_node...\n    def run(self, reader) -&gt; Document:\n        for row in reader:\n            if len(row) &lt;= 0:\n                # Found an empty row, usually the last one. Ignore it.\n                continue\n\n            self._tree_stage = self._tree_stage + 1\n            is_barline = False\n            if self._next_stage_parents:\n                self._prev_stage_parents = copy(self._next_stage_parents)\n            self._next_stage_parents = []\n\n            if row[0].startswith(\"!!\"):\n                self._compute_metacomment_token(row[0].strip())\n            else:\n                for icolumn, column in enumerate(row):\n                    if column.startswith(\"**\"):\n                        self._compute_header_token(icolumn, column)\n                        # go to next row\n                        continue\n\n                    if column in SPINE_OPERATIONS:\n                        self._compute_spine_operator_token(icolumn, column, row)\n                    else:  # column is not a spine operation\n                        if column.startswith(\"!\"):\n                            token = FieldCommentToken(column)\n                        else:\n                            if self._prev_stage_parents is None:\n                                raise ValueError(f'Any spine header found in the column #{icolumn}. '\n                                                 f'Expected a previous line with valid content. '\n                                                 f'The token in column #{icolumn} and row #{self._row_number - 1}'\n                                                 f' was not created correctly. Error detected in '\n                                                 f'column #{icolumn} in row #{self._row_number}. '\n                                                 f'Found {column}. ')\n                            if icolumn &gt;= len(self._prev_stage_parents):\n                                # TODO: Try to fix the kern in runtime. Add options to public API\n                                # continue  # ignore the column\n                                raise ValueError(f'Wrong columns number in row {self._row_number}. '\n                                                 f'The token in column #{icolumn} and row #{self._row_number}'\n                                                 f' has more columns than expected in its row. '\n                                                 f'Expected {len(self._prev_stage_parents)} columns '\n                                                 f'but found {len(row)}.')\n                            parent = self._prev_stage_parents[icolumn]\n                            if not parent:\n                                raise Exception(f'Cannot find a parent node for column #{icolumn} in row {self._row_number}')\n                            if not parent.header_node:\n                                raise Exception(f'Cannot find a header node for column #{icolumn} in row {self._row_number}')\n                            importer = self._importers.get(parent.header_node.token.encoding)\n                            if not importer:\n                                raise Exception(f'Cannot find an importer for header {parent.header_node.token.encoding}')\n                            try:\n                                token = importer.import_token(column)\n                            except Exception as error:\n                                token = ErrorToken(column, self._row_number, str(error))\n                                self.errors.append(token)\n                        if not token:\n                            raise Exception(\n                                f'No token generated for input {column} in row number #{self._row_number} using importer {importer}')\n\n                        parent = self._prev_stage_parents[icolumn]\n                        node = self._tree.add_node(self._tree_stage, parent, token, self.get_last_spine_operator(parent), parent.last_signature_nodes, parent.header_node)\n                        self._next_stage_parents.append(node)\n\n                        if (token.category == TokenCategory.BARLINES\n                                or TokenCategory.is_child(child=token.category, parent=TokenCategory.CORE)\n                                    and len(self._document.measure_start_tree_stages) == 0):\n                            is_barline = True\n                        elif isinstance(token, BoundingBoxToken):\n                            self.handle_bounding_box(self._document, token)\n                        elif isinstance(token, SignatureToken):\n                            node.last_signature_nodes.update(node)\n\n                if is_barline:\n                    self._document.measure_start_tree_stages.append(self._tree_stage)\n                    self.last_measure_number = len(self._document.measure_start_tree_stages)\n                    if self.last_bounding_box:\n                        self.last_bounding_box.to_measure = self.last_measure_number\n            self._row_number = self._row_number + 1\n        return self._document\n\n    def handle_bounding_box(self, document: Document, token: BoundingBoxToken):\n        page_number = token.page_number\n        last_page_bb = document.page_bounding_boxes.get(page_number)\n        if last_page_bb is None:\n            if self.last_measure_number is None:\n                self.last_measure_number = 0\n            self.last_bounding_box = BoundingBoxMeasures(token.bounding_box, self.last_measure_number,\n                                                         self.last_measure_number)\n            document.page_bounding_boxes[page_number] = self.last_bounding_box\n        else:\n            last_page_bb.bounding_box.extend(token.bounding_box)\n            last_page_bb.to_measure = self.last_measure_number\n\n    def import_file(self, file_path: Path) -&gt; Document:\n        \"\"\"\n        Import the content from the importer to the file.\n        Args:\n            file_path: The path to the file.\n\n        Returns:\n            Document - The document with the imported content.\n\n        Examples:\n            # Create the importer and read the file\n            &gt;&gt;&gt; importer = Importer()\n            &gt;&gt;&gt; importer.import_file('file.krn')\n        \"\"\"\n        with open(file_path, 'r', newline='', encoding='utf-8', errors='ignore') as file:\n            reader = csv.reader(file, delimiter='\\t')\n            return self.run(reader)\n\n    def import_string(self, text: str) -&gt; Document:\n        \"\"\"\n        Import the content from the content of the score in string format.\n\n        Args:\n            text: The content of the score in string format.\n\n        Returns:\n            Document - The document with the imported content.\n\n        Examples:\n            # Create the importer and read the file\n            &gt;&gt;&gt; importer = Importer()\n            &gt;&gt;&gt; importer.import_string(\"**kern\\n*clefF4\\nc4\\n4d\\n4e\\n4f\\n*-\")\n            # Read the content from a file\n            &gt;&gt;&gt; with open('file.krn',  'r', newline='', encoding='utf-8', errors='ignore') as f: # We encourage you to use these open file options\n            &gt;&gt;&gt;     content = f.read()\n            &gt;&gt;&gt; importer.import_string(content)\n            &gt;&gt;&gt; document = importer.import_string(content)\n        \"\"\"\n        lines = text.splitlines()\n        reader = csv.reader(lines, delimiter='\\t')\n        return self.run(reader)\n\n    def get_error_messages(self) -&gt; str:\n        \"\"\"\n        Get the error messages of the importer.\n\n        Returns: str - The error messages split by a new line character.\n\n        Examples:\n            # Create the importer and read the file\n            &gt;&gt;&gt; importer = Importer()\n            &gt;&gt;&gt; importer.import_file(Path('file.krn'))\n            &gt;&gt;&gt; print(importer.get_error_messages())\n            'Error: Invalid token in row 1'\n        \"\"\"\n        result = ''\n        for err in self.errors:\n            result += str(err)\n            result += '\\n'\n        return result\n\n    def has_errors(self) -&gt; bool:\n        \"\"\"\n        Check if the importer has any errors.\n\n        Returns: bool - True if the importer has errors, False otherwise.\n\n        Examples:\n            # Create the importer and read the file\n            &gt;&gt;&gt; importer = Importer()\n            &gt;&gt;&gt; importer.import_file(Path('file.krn'))    # file.krn has an error\n            &gt;&gt;&gt; print(importer.has_errors())\n            True\n            &gt;&gt;&gt; importer.import_file(Path('file2.krn'))   # file2.krn has no errors\n            &gt;&gt;&gt; print(importer.has_errors())\n            False\n        \"\"\"\n        return len(self.errors) &gt; 0\n\n    def _compute_metacomment_token(self, raw_token: str):\n        token = MetacommentToken(raw_token)\n        if self._header_row_number is None:\n            node = self._tree.add_node(self._tree_stage, self._last_node_previous_to_header, token, None, None, None)\n            self._last_node_previous_to_header = node\n        else:\n            for parent in self._prev_stage_parents:\n                node = self._tree.add_node(self._tree_stage, parent, token, self.get_last_spine_operator(parent), parent.last_signature_nodes, parent.header_node) # the same reference for all spines - TODO Recordar documentarlo\n                self._next_stage_parents.append(node)\n\n    def _compute_header_token(self, column_index: int, column_content: str):\n        if self._header_row_number is not None and self._header_row_number != self._row_number:\n            raise Exception(\n                f\"Several header rows not supported, there is a header row in #{self._header_row_number} and another in #{self._row_number} \")\n\n            # it's a spine header\n        self._document.header_stage = self._tree_stage\n        importer = self._importers.get(column_content)\n        if not importer:\n            importer = createImporter(column_content)\n            self._importers[column_content] = importer\n\n        token = HeaderToken(column_content, spine_id=column_index)\n        node = self._tree.add_node(self._tree_stage, self._last_node_previous_to_header, token, None, None)\n        node.header_node = node # this value will be propagated\n        self._next_stage_parents.append(node)\n\n    def _compute_spine_operator_token(self, column_index: int, column_content: str, row: List[str]):\n        token = SpineOperationToken(column_content)\n\n        if column_index &gt;= len(self._prev_stage_parents):\n            raise Exception(f'Expected at least {column_index+1} parents in row {self._row_number}, but found {len(self._prev_stage_parents)}: {row}')\n\n        parent = self._prev_stage_parents[column_index]\n        node = self._tree.add_node(self._tree_stage, parent, token, self.get_last_spine_operator(parent), parent.last_signature_nodes, parent.header_node)\n\n        if column_content == '*-':\n            if node.last_spine_operator_node is not None:\n                node.last_spine_operator_node.token.cancelled_at_stage = self._tree_stage\n            pass # it's terminated, no continuation\n        elif column_content == \"*+\" or column_content == \"*^\":\n            self._next_stage_parents.append(node)\n            self._next_stage_parents.append(node) # twice, the next stage two children will have this one as parent\n        elif column_content == \"*v\":\n            if node.last_spine_operator_node is not None:\n                node.last_spine_operator_node.token.cancelled_at_stage = self._tree_stage\n\n            if column_index == 0 or row[column_index-1] != '*v' or self._prev_stage_parents[column_index-1].header_node != self._prev_stage_parents[column_index].header_node: # don't collapse two different spines\n                self._next_stage_parents.append(node) # just one spine each two\n        else:\n            raise Exception(f'Unknown spine operation in column #{column_content} and row #{self._row_number}')\n</code></pre>"},{"location":"reference/#kernpy.core.Importer.__init__","title":"<code>__init__()</code>","text":"<pre><code>    Create an instance of the importer.\n\n    Raises:\n        Exception: If the importer content is not a valid **kern file.\n\n    Examples:\n        # Create the importer\n        &gt;&gt;&gt; importer = Importer()\n\n        # Import the content from a file\n        &gt;&gt;&gt; document = importer.import_file('file.krn')\n\n        # Import the content from a string\n        &gt;&gt;&gt; document = importer.import_string(\"**kern\n</code></pre> <p>clefF4 c4 4d 4e 4f -\")</p> Source code in <code>kernpy/core/importer.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Create an instance of the importer.\n\n    Raises:\n        Exception: If the importer content is not a valid **kern file.\n\n    Examples:\n        # Create the importer\n        &gt;&gt;&gt; importer = Importer()\n\n        # Import the content from a file\n        &gt;&gt;&gt; document = importer.import_file('file.krn')\n\n        # Import the content from a string\n        &gt;&gt;&gt; document = importer.import_string(\"**kern\\n*clefF4\\nc4\\n4d\\n4e\\n4f\\n*-\")\n    \"\"\"\n    self.last_measure_number = None\n    self.last_bounding_box = None\n    self.errors = []\n\n    self._tree = MultistageTree()\n    self._document = Document(self._tree)\n    self._importers = {}\n    self._header_row_number = None\n    self._row_number = 1\n    self._tree_stage = 0\n    self._next_stage_parents = None\n    self._prev_stage_parents = None\n    self._last_node_previous_to_header = self._tree.root\n</code></pre>"},{"location":"reference/#kernpy.core.Importer.get_error_messages","title":"<code>get_error_messages()</code>","text":"<p>Get the error messages of the importer.</p> <p>Returns: str - The error messages split by a new line character.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.core.Importer.get_error_messages--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file(Path('file.krn'))\n&gt;&gt;&gt; print(importer.get_error_messages())\n'Error: Invalid token in row 1'\n</code></pre> Source code in <code>kernpy/core/importer.py</code> <pre><code>def get_error_messages(self) -&gt; str:\n    \"\"\"\n    Get the error messages of the importer.\n\n    Returns: str - The error messages split by a new line character.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_file(Path('file.krn'))\n        &gt;&gt;&gt; print(importer.get_error_messages())\n        'Error: Invalid token in row 1'\n    \"\"\"\n    result = ''\n    for err in self.errors:\n        result += str(err)\n        result += '\\n'\n    return result\n</code></pre>"},{"location":"reference/#kernpy.core.Importer.has_errors","title":"<code>has_errors()</code>","text":"<p>Check if the importer has any errors.</p> <p>Returns: bool - True if the importer has errors, False otherwise.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.core.Importer.has_errors--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file(Path('file.krn'))    # file.krn has an error\n&gt;&gt;&gt; print(importer.has_errors())\nTrue\n&gt;&gt;&gt; importer.import_file(Path('file2.krn'))   # file2.krn has no errors\n&gt;&gt;&gt; print(importer.has_errors())\nFalse\n</code></pre> Source code in <code>kernpy/core/importer.py</code> <pre><code>def has_errors(self) -&gt; bool:\n    \"\"\"\n    Check if the importer has any errors.\n\n    Returns: bool - True if the importer has errors, False otherwise.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_file(Path('file.krn'))    # file.krn has an error\n        &gt;&gt;&gt; print(importer.has_errors())\n        True\n        &gt;&gt;&gt; importer.import_file(Path('file2.krn'))   # file2.krn has no errors\n        &gt;&gt;&gt; print(importer.has_errors())\n        False\n    \"\"\"\n    return len(self.errors) &gt; 0\n</code></pre>"},{"location":"reference/#kernpy.core.Importer.import_file","title":"<code>import_file(file_path)</code>","text":"<p>Import the content from the importer to the file. Args:     file_path: The path to the file.</p> <p>Returns:</p> Type Description <code>Document</code> <p>Document - The document with the imported content.</p> <p>Examples:</p>"},{"location":"reference/#kernpy.core.Importer.import_file--create-the-importer-and-read-the-file","title":"Create the importer and read the file","text":"<pre><code>&gt;&gt;&gt; importer = Importer()\n&gt;&gt;&gt; importer.import_file('file.krn')\n</code></pre> Source code in <code>kernpy/core/importer.py</code> <pre><code>def import_file(self, file_path: Path) -&gt; Document:\n    \"\"\"\n    Import the content from the importer to the file.\n    Args:\n        file_path: The path to the file.\n\n    Returns:\n        Document - The document with the imported content.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_file('file.krn')\n    \"\"\"\n    with open(file_path, 'r', newline='', encoding='utf-8', errors='ignore') as file:\n        reader = csv.reader(file, delimiter='\\t')\n        return self.run(reader)\n</code></pre>"},{"location":"reference/#kernpy.core.Importer.import_string","title":"<code>import_string(text)</code>","text":"<pre><code>    Import the content from the content of the score in string format.\n\n    Args:\n        text: The content of the score in string format.\n\n    Returns:\n        Document - The document with the imported content.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_string(\"**kern\n</code></pre> <p>clefF4 c4 4d 4e 4f -\")             # Read the content from a file             &gt;&gt;&gt; with open('file.krn',  'r', newline='', encoding='utf-8', errors='ignore') as f: # We encourage you to use these open file options             &gt;&gt;&gt;     content = f.read()             &gt;&gt;&gt; importer.import_string(content)             &gt;&gt;&gt; document = importer.import_string(content)</p> Source code in <code>kernpy/core/importer.py</code> <pre><code>def import_string(self, text: str) -&gt; Document:\n    \"\"\"\n    Import the content from the content of the score in string format.\n\n    Args:\n        text: The content of the score in string format.\n\n    Returns:\n        Document - The document with the imported content.\n\n    Examples:\n        # Create the importer and read the file\n        &gt;&gt;&gt; importer = Importer()\n        &gt;&gt;&gt; importer.import_string(\"**kern\\n*clefF4\\nc4\\n4d\\n4e\\n4f\\n*-\")\n        # Read the content from a file\n        &gt;&gt;&gt; with open('file.krn',  'r', newline='', encoding='utf-8', errors='ignore') as f: # We encourage you to use these open file options\n        &gt;&gt;&gt;     content = f.read()\n        &gt;&gt;&gt; importer.import_string(content)\n        &gt;&gt;&gt; document = importer.import_string(content)\n    \"\"\"\n    lines = text.splitlines()\n    reader = csv.reader(lines, delimiter='\\t')\n    return self.run(reader)\n</code></pre>"},{"location":"reference/#kernpy.core.InstrumentToken","title":"<code>InstrumentToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>InstrumentToken class stores the instruments of the score.</p> <p>These tokens usually look like <code>*I\"Organo</code>.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class InstrumentToken(SimpleToken):\n    \"\"\"\n    InstrumentToken class stores the instruments of the score.\n\n    These tokens usually look like `*I\"Organo`.\n    \"\"\"\n\n    def __init__(self, encoding: str):\n        \"\"\"\n        Constructor for the InstrumentToken\n\n        Args:\n            encoding:\n        \"\"\"\n        super().__init__(encoding, TokenCategory.INSTRUMENTS)\n</code></pre>"},{"location":"reference/#kernpy.core.InstrumentToken.__init__","title":"<code>__init__(encoding)</code>","text":"<p>Constructor for the InstrumentToken</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding: str):\n    \"\"\"\n    Constructor for the InstrumentToken\n\n    Args:\n        encoding:\n    \"\"\"\n    super().__init__(encoding, TokenCategory.INSTRUMENTS)\n</code></pre>"},{"location":"reference/#kernpy.core.KernSpineImporter","title":"<code>KernSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/kern_spine_importer.py</code> <pre><code>class KernSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()\n\n    def import_token(self, encoding: str):\n        self._raise_error_if_wrong_input(encoding)\n\n        # self.listenerImporter = KernListenerImporter(token) # TODO \u00bfPor qu\u00e9 no va esto?\n        # self.listenerImporter.start()\n        lexer = kernSpineLexer(InputStream(encoding))\n        lexer.removeErrorListeners()\n        lexer.addErrorListener(self.error_listener)\n        stream = CommonTokenStream(lexer)\n        parser = kernSpineParser(stream)\n        parser._interp.predictionMode = PredictionMode.SLL  # it improves a lot the parsing\n        parser.removeErrorListeners()\n        parser.addErrorListener(self.error_listener)\n        parser.errHandler = BailErrorStrategy()\n        tree = parser.start()\n        walker = ParseTreeWalker()\n        listener = KernSpineListener()\n        walker.walk(listener, tree)\n        if self.error_listener.getNumberErrorsFound() &gt; 0:\n            raise Exception(self.error_listener.errors)\n        return listener.token\n</code></pre>"},{"location":"reference/#kernpy.core.KernSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/kern_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.core.KernTokenizer","title":"<code>KernTokenizer</code>","text":"<p>               Bases: <code>Tokenizer</code></p> <p>KernTokenizer converts a Token into a normalized kern string representation.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class KernTokenizer(Tokenizer):\n    \"\"\"\n    KernTokenizer converts a Token into a normalized kern string representation.\n    \"\"\"\n    def __init__(self, *, token_categories: Set['TokenCategory']):\n        \"\"\"\n        Create a new KernTokenizer.\n\n        Args:\n            token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n        \"\"\"\n        super().__init__(token_categories=token_categories)\n\n    def tokenize(self, token: Token) -&gt; str:\n        \"\"\"\n        Tokenize a token into a normalized kern string representation.\n        This format is the classic Humdrum **kern representation.\n\n        Args:\n            token (Token): Token to be tokenized.\n\n        Returns (str): Normalized kern string representation. This is the classic Humdrum **kern representation.\n\n        Examples:\n            &gt;&gt;&gt; token.encoding\n            '2@.@bb@-\u00b7_\u00b7L'\n            &gt;&gt;&gt; KernTokenizer().tokenize(token)\n            '2.bb-_L'\n        \"\"\"\n        return EkernTokenizer(token_categories=self.token_categories).tokenize(token).replace(TOKEN_SEPARATOR, '').replace(DECORATION_SEPARATOR, '')\n</code></pre>"},{"location":"reference/#kernpy.core.KernTokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new KernTokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None will raise an exception.</p> required Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def __init__(self, *, token_categories: Set['TokenCategory']):\n    \"\"\"\n    Create a new KernTokenizer.\n\n    Args:\n        token_categories (Set[TokenCategory]): List of categories to be tokenized. If None will raise an exception.\n    \"\"\"\n    super().__init__(token_categories=token_categories)\n</code></pre>"},{"location":"reference/#kernpy.core.KernTokenizer.tokenize","title":"<code>tokenize(token)</code>","text":"<p>Tokenize a token into a normalized kern string representation. This format is the classic Humdrum **kern representation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>Token to be tokenized.</p> required <p>Returns (str): Normalized kern string representation. This is the classic Humdrum **kern representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; token.encoding\n'2@.@bb@-\u00b7_\u00b7L'\n&gt;&gt;&gt; KernTokenizer().tokenize(token)\n'2.bb-_L'\n</code></pre> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def tokenize(self, token: Token) -&gt; str:\n    \"\"\"\n    Tokenize a token into a normalized kern string representation.\n    This format is the classic Humdrum **kern representation.\n\n    Args:\n        token (Token): Token to be tokenized.\n\n    Returns (str): Normalized kern string representation. This is the classic Humdrum **kern representation.\n\n    Examples:\n        &gt;&gt;&gt; token.encoding\n        '2@.@bb@-\u00b7_\u00b7L'\n        &gt;&gt;&gt; KernTokenizer().tokenize(token)\n        '2.bb-_L'\n    \"\"\"\n    return EkernTokenizer(token_categories=self.token_categories).tokenize(token).replace(TOKEN_SEPARATOR, '').replace(DECORATION_SEPARATOR, '')\n</code></pre>"},{"location":"reference/#kernpy.core.KeySignatureToken","title":"<code>KeySignatureToken</code>","text":"<p>               Bases: <code>SignatureToken</code></p> <p>KeySignatureToken class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class KeySignatureToken(SignatureToken):\n    \"\"\"\n    KeySignatureToken class.\n    \"\"\"\n\n    def __init__(self, encoding):\n        super().__init__(encoding, TokenCategory.KEY_SIGNATURE)\n</code></pre>"},{"location":"reference/#kernpy.core.KeyToken","title":"<code>KeyToken</code>","text":"<p>               Bases: <code>SignatureToken</code></p> <p>KeyToken class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class KeyToken(SignatureToken):\n    \"\"\"\n    KeyToken class.\n    \"\"\"\n\n    def __init__(self, encoding):\n        super().__init__(encoding, TokenCategory.KEY_TOKEN)\n</code></pre>"},{"location":"reference/#kernpy.core.MHXMToken","title":"<code>MHXMToken</code>","text":"<p>               Bases: <code>Token</code></p> <p>MHXMToken class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class MHXMToken(Token):\n    \"\"\"\n    MHXMToken class.\n    \"\"\"\n    def __init__(self, encoding):\n        super().__init__(encoding, TokenCategory.MHXM)\n\n    # TODO: Implement constructor\n    def export(self, **kwargs) -&gt; str:\n        return self.encoding\n</code></pre>"},{"location":"reference/#kernpy.core.MensSpineImporter","title":"<code>MensSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/mens_spine_importer.py</code> <pre><code>class MensSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        MensSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        raise NotImplementedError()\n\n    def import_token(self, encoding: str) -&gt; Token:\n        raise NotImplementedError()\n</code></pre>"},{"location":"reference/#kernpy.core.MensSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>MensSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/mens_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    MensSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.core.MetacommentToken","title":"<code>MetacommentToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>MetacommentToken class stores the metacomments of the score. Usually these are comments starting with <code>!!</code>.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class MetacommentToken(SimpleToken):\n    \"\"\"\n    MetacommentToken class stores the metacomments of the score.\n    Usually these are comments starting with `!!`.\n\n    \"\"\"\n\n    def __init__(self, encoding: str):\n        \"\"\"\n        Constructor for the MetacommentToken class.\n\n        Args:\n            encoding (str): The original representation of the token.\n        \"\"\"\n        super().__init__(encoding, TokenCategory.LINE_COMMENTS)\n</code></pre>"},{"location":"reference/#kernpy.core.MetacommentToken.__init__","title":"<code>__init__(encoding)</code>","text":"<p>Constructor for the MetacommentToken class.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The original representation of the token.</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding: str):\n    \"\"\"\n    Constructor for the MetacommentToken class.\n\n    Args:\n        encoding (str): The original representation of the token.\n    \"\"\"\n    super().__init__(encoding, TokenCategory.LINE_COMMENTS)\n</code></pre>"},{"location":"reference/#kernpy.core.MeterSymbolToken","title":"<code>MeterSymbolToken</code>","text":"<p>               Bases: <code>SignatureToken</code></p> <p>MeterSymbolToken class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class MeterSymbolToken(SignatureToken):\n    \"\"\"\n    MeterSymbolToken class.\n    \"\"\"\n\n    def __init__(self, encoding):\n        super().__init__(encoding, TokenCategory.METER_SYMBOL)\n</code></pre>"},{"location":"reference/#kernpy.core.MultistageTree","title":"<code>MultistageTree</code>","text":"<p>MultistageTree class.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>class MultistageTree:\n    \"\"\"\n    MultistageTree class.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructor for MultistageTree class.\n\n        Create an empty Node object to serve as the root, \\\n        and start the stages list by placing this root node inside a new list.\n\n        \"\"\"\n        self.root = Node(0, None, None, None, None, None)\n        self.stages = []  # First stage (0-index) is the root (Node with None token and header_node). The core header is in stage 1.\n        self.stages.append([self.root])\n\n    def add_node(\n            self,\n            stage: int,\n            parent: Node,\n            token: Optional[AbstractToken],\n            last_spine_operator_node: Optional[Node],\n            previous_signature_nodes: Optional[SignatureNodes],\n            header_node: Optional[Node] = None\n    ) -&gt; Node:\n        \"\"\"\n        Add a new node to the tree.\n        Args:\n            stage (int):\n            parent (Node):\n            token (Optional[AbstractToken]):\n            last_spine_operator_node (Optional[Node]):\n            previous_signature_nodes (Optional[SignatureNodes]):\n            header_node (Optional[Node]):\n\n        Returns: Node - The added node object.\n\n        \"\"\"\n        node = Node(stage, token, parent, last_spine_operator_node, previous_signature_nodes, header_node)\n        if stage == len(self.stages):\n            self.stages.append([node])\n        elif stage &gt; len(self.stages):\n            raise ValueError(f'Cannot add node in stage {stage} when there are only {len(self.stages)} stages')\n        else:\n            self.stages[stage].append(node)\n\n        parent.children.append(node)\n        return node\n\n    def dfs(self, visit_method) -&gt; None:\n        \"\"\"\n        Depth-first search (DFS)\n\n        Args:\n            visit_method (TreeTraversalInterface): The tree traversal interface.\n\n        Returns: None\n\n        \"\"\"\n        self.root.dfs(visit_method)\n\n    def dfs_iterative(self, visit_method) -&gt; None:\n        \"\"\"\n        Depth-first search (DFS). Iterative version.\n\n        Args:\n            visit_method (TreeTraversalInterface): The tree traversal interface.\n\n        Returns: None\n\n        \"\"\"\n        self.root.dfs_iterative(visit_method)\n\n    def __deepcopy__(self, memo):\n        \"\"\"\n        Create a deep copy of the MultistageTree object.\n        \"\"\"\n        # Create a new empty MultistageTree object\n        new_tree = MultistageTree()\n\n        # Deepcopy the root\n        new_tree.root = deepcopy(self.root, memo)\n\n        # Deepcopy the stages list\n        new_tree.stages = deepcopy(self.stages, memo)\n\n        return new_tree\n</code></pre>"},{"location":"reference/#kernpy.core.MultistageTree.__deepcopy__","title":"<code>__deepcopy__(memo)</code>","text":"<p>Create a deep copy of the MultistageTree object.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def __deepcopy__(self, memo):\n    \"\"\"\n    Create a deep copy of the MultistageTree object.\n    \"\"\"\n    # Create a new empty MultistageTree object\n    new_tree = MultistageTree()\n\n    # Deepcopy the root\n    new_tree.root = deepcopy(self.root, memo)\n\n    # Deepcopy the stages list\n    new_tree.stages = deepcopy(self.stages, memo)\n\n    return new_tree\n</code></pre>"},{"location":"reference/#kernpy.core.MultistageTree.__init__","title":"<code>__init__()</code>","text":"<p>Constructor for MultistageTree class.</p> <p>Create an empty Node object to serve as the root,         and start the stages list by placing this root node inside a new list.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor for MultistageTree class.\n\n    Create an empty Node object to serve as the root, \\\n    and start the stages list by placing this root node inside a new list.\n\n    \"\"\"\n    self.root = Node(0, None, None, None, None, None)\n    self.stages = []  # First stage (0-index) is the root (Node with None token and header_node). The core header is in stage 1.\n    self.stages.append([self.root])\n</code></pre>"},{"location":"reference/#kernpy.core.MultistageTree.add_node","title":"<code>add_node(stage, parent, token, last_spine_operator_node, previous_signature_nodes, header_node=None)</code>","text":"<p>Add a new node to the tree. Args:     stage (int):     parent (Node):     token (Optional[AbstractToken]):     last_spine_operator_node (Optional[Node]):     previous_signature_nodes (Optional[SignatureNodes]):     header_node (Optional[Node]):</p> <p>Returns: Node - The added node object.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def add_node(\n        self,\n        stage: int,\n        parent: Node,\n        token: Optional[AbstractToken],\n        last_spine_operator_node: Optional[Node],\n        previous_signature_nodes: Optional[SignatureNodes],\n        header_node: Optional[Node] = None\n) -&gt; Node:\n    \"\"\"\n    Add a new node to the tree.\n    Args:\n        stage (int):\n        parent (Node):\n        token (Optional[AbstractToken]):\n        last_spine_operator_node (Optional[Node]):\n        previous_signature_nodes (Optional[SignatureNodes]):\n        header_node (Optional[Node]):\n\n    Returns: Node - The added node object.\n\n    \"\"\"\n    node = Node(stage, token, parent, last_spine_operator_node, previous_signature_nodes, header_node)\n    if stage == len(self.stages):\n        self.stages.append([node])\n    elif stage &gt; len(self.stages):\n        raise ValueError(f'Cannot add node in stage {stage} when there are only {len(self.stages)} stages')\n    else:\n        self.stages[stage].append(node)\n\n    parent.children.append(node)\n    return node\n</code></pre>"},{"location":"reference/#kernpy.core.MultistageTree.dfs","title":"<code>dfs(visit_method)</code>","text":"<p>Depth-first search (DFS)</p> <p>Parameters:</p> Name Type Description Default <code>visit_method</code> <code>TreeTraversalInterface</code> <p>The tree traversal interface.</p> required <p>Returns: None</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def dfs(self, visit_method) -&gt; None:\n    \"\"\"\n    Depth-first search (DFS)\n\n    Args:\n        visit_method (TreeTraversalInterface): The tree traversal interface.\n\n    Returns: None\n\n    \"\"\"\n    self.root.dfs(visit_method)\n</code></pre>"},{"location":"reference/#kernpy.core.MultistageTree.dfs_iterative","title":"<code>dfs_iterative(visit_method)</code>","text":"<p>Depth-first search (DFS). Iterative version.</p> <p>Parameters:</p> Name Type Description Default <code>visit_method</code> <code>TreeTraversalInterface</code> <p>The tree traversal interface.</p> required <p>Returns: None</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def dfs_iterative(self, visit_method) -&gt; None:\n    \"\"\"\n    Depth-first search (DFS). Iterative version.\n\n    Args:\n        visit_method (TreeTraversalInterface): The tree traversal interface.\n\n    Returns: None\n\n    \"\"\"\n    self.root.dfs_iterative(visit_method)\n</code></pre>"},{"location":"reference/#kernpy.core.MxhmSpineImporter","title":"<code>MxhmSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/mhxm_spine_importer.py</code> <pre><code>class MxhmSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.HARMONY)\n\n        return token\n\n        return MHXMToken(encoding)\n</code></pre>"},{"location":"reference/#kernpy.core.MxhmSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/mhxm_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.core.Node","title":"<code>Node</code>","text":"<p>Node class.</p> <p>This class represents a node in a tree. The <code>Node</code> class is responsible for storing the main information of the **kern file.</p> <p>Attributes:</p> Name Type Description <code>id(int)</code> <p>The unique id of the node.</p> <code>token(Optional[AbstractToken])</code> <p>The specific token of the node. The token can be a <code>KeyToken</code>, <code>MeterSymbolToken</code>, etc...</p> <code>parent(Optional['Node'])</code> <p>A reference to the parent <code>Node</code>. If the parent is the root, the parent is None.</p> <code>children(List['Node'])</code> <p>A list of the children <code>Node</code>.</p> <code>stage(int)</code> <p>The stage of the node in the tree. The stage is similar to a row in the **kern file.</p> <code>last_spine_operator_node(Optional['Node'])</code> <p>The last spine operator node.</p> <code>last_signature_nodes(Optional[SignatureNodes])</code> <p>A reference to the last <code>SignatureNodes</code> instance.</p> <code>header_node(Optional['Node'])</code> <p>The header node.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>class Node:\n    \"\"\"\n    Node class.\n\n    This class represents a node in a tree.\n    The `Node` class is responsible for storing the main information of the **kern file.\n\n    Attributes:\n        id(int): The unique id of the node.\n        token(Optional[AbstractToken]): The specific token of the node. The token can be a `KeyToken`, `MeterSymbolToken`, etc...\n        parent(Optional['Node']): A reference to the parent `Node`. If the parent is the root, the parent is None.\n        children(List['Node']): A list of the children `Node`.\n        stage(int): The stage of the node in the tree. The stage is similar to a row in the **kern file.\n        last_spine_operator_node(Optional['Node']): The last spine operator node.\n        last_signature_nodes(Optional[SignatureNodes]): A reference to the last `SignatureNodes` instance.\n        header_node(Optional['Node']): The header node.\n    \"\"\"\n    NextID = 1  # static counter\n\n    def __init__(self,\n                 stage: int,\n                 token: Optional[AbstractToken],\n                 parent: Optional['Node'],\n                 last_spine_operator_node: Optional['Node'],\n                 last_signature_nodes: Optional[SignatureNodes],\n                 header_node: Optional['Node']\n                 ):\n        \"\"\"\n        Create an instance of Node.\n\n        Args:\n            stage (int): The stage of the node in the tree. The stage is similar to a row in the **kern file.\n            token (Optional[AbstractToken]): The specific token of the node. The token can be a `KeyToken`, `MeterSymbolToken`, etc...\n            parent (Optional['Node']): A reference to the parent `Node`. If the parent is the root, the parent is None.\n            last_spine_operator_node (Optional['Node']): The last spine operator node.\n            last_signature_nodes (Optional[SignatureNodes]): A reference to the last `SignatureNodes` instance.\n            header_node (Optional['Node']): The header node.\n        \"\"\"\n        self.id = Node.NextID\n        Node.NextID += 1\n        self.token = token\n        self.parent = parent\n        self.children = []\n        self.stage = stage\n        self.header_node = header_node\n        if last_signature_nodes is not None:\n            self.last_signature_nodes = last_signature_nodes.clone()  #TODO Documentar todo esto - composici\u00f3n\n            # self.last_signature_nodes = copy.deepcopy(last_signature_nodes) # TODO: Ver en SignatureNodes.clone\n        else:\n            self.last_signature_nodes = SignatureNodes()\n        self.last_spine_operator_node = last_spine_operator_node\n\n    def count_nodes_by_stage(self) -&gt; List[int]:\n        \"\"\"\n        Count the number of nodes in each stage of the tree.\n\n        Examples:\n            &gt;&gt;&gt; node = Node(0, None, None, None, None, None)\n            &gt;&gt;&gt; ...\n            &gt;&gt;&gt; node.count_nodes_by_stage()\n            [2, 2, 2, 2, 3, 3, 3, 2]\n\n        Returns:\n            List[int]: A list with the number of nodes in each stage of the tree.\n        \"\"\"\n        level_counts = defaultdict(int)\n        queue = deque([(self, 0)])  # (node, level)\n        # breadth-first search (BFS)\n        while queue:\n            node, level = queue.popleft()\n            level_counts[level] += 1\n            for child in node.children:\n                queue.append((child, level + 1))\n\n        # Convert the level_counts dictionary to a list of counts\n        max_level = max(level_counts.keys())\n        counts_by_level = [level_counts[level] for level in range(max_level + 1)]\n\n        return counts_by_level\n\n    def dfs(self, tree_traversal: TreeTraversalInterface):\n        \"\"\"\n        Depth-first search (DFS)\n\n        Args:\n            tree_traversal (TreeTraversalInterface): The tree traversal interface. Object used to visit the nodes of the tree.\n        \"\"\"\n        node = self\n        tree_traversal.visit(node)\n        for child in self.children:\n            child.dfs(tree_traversal)\n\n    def dfs_iterative(self, tree_traversal: TreeTraversalInterface):\n        \"\"\"\n        Depth-first search (DFS). Iterative version.\n\n        Args:\n            tree_traversal (TreeTraversalInterface): The tree traversal interface. Object used to visit the nodes of the tree.\n\n        Returns: None\n        \"\"\"\n        stack = [self]\n        while stack:\n            node = stack.pop()\n            tree_traversal.visit(node)\n            stack.extend(reversed(node.children))  # Add children in reverse order to maintain DFS order\n\n    def __eq__(self, other):\n        \"\"\"\n        Compare two nodes.\n\n        Args:\n            other: The other node to compare.\n\n        Returns: True if the nodes are equal, False otherwise.\n        \"\"\"\n        if other is None or not isinstance(other, Node):\n            return False\n\n        return self.id == other.id\n\n    def __ne__(self, other):\n        \"\"\"\n        Compare two nodes.\n\n        Args:\n            other: The other node to compare.\n\n        Returns: True if the nodes are not equal, False otherwise.\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        \"\"\"\n        Get the hash of the node.\n\n        Returns: The hash of the node.\n        \"\"\"\n        return hash(self.id)\n\n    def __str__(self):\n        \"\"\"\n        Get the string representation of the node.\n\n        Returns: The string representation of the node.\n        \"\"\"\n        return f\"{{{self.stage}: {self.token}}}\"\n</code></pre>"},{"location":"reference/#kernpy.core.Node.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two nodes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>The other node to compare.</p> required <p>Returns: True if the nodes are equal, False otherwise.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compare two nodes.\n\n    Args:\n        other: The other node to compare.\n\n    Returns: True if the nodes are equal, False otherwise.\n    \"\"\"\n    if other is None or not isinstance(other, Node):\n        return False\n\n    return self.id == other.id\n</code></pre>"},{"location":"reference/#kernpy.core.Node.__hash__","title":"<code>__hash__()</code>","text":"<p>Get the hash of the node.</p> <p>Returns: The hash of the node.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Get the hash of the node.\n\n    Returns: The hash of the node.\n    \"\"\"\n    return hash(self.id)\n</code></pre>"},{"location":"reference/#kernpy.core.Node.__init__","title":"<code>__init__(stage, token, parent, last_spine_operator_node, last_signature_nodes, header_node)</code>","text":"<p>Create an instance of Node.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>int</code> <p>The stage of the node in the tree. The stage is similar to a row in the **kern file.</p> required <code>token</code> <code>Optional[AbstractToken]</code> <p>The specific token of the node. The token can be a <code>KeyToken</code>, <code>MeterSymbolToken</code>, etc...</p> required <code>parent</code> <code>Optional['Node']</code> <p>A reference to the parent <code>Node</code>. If the parent is the root, the parent is None.</p> required <code>last_spine_operator_node</code> <code>Optional['Node']</code> <p>The last spine operator node.</p> required <code>last_signature_nodes</code> <code>Optional[SignatureNodes]</code> <p>A reference to the last <code>SignatureNodes</code> instance.</p> required <code>header_node</code> <code>Optional['Node']</code> <p>The header node.</p> required Source code in <code>kernpy/core/document.py</code> <pre><code>def __init__(self,\n             stage: int,\n             token: Optional[AbstractToken],\n             parent: Optional['Node'],\n             last_spine_operator_node: Optional['Node'],\n             last_signature_nodes: Optional[SignatureNodes],\n             header_node: Optional['Node']\n             ):\n    \"\"\"\n    Create an instance of Node.\n\n    Args:\n        stage (int): The stage of the node in the tree. The stage is similar to a row in the **kern file.\n        token (Optional[AbstractToken]): The specific token of the node. The token can be a `KeyToken`, `MeterSymbolToken`, etc...\n        parent (Optional['Node']): A reference to the parent `Node`. If the parent is the root, the parent is None.\n        last_spine_operator_node (Optional['Node']): The last spine operator node.\n        last_signature_nodes (Optional[SignatureNodes]): A reference to the last `SignatureNodes` instance.\n        header_node (Optional['Node']): The header node.\n    \"\"\"\n    self.id = Node.NextID\n    Node.NextID += 1\n    self.token = token\n    self.parent = parent\n    self.children = []\n    self.stage = stage\n    self.header_node = header_node\n    if last_signature_nodes is not None:\n        self.last_signature_nodes = last_signature_nodes.clone()  #TODO Documentar todo esto - composici\u00f3n\n        # self.last_signature_nodes = copy.deepcopy(last_signature_nodes) # TODO: Ver en SignatureNodes.clone\n    else:\n        self.last_signature_nodes = SignatureNodes()\n    self.last_spine_operator_node = last_spine_operator_node\n</code></pre>"},{"location":"reference/#kernpy.core.Node.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two nodes.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <p>The other node to compare.</p> required <p>Returns: True if the nodes are not equal, False otherwise.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def __ne__(self, other):\n    \"\"\"\n    Compare two nodes.\n\n    Args:\n        other: The other node to compare.\n\n    Returns: True if the nodes are not equal, False otherwise.\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.Node.__str__","title":"<code>__str__()</code>","text":"<p>Get the string representation of the node.</p> <p>Returns: The string representation of the node.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Get the string representation of the node.\n\n    Returns: The string representation of the node.\n    \"\"\"\n    return f\"{{{self.stage}: {self.token}}}\"\n</code></pre>"},{"location":"reference/#kernpy.core.Node.count_nodes_by_stage","title":"<code>count_nodes_by_stage()</code>","text":"<p>Count the number of nodes in each stage of the tree.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node = Node(0, None, None, None, None, None)\n&gt;&gt;&gt; ...\n&gt;&gt;&gt; node.count_nodes_by_stage()\n[2, 2, 2, 2, 3, 3, 3, 2]\n</code></pre> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: A list with the number of nodes in each stage of the tree.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def count_nodes_by_stage(self) -&gt; List[int]:\n    \"\"\"\n    Count the number of nodes in each stage of the tree.\n\n    Examples:\n        &gt;&gt;&gt; node = Node(0, None, None, None, None, None)\n        &gt;&gt;&gt; ...\n        &gt;&gt;&gt; node.count_nodes_by_stage()\n        [2, 2, 2, 2, 3, 3, 3, 2]\n\n    Returns:\n        List[int]: A list with the number of nodes in each stage of the tree.\n    \"\"\"\n    level_counts = defaultdict(int)\n    queue = deque([(self, 0)])  # (node, level)\n    # breadth-first search (BFS)\n    while queue:\n        node, level = queue.popleft()\n        level_counts[level] += 1\n        for child in node.children:\n            queue.append((child, level + 1))\n\n    # Convert the level_counts dictionary to a list of counts\n    max_level = max(level_counts.keys())\n    counts_by_level = [level_counts[level] for level in range(max_level + 1)]\n\n    return counts_by_level\n</code></pre>"},{"location":"reference/#kernpy.core.Node.dfs","title":"<code>dfs(tree_traversal)</code>","text":"<p>Depth-first search (DFS)</p> <p>Parameters:</p> Name Type Description Default <code>tree_traversal</code> <code>TreeTraversalInterface</code> <p>The tree traversal interface. Object used to visit the nodes of the tree.</p> required Source code in <code>kernpy/core/document.py</code> <pre><code>def dfs(self, tree_traversal: TreeTraversalInterface):\n    \"\"\"\n    Depth-first search (DFS)\n\n    Args:\n        tree_traversal (TreeTraversalInterface): The tree traversal interface. Object used to visit the nodes of the tree.\n    \"\"\"\n    node = self\n    tree_traversal.visit(node)\n    for child in self.children:\n        child.dfs(tree_traversal)\n</code></pre>"},{"location":"reference/#kernpy.core.Node.dfs_iterative","title":"<code>dfs_iterative(tree_traversal)</code>","text":"<p>Depth-first search (DFS). Iterative version.</p> <p>Parameters:</p> Name Type Description Default <code>tree_traversal</code> <code>TreeTraversalInterface</code> <p>The tree traversal interface. Object used to visit the nodes of the tree.</p> required <p>Returns: None</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def dfs_iterative(self, tree_traversal: TreeTraversalInterface):\n    \"\"\"\n    Depth-first search (DFS). Iterative version.\n\n    Args:\n        tree_traversal (TreeTraversalInterface): The tree traversal interface. Object used to visit the nodes of the tree.\n\n    Returns: None\n    \"\"\"\n    stack = [self]\n    while stack:\n        node = stack.pop()\n        tree_traversal.visit(node)\n        stack.extend(reversed(node.children))  # Add children in reverse order to maintain DFS order\n</code></pre>"},{"location":"reference/#kernpy.core.NoteRestToken","title":"<code>NoteRestToken</code>","text":"<p>               Bases: <code>ComplexToken</code></p> <p>NoteRestToken class.</p> <p>Attributes:</p> Name Type Description <code>pitch_duration_subtokens</code> <code>list</code> <p>The subtokens for the pitch and duration</p> <code>decoration_subtokens</code> <code>list</code> <p>The subtokens for the decorations</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class NoteRestToken(ComplexToken):\n    \"\"\"\n    NoteRestToken class.\n\n    Attributes:\n        pitch_duration_subtokens (list): The subtokens for the pitch and duration\n        decoration_subtokens (list): The subtokens for the decorations\n    \"\"\"\n\n    def __init__(\n            self,\n            encoding: str,\n            pitch_duration_subtokens: List[Subtoken],\n            decoration_subtokens: List[Subtoken]\n    ):\n        \"\"\"\n        NoteRestToken constructor.\n\n        Args:\n            encoding (str): The complete unprocessed encoding\n            pitch_duration_subtokens (List[Subtoken])y: The subtokens for the pitch and duration\n            decoration_subtokens (List[Subtoken]): The subtokens for the decorations. Individual elements of the token, of type Subtoken\n        \"\"\"\n        super().__init__(encoding, TokenCategory.NOTE_REST)\n        if not pitch_duration_subtokens or len(pitch_duration_subtokens) == 0:\n            raise ValueError('Empty name-duration subtokens')\n\n        for subtoken in pitch_duration_subtokens:\n            if not isinstance(subtoken, Subtoken):\n                raise ValueError(f'All pitch-duration subtokens must be instances of Subtoken. Found {type(subtoken)}')\n        for subtoken in decoration_subtokens:\n            if not isinstance(subtoken, Subtoken):\n                raise ValueError(f'All decoration subtokens must be instances of Subtoken. Found {type(subtoken)}')\n\n        self.pitch_duration_subtokens = pitch_duration_subtokens\n        self.decoration_subtokens = decoration_subtokens\n\n    def export(self, **kwargs) -&gt; str:\n        \"\"\"\n        Exports the token.\n\n        Keyword Arguments:\n            filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n                indicating whether the token should be included in the export. If provided, only tokens for which the\n                function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n        Returns (str): The exported token.\n\n        \"\"\"\n        filter_categories_fn = kwargs.get('filter_categories', None)\n\n        # Filter subcategories\n        pitch_duration_tokens = {\n            subtoken for subtoken in self.pitch_duration_subtokens\n            if filter_categories_fn is None or filter_categories_fn(subtoken.category)\n        }\n        decoration_tokens = {\n            subtoken for subtoken in self.decoration_subtokens\n            if filter_categories_fn is None or filter_categories_fn(subtoken.category)\n        }\n        pitch_duration_tokens_sorted = sorted(pitch_duration_tokens, key=lambda t:  (t.category.value, t.encoding))\n        decoration_tokens_sorted     = sorted(decoration_tokens,     key=lambda t:  (t.category.value, t.encoding))\n\n        # Join the sorted subtokens\n        pitch_duration_part = TOKEN_SEPARATOR.join([subtoken.encoding for subtoken in pitch_duration_tokens_sorted])\n        decoration_part = DECORATION_SEPARATOR.join([subtoken.encoding for subtoken in decoration_tokens_sorted])\n\n        result = pitch_duration_part\n        if len(decoration_part):\n            result += DECORATION_SEPARATOR + decoration_part\n\n        return result if len(result) &gt; 0 else EMPTY_TOKEN\n</code></pre>"},{"location":"reference/#kernpy.core.NoteRestToken.__init__","title":"<code>__init__(encoding, pitch_duration_subtokens, decoration_subtokens)</code>","text":"<p>NoteRestToken constructor.</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>pitch_duration_subtokens</code> <code>List[Subtoken])y</code> <p>The subtokens for the pitch and duration</p> required <code>decoration_subtokens</code> <code>List[Subtoken]</code> <p>The subtokens for the decorations. Individual elements of the token, of type Subtoken</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(\n        self,\n        encoding: str,\n        pitch_duration_subtokens: List[Subtoken],\n        decoration_subtokens: List[Subtoken]\n):\n    \"\"\"\n    NoteRestToken constructor.\n\n    Args:\n        encoding (str): The complete unprocessed encoding\n        pitch_duration_subtokens (List[Subtoken])y: The subtokens for the pitch and duration\n        decoration_subtokens (List[Subtoken]): The subtokens for the decorations. Individual elements of the token, of type Subtoken\n    \"\"\"\n    super().__init__(encoding, TokenCategory.NOTE_REST)\n    if not pitch_duration_subtokens or len(pitch_duration_subtokens) == 0:\n        raise ValueError('Empty name-duration subtokens')\n\n    for subtoken in pitch_duration_subtokens:\n        if not isinstance(subtoken, Subtoken):\n            raise ValueError(f'All pitch-duration subtokens must be instances of Subtoken. Found {type(subtoken)}')\n    for subtoken in decoration_subtokens:\n        if not isinstance(subtoken, Subtoken):\n            raise ValueError(f'All decoration subtokens must be instances of Subtoken. Found {type(subtoken)}')\n\n    self.pitch_duration_subtokens = pitch_duration_subtokens\n    self.decoration_subtokens = decoration_subtokens\n</code></pre>"},{"location":"reference/#kernpy.core.NoteRestToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Other Parameters:</p> Name Type Description <code>filter_categories</code> <code>Optional[Callable[[TokenCategory], bool]]</code> <p>A function that takes a TokenCategory and returns a boolean indicating whether the token should be included in the export. If provided, only tokens for which the function returns True will be exported. Defaults to None. If None, all tokens will be exported.</p> <p>Returns (str): The exported token.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def export(self, **kwargs) -&gt; str:\n    \"\"\"\n    Exports the token.\n\n    Keyword Arguments:\n        filter_categories (Optional[Callable[[TokenCategory], bool]]): A function that takes a TokenCategory and returns a boolean\n            indicating whether the token should be included in the export. If provided, only tokens for which the\n            function returns True will be exported. Defaults to None. If None, all tokens will be exported.\n\n    Returns (str): The exported token.\n\n    \"\"\"\n    filter_categories_fn = kwargs.get('filter_categories', None)\n\n    # Filter subcategories\n    pitch_duration_tokens = {\n        subtoken for subtoken in self.pitch_duration_subtokens\n        if filter_categories_fn is None or filter_categories_fn(subtoken.category)\n    }\n    decoration_tokens = {\n        subtoken for subtoken in self.decoration_subtokens\n        if filter_categories_fn is None or filter_categories_fn(subtoken.category)\n    }\n    pitch_duration_tokens_sorted = sorted(pitch_duration_tokens, key=lambda t:  (t.category.value, t.encoding))\n    decoration_tokens_sorted     = sorted(decoration_tokens,     key=lambda t:  (t.category.value, t.encoding))\n\n    # Join the sorted subtokens\n    pitch_duration_part = TOKEN_SEPARATOR.join([subtoken.encoding for subtoken in pitch_duration_tokens_sorted])\n    decoration_part = DECORATION_SEPARATOR.join([subtoken.encoding for subtoken in decoration_tokens_sorted])\n\n    result = pitch_duration_part\n    if len(decoration_part):\n        result += DECORATION_SEPARATOR + decoration_part\n\n    return result if len(result) &gt; 0 else EMPTY_TOKEN\n</code></pre>"},{"location":"reference/#kernpy.core.PitchPositionReferenceSystem","title":"<code>PitchPositionReferenceSystem</code>","text":"Source code in <code>kernpy/core/gkern.py</code> <pre><code>class PitchPositionReferenceSystem:\n    def __init__(self, base_pitch: AgnosticPitch):\n        \"\"\"\n        Initializes the PitchPositionReferenceSystem object.\n        Args:\n            base_pitch (AgnosticPitch): The AgnosticPitch in the first line of the Staff. \\\n             The AgnosticPitch object that serves as the reference point for the system.\n        \"\"\"\n        self.base_pitch = base_pitch\n\n    def compute_position(self, pitch: AgnosticPitch) -&gt; PositionInStaff:\n        \"\"\"\n        Computes the position in staff for the given pitch.\n        Args:\n            pitch (AgnosticPitch): The AgnosticPitch object to compute the position for.\n        Returns:\n            PositionInStaff: The PositionInStaff object representing the computed position.\n        \"\"\"\n        # map A\u2013G to 0\u20136\n        LETTER_TO_INDEX = {'C': 0, 'D': 1, 'E': 2,\n                           'F': 3, 'G': 4, 'A': 5, 'B': 6}\n\n        # strip off any '+' or '-' accidentals, then grab the letter\n        def letter(p: AgnosticPitch) -&gt; str:\n            name = p.name.replace('+', '').replace('-', '')\n            return AgnosticPitch(name, p.octave).name\n\n        base_letter_idx = LETTER_TO_INDEX[letter(self.base_pitch)]\n        target_letter_idx = LETTER_TO_INDEX[letter(pitch)]\n\n        # \"octave difference \u00d7 7\" plus the letter\u2010index difference\n        diatonic_steps = (pitch.octave - self.base_pitch.octave) * 7 \\\n                         + (target_letter_idx - base_letter_idx)\n\n        # that many \"lines or spaces\" above (or below) the reference line\n        return PositionInStaff(diatonic_steps)\n</code></pre>"},{"location":"reference/#kernpy.core.PitchPositionReferenceSystem.__init__","title":"<code>__init__(base_pitch)</code>","text":"<p>Initializes the PitchPositionReferenceSystem object. Args:     base_pitch (AgnosticPitch): The AgnosticPitch in the first line of the Staff.              The AgnosticPitch object that serves as the reference point for the system.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self, base_pitch: AgnosticPitch):\n    \"\"\"\n    Initializes the PitchPositionReferenceSystem object.\n    Args:\n        base_pitch (AgnosticPitch): The AgnosticPitch in the first line of the Staff. \\\n         The AgnosticPitch object that serves as the reference point for the system.\n    \"\"\"\n    self.base_pitch = base_pitch\n</code></pre>"},{"location":"reference/#kernpy.core.PitchPositionReferenceSystem.compute_position","title":"<code>compute_position(pitch)</code>","text":"<p>Computes the position in staff for the given pitch. Args:     pitch (AgnosticPitch): The AgnosticPitch object to compute the position for. Returns:     PositionInStaff: The PositionInStaff object representing the computed position.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def compute_position(self, pitch: AgnosticPitch) -&gt; PositionInStaff:\n    \"\"\"\n    Computes the position in staff for the given pitch.\n    Args:\n        pitch (AgnosticPitch): The AgnosticPitch object to compute the position for.\n    Returns:\n        PositionInStaff: The PositionInStaff object representing the computed position.\n    \"\"\"\n    # map A\u2013G to 0\u20136\n    LETTER_TO_INDEX = {'C': 0, 'D': 1, 'E': 2,\n                       'F': 3, 'G': 4, 'A': 5, 'B': 6}\n\n    # strip off any '+' or '-' accidentals, then grab the letter\n    def letter(p: AgnosticPitch) -&gt; str:\n        name = p.name.replace('+', '').replace('-', '')\n        return AgnosticPitch(name, p.octave).name\n\n    base_letter_idx = LETTER_TO_INDEX[letter(self.base_pitch)]\n    target_letter_idx = LETTER_TO_INDEX[letter(pitch)]\n\n    # \"octave difference \u00d7 7\" plus the letter\u2010index difference\n    diatonic_steps = (pitch.octave - self.base_pitch.octave) * 7 \\\n                     + (target_letter_idx - base_letter_idx)\n\n    # that many \"lines or spaces\" above (or below) the reference line\n    return PositionInStaff(diatonic_steps)\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest","title":"<code>PitchRest</code>","text":"<p>Represents a name or a rest in a note.</p> <p>The name is represented using the International Standard Organization (ISO) name notation. The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.</p> <p>The Humdrum Kern format uses the following name representation: 'c' = C4 'cc' = C5 'ccc' = C6 'cccc' = C7</p> <p>'C' = C3 'CC' = C2 'CCC' = C1</p> <p>The rests are represented by the letter 'r'. The rests do not have name.</p> <p>This class do not limit the name ranges.</p> <p>In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.</p> <pre><code>**kern\n*clefG2\n2c          // C4\n2cc         // C5\n2ccc        // C6\n2C          // C3\n2CC         // C2\n2CCC        // C1\n*-\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class PitchRest:\n    \"\"\"\n    Represents a name or a rest in a note.\n\n    The name is represented using the International Standard Organization (ISO) name notation.\n    The first line below the staff is the C4 in G clef. The above C is C5, the below C is C3, etc.\n\n    The Humdrum Kern format uses the following name representation:\n    'c' = C4\n    'cc' = C5\n    'ccc' = C6\n    'cccc' = C7\n\n    'C' = C3\n    'CC' = C2\n    'CCC' = C1\n\n    The rests are represented by the letter 'r'. The rests do not have name.\n\n    This class do not limit the name ranges.\n\n\n    In the following example, the name is represented by the letter 'c'. The name of 'c' is C4, 'cc' is C5, 'ccc' is C6.\n    ```\n    **kern\n    *clefG2\n    2c          // C4\n    2cc         // C5\n    2ccc        // C6\n    2C          // C3\n    2CC         // C2\n    2CCC        // C1\n    *-\n    ```\n    \"\"\"\n    C4_PITCH_LOWERCASE = 'c'\n    C4_OCATAVE = 4\n    C3_PITCH_UPPERCASE = 'C'\n    C3_OCATAVE = 3\n    REST_CHARACTER = 'r'\n\n    VALID_PITCHES = 'abcdefg' + 'ABCDEFG' + REST_CHARACTER\n\n    def __init__(self, raw_pitch: str):\n        \"\"\"\n        Create a new PitchRest object.\n\n        Args:\n            raw_pitch (str): name representation in Humdrum Kern format\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest = PitchRest('DDD')\n        \"\"\"\n        if raw_pitch is None or len(raw_pitch) == 0:\n            raise ValueError(f'Empty name: name can not be None or empty. But {raw_pitch} was provided.')\n\n        self.encoding = raw_pitch\n        self.pitch, self.octave = self.__parse_pitch_octave()\n\n    def __parse_pitch_octave(self) -&gt; (str, int):\n        if self.encoding == PitchRest.REST_CHARACTER:\n            return PitchRest.REST_CHARACTER, None\n\n        if self.encoding.islower():\n            min_octave = PitchRest.C4_OCATAVE\n            octave = min_octave + (len(self.encoding) - 1)\n            pitch = self.encoding[0].lower()\n            return pitch, octave\n\n        if self.encoding.isupper():\n            max_octave = PitchRest.C3_OCATAVE\n            octave = max_octave - (len(self.encoding) - 1)\n            pitch = self.encoding[0].lower()\n            return pitch, octave\n\n        raise ValueError(f'Invalid name: name {self.encoding} is not a valid name representation.')\n\n    def is_rest(self) -&gt; bool:\n        \"\"\"\n        Check if the name is a rest.\n\n        Returns:\n            bool: True if the name is a rest, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest.is_rest()\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest.is_rest()\n            True\n        \"\"\"\n        return self.octave is None\n\n    @staticmethod\n    def pitch_comparator(pitch_a: str, pitch_b: str) -&gt; int:\n        \"\"\"\n        Compare two pitches of the same octave.\n\n        The lower name is 'a'. So 'a' &lt; 'b' &lt; 'c' &lt; 'd' &lt; 'e' &lt; 'f' &lt; 'g'\n\n        Args:\n            pitch_a: One name of 'abcdefg'\n            pitch_b: Another name of 'abcdefg'\n\n        Returns:\n            -1 if pitch1 is lower than pitch2\n            0 if pitch1 is equal to pitch2\n            1 if pitch1 is higher than pitch2\n\n        Examples:\n            &gt;&gt;&gt; PitchRest.pitch_comparator('c', 'c')\n            0\n            &gt;&gt;&gt; PitchRest.pitch_comparator('c', 'd')\n            -1\n            &gt;&gt;&gt; PitchRest.pitch_comparator('d', 'c')\n            1\n        \"\"\"\n        if pitch_a &lt; pitch_b:\n            return -1\n        if pitch_a &gt; pitch_b:\n            return 1\n        return 0\n\n    def __str__(self):\n        return f'{self.encoding}'\n\n    def __repr__(self):\n        return f'[PitchRest: {self.encoding}, name={self.pitch}, octave={self.octave}]'\n\n    def __eq__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches and rests.\n\n        Args:\n            other (PitchRest): The other name to compare\n\n        Returns (bool):\n            True if the pitches are equal, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest == pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n            &gt;&gt;&gt; pitch_rest == pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest == pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest == pitch_rest2\n            True\n\n        \"\"\"\n        if not isinstance(other, PitchRest):\n            return False\n        if self.is_rest() and other.is_rest():\n            return True\n        if self.is_rest() or other.is_rest():\n            return False\n        return self.pitch == other.pitch and self.octave == other.octave\n\n    def __ne__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches and rests.\n        Args:\n            other (PitchRest): The other name to compare\n\n        Returns (bool):\n            True if the pitches are different, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest != pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n            &gt;&gt;&gt; pitch_rest != pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest != pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest != pitch_rest2\n            False\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __gt__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches.\n\n        If any of the pitches is a rest, the comparison raise an exception.\n\n        Args:\n            other (PitchRest): The other name to compare\n\n        Returns (bool): True if this name is higher than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n            &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n            &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n            Traceback (most recent call last):\n            ValueError: ...\n\n\n        \"\"\"\n        if self.is_rest() or other.is_rest():\n            raise ValueError(f'Invalid comparison: &gt; operator can not be used to compare name of a rest.\\n\\\n            self={repr(self)} &gt; other={repr(other)}')\n\n        if self.octave &gt; other.octave:\n            return True\n        if self.octave == other.octave:\n            return PitchRest.pitch_comparator(self.pitch, other.pitch) &gt; 0\n        return False\n\n    def __lt__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches.\n\n        If any of the pitches is a rest, the comparison raise an exception.\n\n        Args:\n            other: The other name to compare\n\n        Returns:\n            True if this name is lower than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n            &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n            &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n\n        \"\"\"\n        if self.is_rest() or other.is_rest():\n            raise ValueError(f'Invalid comparison: &lt; operator can not be used to compare name of a rest.\\n\\\n            self={repr(self)} &lt; other={repr(other)}')\n\n        if self.octave &lt; other.octave:\n            return True\n        if self.octave == other.octave:\n            return PitchRest.pitch_comparator(self.pitch, other.pitch) &lt; 0\n        return False\n\n    def __ge__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception.\n        Args:\n            other (PitchRest): The other name to compare\n\n        Returns (bool):\n            True if this name is higher or equal than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n            &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n            &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n\n\n        \"\"\"\n        return self.__gt__(other) or self.__eq__(other)\n\n    def __le__(self, other: 'PitchRest') -&gt; bool:\n        \"\"\"\n        Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception.\n        Args:\n            other (PitchRest): The other name to compare\n\n        Returns (bool): True if this name is lower or equal than the other, False otherwise\n\n        Examples:\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n            &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n            True\n            &gt;&gt;&gt; pitch_rest = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n            &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n            False\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n            &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n            &gt;&gt;&gt; pitch_rest = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n            &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n            Traceback (most recent call last):\n            ...\n            ValueError: ...\n\n        \"\"\"\n        return self.__lt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two pitches and rests.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PitchRest</code> <p>The other name to compare</p> required <p>Returns (bool):     True if the pitches are equal, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest == pitch_rest2\nTrue\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __eq__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches and rests.\n\n    Args:\n        other (PitchRest): The other name to compare\n\n    Returns (bool):\n        True if the pitches are equal, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest == pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n        &gt;&gt;&gt; pitch_rest == pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest == pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest == pitch_rest2\n        True\n\n    \"\"\"\n    if not isinstance(other, PitchRest):\n        return False\n    if self.is_rest() and other.is_rest():\n        return True\n    if self.is_rest() or other.is_rest():\n        return False\n    return self.pitch == other.pitch and self.octave == other.octave\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__ge__","title":"<code>__ge__(other)</code>","text":"<p>Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool):     True if this name is higher or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ge__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception.\n    Args:\n        other (PitchRest): The other name to compare\n\n    Returns (bool):\n        True if this name is higher or equal than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n        &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n        &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest &gt;= pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n\n    \"\"\"\n    return self.__gt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__gt__","title":"<code>__gt__(other)</code>","text":"<p>Compare two pitches.</p> <p>If any of the pitches is a rest, the comparison raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>PitchRest</code> <p>The other name to compare</p> required <p>Returns (bool): True if this name is higher than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &gt; pitch_rest2\nTraceback (most recent call last):\nValueError: ...\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __gt__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches.\n\n    If any of the pitches is a rest, the comparison raise an exception.\n\n    Args:\n        other (PitchRest): The other name to compare\n\n    Returns (bool): True if this name is higher than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n        &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n        &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest &gt; pitch_rest2\n        Traceback (most recent call last):\n        ValueError: ...\n\n\n    \"\"\"\n    if self.is_rest() or other.is_rest():\n        raise ValueError(f'Invalid comparison: &gt; operator can not be used to compare name of a rest.\\n\\\n        self={repr(self)} &gt; other={repr(other)}')\n\n    if self.octave &gt; other.octave:\n        return True\n    if self.octave == other.octave:\n        return PitchRest.pitch_comparator(self.pitch, other.pitch) &gt; 0\n    return False\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__init__","title":"<code>__init__(raw_pitch)</code>","text":"<p>Create a new PitchRest object.</p> <p>Parameters:</p> Name Type Description Default <code>raw_pitch</code> <code>str</code> <p>name representation in Humdrum Kern format</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest = PitchRest('DDD')\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, raw_pitch: str):\n    \"\"\"\n    Create a new PitchRest object.\n\n    Args:\n        raw_pitch (str): name representation in Humdrum Kern format\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest = PitchRest('DDD')\n    \"\"\"\n    if raw_pitch is None or len(raw_pitch) == 0:\n        raise ValueError(f'Empty name: name can not be None or empty. But {raw_pitch} was provided.')\n\n    self.encoding = raw_pitch\n    self.pitch, self.octave = self.__parse_pitch_octave()\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__le__","title":"<code>__le__(other)</code>","text":"<p>Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool): True if this name is lower or equal than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __le__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches. If any of the PitchRest is a rest, the comparison raise an exception.\n    Args:\n        other (PitchRest): The other name to compare\n\n    Returns (bool): True if this name is lower or equal than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n        &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n        &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest &lt;= pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n    \"\"\"\n    return self.__lt__(other) or self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two pitches.</p> <p>If any of the pitches is a rest, the comparison raise an exception.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>'PitchRest'</code> <p>The other name to compare</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if this name is lower than the other, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest &lt; pitch_rest2\nTraceback (most recent call last):\n...\nValueError: ...\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __lt__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches.\n\n    If any of the pitches is a rest, the comparison raise an exception.\n\n    Args:\n        other: The other name to compare\n\n    Returns:\n        True if this name is lower than the other, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('d')\n        &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('b')\n        &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest &lt; pitch_rest2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n    \"\"\"\n    if self.is_rest() or other.is_rest():\n        raise ValueError(f'Invalid comparison: &lt; operator can not be used to compare name of a rest.\\n\\\n        self={repr(self)} &lt; other={repr(other)}')\n\n    if self.octave &lt; other.octave:\n        return True\n    if self.octave == other.octave:\n        return PitchRest.pitch_comparator(self.pitch, other.pitch) &lt; 0\n    return False\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two pitches and rests. Args:     other (PitchRest): The other name to compare</p> <p>Returns (bool):     True if the pitches are different, False otherwise</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nTrue\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n&gt;&gt;&gt; pitch_rest != pitch_rest2\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ne__(self, other: 'PitchRest') -&gt; bool:\n    \"\"\"\n    Compare two pitches and rests.\n    Args:\n        other (PitchRest): The other name to compare\n\n    Returns (bool):\n        True if the pitches are different, False otherwise\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest != pitch_rest2\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('ccc')\n        &gt;&gt;&gt; pitch_rest != pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest != pitch_rest2\n        True\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest2 = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest != pitch_rest2\n        False\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.is_rest","title":"<code>is_rest()</code>","text":"<p>Check if the name is a rest.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the name is a rest, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitch_rest = PitchRest('c')\n&gt;&gt;&gt; pitch_rest.is_rest()\nFalse\n&gt;&gt;&gt; pitch_rest = PitchRest('r')\n&gt;&gt;&gt; pitch_rest.is_rest()\nTrue\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def is_rest(self) -&gt; bool:\n    \"\"\"\n    Check if the name is a rest.\n\n    Returns:\n        bool: True if the name is a rest, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; pitch_rest = PitchRest('c')\n        &gt;&gt;&gt; pitch_rest.is_rest()\n        False\n        &gt;&gt;&gt; pitch_rest = PitchRest('r')\n        &gt;&gt;&gt; pitch_rest.is_rest()\n        True\n    \"\"\"\n    return self.octave is None\n</code></pre>"},{"location":"reference/#kernpy.core.PitchRest.pitch_comparator","title":"<code>pitch_comparator(pitch_a, pitch_b)</code>  <code>staticmethod</code>","text":"<p>Compare two pitches of the same octave.</p> <p>The lower name is 'a'. So 'a' &lt; 'b' &lt; 'c' &lt; 'd' &lt; 'e' &lt; 'f' &lt; 'g'</p> <p>Parameters:</p> Name Type Description Default <code>pitch_a</code> <code>str</code> <p>One name of 'abcdefg'</p> required <code>pitch_b</code> <code>str</code> <p>Another name of 'abcdefg'</p> required <p>Returns:</p> Type Description <code>int</code> <p>-1 if pitch1 is lower than pitch2</p> <code>int</code> <p>0 if pitch1 is equal to pitch2</p> <code>int</code> <p>1 if pitch1 is higher than pitch2</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; PitchRest.pitch_comparator('c', 'c')\n0\n&gt;&gt;&gt; PitchRest.pitch_comparator('c', 'd')\n-1\n&gt;&gt;&gt; PitchRest.pitch_comparator('d', 'c')\n1\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@staticmethod\ndef pitch_comparator(pitch_a: str, pitch_b: str) -&gt; int:\n    \"\"\"\n    Compare two pitches of the same octave.\n\n    The lower name is 'a'. So 'a' &lt; 'b' &lt; 'c' &lt; 'd' &lt; 'e' &lt; 'f' &lt; 'g'\n\n    Args:\n        pitch_a: One name of 'abcdefg'\n        pitch_b: Another name of 'abcdefg'\n\n    Returns:\n        -1 if pitch1 is lower than pitch2\n        0 if pitch1 is equal to pitch2\n        1 if pitch1 is higher than pitch2\n\n    Examples:\n        &gt;&gt;&gt; PitchRest.pitch_comparator('c', 'c')\n        0\n        &gt;&gt;&gt; PitchRest.pitch_comparator('c', 'd')\n        -1\n        &gt;&gt;&gt; PitchRest.pitch_comparator('d', 'c')\n        1\n    \"\"\"\n    if pitch_a &lt; pitch_b:\n        return -1\n    if pitch_a &gt; pitch_b:\n        return 1\n    return 0\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff","title":"<code>PositionInStaff</code>","text":"Source code in <code>kernpy/core/gkern.py</code> <pre><code>class PositionInStaff:\n    LINE_CHARACTER = 'L'\n    SPACE_CHARACTER = 'S'\n\n    def __init__(self, line_space: int):\n        \"\"\"\n        Initializes the PositionInStaff object.\n\n        Args:\n            line_space (int): 0 for bottom line, -1 for space under bottom line, 1 for space above bottom line. \\\n             Increments by 1 for each line or space.\n\n        \"\"\"\n        self.line_space = line_space\n\n    @classmethod\n    def from_line(cls, line: int) -&gt; PositionInStaff:\n        \"\"\"\n        Creates a PositionInStaff object from a line number.\n\n        Args:\n            line (int): The line number. line 1 is bottom line, 2 is the 1st line from bottom, 0 is the bottom ledger line\n\n        Returns:\n            PositionInStaff: The PositionInStaff object. 0 for the bottom line, 2 for the 1st line from bottom, -1 for the bottom ledger line, etc.\n        \"\"\"\n        return cls((line - 1) * 2)\n\n    @classmethod\n    def from_space(cls, space: int) -&gt; PositionInStaff:\n        \"\"\"\n        Creates a PositionInStaff object from a space number.\n\n        Args:\n            space (int): The space number. space 1 is bottom space, 2\n\n        Returns:\n            PositionInStaff: The PositionInStaff object.\n        \"\"\"\n        return cls((space) * 2 - 1)\n\n    @classmethod\n    def from_encoded(cls, encoded: str) -&gt; PositionInStaff:\n        \"\"\"\n        Creates a PositionInStaff object from an encoded string.\n\n        Args:\n            encoded (str): The encoded string.\n\n        Returns:\n            PositionInStaff: The PositionInStaff object.\n        \"\"\"\n        if encoded.startswith(cls.LINE_CHARACTER):\n            line = int(encoded[1:])  # Extract the line number\n            return cls.from_line(line)\n        elif encoded.startswith(cls.SPACE_CHARACTER):\n            space = int(encoded[1:])  # Extract the space number\n            return cls.from_space(space)\n        else:\n            raise ValueError(f\"\"\n                             f\"Invalid encoded string: {encoded}. \"\n                             f\"Expected to start with '{cls.LINE_CHARACTER}' or '{cls.SPACE_CHARACTER} at the beginning.\")\n\n\n    def line(self):\n        \"\"\"\n        Returns the line number of the position in staff.\n        \"\"\"\n        return self.line_space // 2 + 1\n\n\n    def space(self):\n        \"\"\"\n        Returns the space number of the position in staff.\n        \"\"\"\n        return (self.line_space - 1) // 2 + 1\n\n\n    def is_line(self) -&gt; bool:\n        \"\"\"\n        Returns True if the position is a line, False otherwise. If is not a line, it is a space, and vice versa.\n        \"\"\"\n        return self.line_space % 2 == 0\n\n    def move(self, line_space_difference: int) -&gt; PositionInStaff:\n        \"\"\"\n        Returns a new PositionInStaff object with the position moved by the given number of lines or spaces.\n\n        Args:\n            line_space_difference (int): The number of lines or spaces to move.\n\n        Returns:\n            PositionInStaff: The new PositionInStaff object.\n        \"\"\"\n        return PositionInStaff(self.line_space + line_space_difference)\n\n    def position_below(self) -&gt; PositionInStaff:\n        \"\"\"\n        Returns the position below the current position.\n        \"\"\"\n        return self.move(-2)\n\n    def position_above(self) -&gt; PositionInStaff:\n        \"\"\"\n        Returns the position above the current position.\n        \"\"\"\n        return self.move(2)\n\n\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns the string representation of the position in staff.\n        \"\"\"\n        if self.is_line():\n            return f\"{self.LINE_CHARACTER}{int(self.line())}\"\n        else:\n            return f\"{self.SPACE_CHARACTER}{int(self.space())}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns the string representation of the PositionInStaff object.\n        \"\"\"\n        return f\"PositionInStaff(line_space={self.line_space}), {self.__str__()}\"\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        Compares two PositionInStaff objects.\n        \"\"\"\n        if not isinstance(other, PositionInStaff):\n            return False\n        return self.line_space == other.line_space\n\n    def __ne__(self, other) -&gt; bool:\n        \"\"\"\n        Compares two PositionInStaff objects.\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Returns the hash of the PositionInStaff object.\n        \"\"\"\n        return hash(self.line_space)\n\n    def __lt__(self, other) -&gt; bool:\n        \"\"\"\n        Compares two PositionInStaff objects.\n        \"\"\"\n        if not isinstance(other, PositionInStaff):\n            return NotImplemented\n        return self.line_space &lt; other.line_space\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Compares two PositionInStaff objects.\n    \"\"\"\n    if not isinstance(other, PositionInStaff):\n        return False\n    return self.line_space == other.line_space\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the PositionInStaff object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Returns the hash of the PositionInStaff object.\n    \"\"\"\n    return hash(self.line_space)\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.__init__","title":"<code>__init__(line_space)</code>","text":"<p>Initializes the PositionInStaff object.</p> <p>Parameters:</p> Name Type Description Default <code>line_space</code> <code>int</code> <p>0 for bottom line, -1 for space under bottom line, 1 for space above bottom line.              Increments by 1 for each line or space.</p> required Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __init__(self, line_space: int):\n    \"\"\"\n    Initializes the PositionInStaff object.\n\n    Args:\n        line_space (int): 0 for bottom line, -1 for space under bottom line, 1 for space above bottom line. \\\n         Increments by 1 for each line or space.\n\n    \"\"\"\n    self.line_space = line_space\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __lt__(self, other) -&gt; bool:\n    \"\"\"\n    Compares two PositionInStaff objects.\n    \"\"\"\n    if not isinstance(other, PositionInStaff):\n        return NotImplemented\n    return self.line_space &lt; other.line_space\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compares two PositionInStaff objects.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __ne__(self, other) -&gt; bool:\n    \"\"\"\n    Compares two PositionInStaff objects.\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the PositionInStaff object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns the string representation of the PositionInStaff object.\n    \"\"\"\n    return f\"PositionInStaff(line_space={self.line_space}), {self.__str__()}\"\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the position in staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns the string representation of the position in staff.\n    \"\"\"\n    if self.is_line():\n        return f\"{self.LINE_CHARACTER}{int(self.line())}\"\n    else:\n        return f\"{self.SPACE_CHARACTER}{int(self.space())}\"\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.from_encoded","title":"<code>from_encoded(encoded)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from an encoded string.</p> <p>Parameters:</p> Name Type Description Default <code>encoded</code> <code>str</code> <p>The encoded string.</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>@classmethod\ndef from_encoded(cls, encoded: str) -&gt; PositionInStaff:\n    \"\"\"\n    Creates a PositionInStaff object from an encoded string.\n\n    Args:\n        encoded (str): The encoded string.\n\n    Returns:\n        PositionInStaff: The PositionInStaff object.\n    \"\"\"\n    if encoded.startswith(cls.LINE_CHARACTER):\n        line = int(encoded[1:])  # Extract the line number\n        return cls.from_line(line)\n    elif encoded.startswith(cls.SPACE_CHARACTER):\n        space = int(encoded[1:])  # Extract the space number\n        return cls.from_space(space)\n    else:\n        raise ValueError(f\"\"\n                         f\"Invalid encoded string: {encoded}. \"\n                         f\"Expected to start with '{cls.LINE_CHARACTER}' or '{cls.SPACE_CHARACTER} at the beginning.\")\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.from_line","title":"<code>from_line(line)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from a line number.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>int</code> <p>The line number. line 1 is bottom line, 2 is the 1st line from bottom, 0 is the bottom ledger line</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object. 0 for the bottom line, 2 for the 1st line from bottom, -1 for the bottom ledger line, etc.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>@classmethod\ndef from_line(cls, line: int) -&gt; PositionInStaff:\n    \"\"\"\n    Creates a PositionInStaff object from a line number.\n\n    Args:\n        line (int): The line number. line 1 is bottom line, 2 is the 1st line from bottom, 0 is the bottom ledger line\n\n    Returns:\n        PositionInStaff: The PositionInStaff object. 0 for the bottom line, 2 for the 1st line from bottom, -1 for the bottom ledger line, etc.\n    \"\"\"\n    return cls((line - 1) * 2)\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.from_space","title":"<code>from_space(space)</code>  <code>classmethod</code>","text":"<p>Creates a PositionInStaff object from a space number.</p> <p>Parameters:</p> Name Type Description Default <code>space</code> <code>int</code> <p>The space number. space 1 is bottom space, 2</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The PositionInStaff object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>@classmethod\ndef from_space(cls, space: int) -&gt; PositionInStaff:\n    \"\"\"\n    Creates a PositionInStaff object from a space number.\n\n    Args:\n        space (int): The space number. space 1 is bottom space, 2\n\n    Returns:\n        PositionInStaff: The PositionInStaff object.\n    \"\"\"\n    return cls((space) * 2 - 1)\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.is_line","title":"<code>is_line()</code>","text":"<p>Returns True if the position is a line, False otherwise. If is not a line, it is a space, and vice versa.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def is_line(self) -&gt; bool:\n    \"\"\"\n    Returns True if the position is a line, False otherwise. If is not a line, it is a space, and vice versa.\n    \"\"\"\n    return self.line_space % 2 == 0\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.line","title":"<code>line()</code>","text":"<p>Returns the line number of the position in staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def line(self):\n    \"\"\"\n    Returns the line number of the position in staff.\n    \"\"\"\n    return self.line_space // 2 + 1\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.move","title":"<code>move(line_space_difference)</code>","text":"<p>Returns a new PositionInStaff object with the position moved by the given number of lines or spaces.</p> <p>Parameters:</p> Name Type Description Default <code>line_space_difference</code> <code>int</code> <p>The number of lines or spaces to move.</p> required <p>Returns:</p> Name Type Description <code>PositionInStaff</code> <code>PositionInStaff</code> <p>The new PositionInStaff object.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def move(self, line_space_difference: int) -&gt; PositionInStaff:\n    \"\"\"\n    Returns a new PositionInStaff object with the position moved by the given number of lines or spaces.\n\n    Args:\n        line_space_difference (int): The number of lines or spaces to move.\n\n    Returns:\n        PositionInStaff: The new PositionInStaff object.\n    \"\"\"\n    return PositionInStaff(self.line_space + line_space_difference)\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.position_above","title":"<code>position_above()</code>","text":"<p>Returns the position above the current position.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def position_above(self) -&gt; PositionInStaff:\n    \"\"\"\n    Returns the position above the current position.\n    \"\"\"\n    return self.move(2)\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.position_below","title":"<code>position_below()</code>","text":"<p>Returns the position below the current position.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def position_below(self) -&gt; PositionInStaff:\n    \"\"\"\n    Returns the position below the current position.\n    \"\"\"\n    return self.move(-2)\n</code></pre>"},{"location":"reference/#kernpy.core.PositionInStaff.space","title":"<code>space()</code>","text":"<p>Returns the space number of the position in staff.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def space(self):\n    \"\"\"\n    Returns the space number of the position in staff.\n    \"\"\"\n    return (self.line_space - 1) // 2 + 1\n</code></pre>"},{"location":"reference/#kernpy.core.RootSpineImporter","title":"<code>RootSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/root_spine_importer.py</code> <pre><code>class RootSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        #return RootSpineListener() # TODO: Create a custom functional listener for RootSpineImporter\n        return KernSpineListener()\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        return token  # The **root spine tokens are always a subset of the **kern spine tokens\n</code></pre>"},{"location":"reference/#kernpy.core.RootSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/root_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.core.SignatureNodes","title":"<code>SignatureNodes</code>","text":"<p>SignatureNodes class.</p> <p>This class is used to store the last signature nodes of a tree. It is used to keep track of the last signature nodes.</p> <p>Attributes: nodes (dict): A dictionary that stores the last signature nodes. This way, we can add several tokens without repetitions. - The key is the signature descendant token class (KeyToken, MeterSymbolToken, etc...) - The value = node</p> Source code in <code>kernpy/core/document.py</code> <pre><code>class SignatureNodes:\n    \"\"\"\n    SignatureNodes class.\n\n    This class is used to store the last signature nodes of a tree.\n    It is used to keep track of the last signature nodes.\n\n    Attributes: nodes (dict): A dictionary that stores the last signature nodes. This way, we can add several tokens\n    without repetitions. - The key is the signature descendant token class (KeyToken, MeterSymbolToken, etc...) - The\n    value = node\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Create an instance of SignatureNodes. Initialize the nodes as an empty dictionary.\n\n        Examples:\n            &gt;&gt;&gt; signature_nodes = SignatureNodes()\n            &gt;&gt;&gt; signature_nodes.nodes\n            {}\n        \"\"\"\n        self.nodes = {}\n\n    def clone(self):\n        \"\"\"\n        Create a deep copy of the SignatureNodes instance.\n        Returns: A new instance of SignatureNodes with nodes copied.\n\n        # TODO: This method is equivalent to the following code:\n        # from copy import deepcopy\n        # signature_nodes_to_copy = SignatureNodes()\n        # ...\n        # result = deepcopy(signature_nodes_to_copy)\n        # It should be tested.\n        \"\"\"\n        result = SignatureNodes()\n        result.nodes = copy(self.nodes)\n        return result\n\n    def update(self, node):\n        self.nodes[node.token.__class__.__name__] = node\n</code></pre>"},{"location":"reference/#kernpy.core.SignatureNodes.__init__","title":"<code>__init__()</code>","text":"<p>Create an instance of SignatureNodes. Initialize the nodes as an empty dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; signature_nodes = SignatureNodes()\n&gt;&gt;&gt; signature_nodes.nodes\n{}\n</code></pre> Source code in <code>kernpy/core/document.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Create an instance of SignatureNodes. Initialize the nodes as an empty dictionary.\n\n    Examples:\n        &gt;&gt;&gt; signature_nodes = SignatureNodes()\n        &gt;&gt;&gt; signature_nodes.nodes\n        {}\n    \"\"\"\n    self.nodes = {}\n</code></pre>"},{"location":"reference/#kernpy.core.SignatureNodes.clone","title":"<code>clone()</code>","text":"<p>Create a deep copy of the SignatureNodes instance. Returns: A new instance of SignatureNodes with nodes copied.</p>"},{"location":"reference/#kernpy.core.SignatureNodes.clone--todo-this-method-is-equivalent-to-the-following-code","title":"TODO: This method is equivalent to the following code:","text":""},{"location":"reference/#kernpy.core.SignatureNodes.clone--from-copy-import-deepcopy","title":"from copy import deepcopy","text":""},{"location":"reference/#kernpy.core.SignatureNodes.clone--signature_nodes_to_copy-signaturenodes","title":"signature_nodes_to_copy = SignatureNodes()","text":""},{"location":"reference/#kernpy.core.SignatureNodes.clone--_1","title":"...","text":""},{"location":"reference/#kernpy.core.SignatureNodes.clone--result-deepcopysignature_nodes_to_copy","title":"result = deepcopy(signature_nodes_to_copy)","text":""},{"location":"reference/#kernpy.core.SignatureNodes.clone--it-should-be-tested","title":"It should be tested.","text":"Source code in <code>kernpy/core/document.py</code> <pre><code>def clone(self):\n    \"\"\"\n    Create a deep copy of the SignatureNodes instance.\n    Returns: A new instance of SignatureNodes with nodes copied.\n\n    # TODO: This method is equivalent to the following code:\n    # from copy import deepcopy\n    # signature_nodes_to_copy = SignatureNodes()\n    # ...\n    # result = deepcopy(signature_nodes_to_copy)\n    # It should be tested.\n    \"\"\"\n    result = SignatureNodes()\n    result.nodes = copy(self.nodes)\n    return result\n</code></pre>"},{"location":"reference/#kernpy.core.SignatureToken","title":"<code>SignatureToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>SignatureToken class for all signature tokens. It will be overridden by more specific classes.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class SignatureToken(SimpleToken):\n    \"\"\"\n    SignatureToken class for all signature tokens. It will be overridden by more specific classes.\n    \"\"\"\n\n    def __init__(self, encoding, category=TokenCategory.SIGNATURES):\n        super().__init__(encoding, category)\n</code></pre>"},{"location":"reference/#kernpy.core.SimpleToken","title":"<code>SimpleToken</code>","text":"<p>               Bases: <code>Token</code></p> <p>SimpleToken class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class SimpleToken(Token):\n    \"\"\"\n    SimpleToken class.\n    \"\"\"\n\n    def __init__(self, encoding, category):\n        super().__init__(encoding, category)\n\n    def export(self, **kwargs) -&gt; str:\n        \"\"\"\n        Exports the token.\n\n        Args:\n            **kwargs: 'filter_categories' (Optional[Callable[[TokenCategory], bool]]): It is ignored in this class.\n\n        Returns (str): The encoded token representation.\n        \"\"\"\n        return self.encoding\n</code></pre>"},{"location":"reference/#kernpy.core.SimpleToken.export","title":"<code>export(**kwargs)</code>","text":"<p>Exports the token.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>'filter_categories' (Optional[Callable[[TokenCategory], bool]]): It is ignored in this class.</p> <code>{}</code> <p>Returns (str): The encoded token representation.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def export(self, **kwargs) -&gt; str:\n    \"\"\"\n    Exports the token.\n\n    Args:\n        **kwargs: 'filter_categories' (Optional[Callable[[TokenCategory], bool]]): It is ignored in this class.\n\n    Returns (str): The encoded token representation.\n    \"\"\"\n    return self.encoding\n</code></pre>"},{"location":"reference/#kernpy.core.SpineImporter","title":"<code>SpineImporter</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>kernpy/core/spine_importer.py</code> <pre><code>class SpineImporter(ABC):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        SpineImporter constructor.\n        This class is an abstract base class for importing all kinds of spines.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        self.import_listener = self.import_listener()\n        self.error_listener = ErrorListener(verbose=verbose)\n\n    @abstractmethod\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        pass\n\n    @abstractmethod\n    def import_token(self, encoding: str) -&gt; Token:\n        pass\n\n    @classmethod\n    def _raise_error_if_wrong_input(cls, encoding: str):\n        if encoding is None:\n            raise ValueError(\"Encoding cannot be None\")\n        if not isinstance(encoding, str):\n            raise TypeError(\"Encoding must be a string\")\n        if encoding == '':\n            raise ValueError(\"Encoding cannot be an empty string\")\n</code></pre>"},{"location":"reference/#kernpy.core.SpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>SpineImporter constructor. This class is an abstract base class for importing all kinds of spines.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    SpineImporter constructor.\n    This class is an abstract base class for importing all kinds of spines.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    self.import_listener = self.import_listener()\n    self.error_listener = ErrorListener(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.core.SpineOperationToken","title":"<code>SpineOperationToken</code>","text":"<p>               Bases: <code>SimpleToken</code></p> <p>SpineOperationToken class.</p> <p>This token represents different operations in the Humdrum kern encoding. These are the available operations:     - <code>*-</code>:  spine-path terminator.     - <code>*</code>: null interpretation.     - <code>*+</code>: add spines.     - <code>*^</code>: split spines.     - <code>*x</code>: exchange spines.</p> <p>Attributes:</p> Name Type Description <code>cancelled_at_stage</code> <code>int</code> <p>The stage at which the operation was cancelled. Defaults to None.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class SpineOperationToken(SimpleToken):\n    \"\"\"\n    SpineOperationToken class.\n\n    This token represents different operations in the Humdrum kern encoding.\n    These are the available operations:\n        - `*-`:  spine-path terminator.\n        - `*`: null interpretation.\n        - `*+`: add spines.\n        - `*^`: split spines.\n        - `*x`: exchange spines.\n\n    Attributes:\n        cancelled_at_stage (int): The stage at which the operation was cancelled. Defaults to None.\n    \"\"\"\n\n    def __init__(self, encoding):\n        super().__init__(encoding, TokenCategory.SPINE_OPERATION)\n        self.cancelled_at_stage = None\n\n    def is_cancelled_at(self, stage) -&gt; bool:\n        \"\"\"\n        Checks if the operation was cancelled at the given stage.\n\n        Args:\n            stage (int): The stage at which the operation was cancelled.\n\n        Returns:\n            bool: True if the operation was cancelled at the given stage, False otherwise.\n        \"\"\"\n        if self.cancelled_at_stage is None:\n            return False\n        else:\n            return self.cancelled_at_stage &lt; stage\n</code></pre>"},{"location":"reference/#kernpy.core.SpineOperationToken.is_cancelled_at","title":"<code>is_cancelled_at(stage)</code>","text":"<p>Checks if the operation was cancelled at the given stage.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>int</code> <p>The stage at which the operation was cancelled.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the operation was cancelled at the given stage, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def is_cancelled_at(self, stage) -&gt; bool:\n    \"\"\"\n    Checks if the operation was cancelled at the given stage.\n\n    Args:\n        stage (int): The stage at which the operation was cancelled.\n\n    Returns:\n        bool: True if the operation was cancelled at the given stage, False otherwise.\n    \"\"\"\n    if self.cancelled_at_stage is None:\n        return False\n    else:\n        return self.cancelled_at_stage &lt; stage\n</code></pre>"},{"location":"reference/#kernpy.core.Staff","title":"<code>Staff</code>","text":"Source code in <code>kernpy/core/gkern.py</code> <pre><code>class Staff:\n    def position_in_staff(self, *, clef: Clef, pitch: AgnosticPitch) -&gt; PositionInStaff:\n        \"\"\"\n        Returns the position in staff for the given clef and pitch.\n        \"\"\"\n        bottom_cleff_note_name = clef.bottom_line()\n</code></pre>"},{"location":"reference/#kernpy.core.Staff.position_in_staff","title":"<code>position_in_staff(*, clef, pitch)</code>","text":"<p>Returns the position in staff for the given clef and pitch.</p> Source code in <code>kernpy/core/gkern.py</code> <pre><code>def position_in_staff(self, *, clef: Clef, pitch: AgnosticPitch) -&gt; PositionInStaff:\n    \"\"\"\n    Returns the position in staff for the given clef and pitch.\n    \"\"\"\n    bottom_cleff_note_name = clef.bottom_line()\n</code></pre>"},{"location":"reference/#kernpy.core.Subtoken","title":"<code>Subtoken</code>","text":"<p>Subtoken class. Thhe subtokens are the smallest units of categories. ComplexToken objects are composed of subtokens.</p> <p>Attributes:</p> Name Type Description <code>encoding</code> <p>The complete unprocessed encoding</p> <code>category</code> <p>The subtoken category, one of SubTokenCategory</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class Subtoken:\n    \"\"\"\n    Subtoken class. Thhe subtokens are the smallest units of categories. ComplexToken objects are composed of subtokens.\n\n    Attributes:\n        encoding: The complete unprocessed encoding\n        category: The subtoken category, one of SubTokenCategory\n    \"\"\"\n    DECORATION = None\n\n    def __init__(self, encoding: str, category: TokenCategory):\n        \"\"\"\n        Subtoken constructor\n\n        Args:\n            encoding (str): The complete unprocessed encoding\n            category (TokenCategory): The subtoken category. \\\n                It should be a child of the main 'TokenCategory' in the hierarchy.\n\n        \"\"\"\n        self.encoding = encoding\n        self.category = category\n\n    def __str__(self):\n        \"\"\"\n        Returns the string representation of the subtoken.\n\n        Returns (str): The string representation of the subtoken.\n        \"\"\"\n        return self.encoding\n\n    def __eq__(self, other):\n        \"\"\"\n        Compare two subtokens.\n\n        Args:\n            other (Subtoken): The other subtoken to compare.\n        Returns (bool): True if the subtokens are equal, False otherwise.\n        \"\"\"\n        if not isinstance(other, Subtoken):\n            return False\n        return self.encoding == other.encoding and self.category == other.category\n\n    def __ne__(self, other):\n        \"\"\"\n        Compare two subtokens.\n\n        Args:\n            other (Subtoken): The other subtoken to compare.\n        Returns (bool): True if the subtokens are different, False otherwise.\n        \"\"\"\n        return not self.__eq__(other)\n\n    def __hash__(self):\n        \"\"\"\n        Returns the hash of the subtoken.\n\n        Returns (int): The hash of the subtoken.\n        \"\"\"\n        return hash((self.encoding, self.category))\n</code></pre>"},{"location":"reference/#kernpy.core.Subtoken.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two subtokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Subtoken</code> <p>The other subtoken to compare.</p> required <p>Returns (bool): True if the subtokens are equal, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compare two subtokens.\n\n    Args:\n        other (Subtoken): The other subtoken to compare.\n    Returns (bool): True if the subtokens are equal, False otherwise.\n    \"\"\"\n    if not isinstance(other, Subtoken):\n        return False\n    return self.encoding == other.encoding and self.category == other.category\n</code></pre>"},{"location":"reference/#kernpy.core.Subtoken.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the subtoken.</p> <p>Returns (int): The hash of the subtoken.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __hash__(self):\n    \"\"\"\n    Returns the hash of the subtoken.\n\n    Returns (int): The hash of the subtoken.\n    \"\"\"\n    return hash((self.encoding, self.category))\n</code></pre>"},{"location":"reference/#kernpy.core.Subtoken.__init__","title":"<code>__init__(encoding, category)</code>","text":"<p>Subtoken constructor</p> <p>Parameters:</p> Name Type Description Default <code>encoding</code> <code>str</code> <p>The complete unprocessed encoding</p> required <code>category</code> <code>TokenCategory</code> <p>The subtoken category.                 It should be a child of the main 'TokenCategory' in the hierarchy.</p> required Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __init__(self, encoding: str, category: TokenCategory):\n    \"\"\"\n    Subtoken constructor\n\n    Args:\n        encoding (str): The complete unprocessed encoding\n        category (TokenCategory): The subtoken category. \\\n            It should be a child of the main 'TokenCategory' in the hierarchy.\n\n    \"\"\"\n    self.encoding = encoding\n    self.category = category\n</code></pre>"},{"location":"reference/#kernpy.core.Subtoken.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Compare two subtokens.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Subtoken</code> <p>The other subtoken to compare.</p> required <p>Returns (bool): True if the subtokens are different, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __ne__(self, other):\n    \"\"\"\n    Compare two subtokens.\n\n    Args:\n        other (Subtoken): The other subtoken to compare.\n    Returns (bool): True if the subtokens are different, False otherwise.\n    \"\"\"\n    return not self.__eq__(other)\n</code></pre>"},{"location":"reference/#kernpy.core.Subtoken.__str__","title":"<code>__str__()</code>","text":"<p>Returns the string representation of the subtoken.</p> <p>Returns (str): The string representation of the subtoken.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Returns the string representation of the subtoken.\n\n    Returns (str): The string representation of the subtoken.\n    \"\"\"\n    return self.encoding\n</code></pre>"},{"location":"reference/#kernpy.core.TextSpineImporter","title":"<code>TextSpineImporter</code>","text":"<p>               Bases: <code>SpineImporter</code></p> Source code in <code>kernpy/core/text_spine_importer.py</code> <pre><code>class TextSpineImporter(SpineImporter):\n    def __init__(self, verbose: Optional[bool] = False):\n        \"\"\"\n        KernSpineImporter constructor.\n\n        Args:\n            verbose (Optional[bool]): Level of verbosity for error messages.\n        \"\"\"\n        super().__init__(verbose=verbose)\n\n    def import_listener(self) -&gt; BaseANTLRSpineParserListener:\n        return KernSpineListener()  # TODO: Create a custom functional listener for TextSpineImporter\n\n    def import_token(self, encoding: str) -&gt; Token:\n        self._raise_error_if_wrong_input(encoding)\n\n        kern_spine_importer = KernSpineImporter()\n        token = kern_spine_importer.import_token(encoding)\n\n        ACCEPTED_CATEGORIES = {\n            TokenCategory.STRUCTURAL,\n            TokenCategory.SIGNATURES,\n            TokenCategory.EMPTY,\n            TokenCategory.BARLINES,\n            TokenCategory.IMAGE_ANNOTATIONS,\n            TokenCategory.BARLINES,\n            TokenCategory.COMMENTS,\n        }\n\n        if not any(TokenCategory.is_child(child=token.category, parent=cat) for cat in ACCEPTED_CATEGORIES):\n            return SimpleToken(encoding, TokenCategory.LYRICS)\n\n        return token\n</code></pre>"},{"location":"reference/#kernpy.core.TextSpineImporter.__init__","title":"<code>__init__(verbose=False)</code>","text":"<p>KernSpineImporter constructor.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>Optional[bool]</code> <p>Level of verbosity for error messages.</p> <code>False</code> Source code in <code>kernpy/core/text_spine_importer.py</code> <pre><code>def __init__(self, verbose: Optional[bool] = False):\n    \"\"\"\n    KernSpineImporter constructor.\n\n    Args:\n        verbose (Optional[bool]): Level of verbosity for error messages.\n    \"\"\"\n    super().__init__(verbose=verbose)\n</code></pre>"},{"location":"reference/#kernpy.core.TimeSignatureToken","title":"<code>TimeSignatureToken</code>","text":"<p>               Bases: <code>SignatureToken</code></p> <p>TimeSignatureToken class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class TimeSignatureToken(SignatureToken):\n    \"\"\"\n    TimeSignatureToken class.\n    \"\"\"\n\n    def __init__(self, encoding):\n        super().__init__(encoding, TokenCategory.TIME_SIGNATURE)\n</code></pre>"},{"location":"reference/#kernpy.core.Token","title":"<code>Token</code>","text":"<p>               Bases: <code>AbstractToken</code>, <code>ABC</code></p> <p>Abstract Token class.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class Token(AbstractToken, ABC):\n    \"\"\"\n    Abstract Token class.\n    \"\"\"\n\n    def __init__(self, encoding, category):\n        super().__init__(encoding, category)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory","title":"<code>TokenCategory</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Options for the category of a token.</p> <p>This is used to determine what kind of token should be exported.</p> <p>The categories are sorted the specific order they are compared to sorthem. But hierarchical order must be defined in other data structures.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class TokenCategory(Enum):\n    \"\"\"\n    Options for the category of a token.\n\n    This is used to determine what kind of token should be exported.\n\n    The categories are sorted the specific order they are compared to sorthem. But hierarchical order must be defined in other data structures.\n    \"\"\"\n    STRUCTURAL = auto()  # header, spine operations\n    HEADER = auto()  # **kern, **mens, **text, **harm, **mxhm, **root, **dyn, **dynam, **fing\n    SPINE_OPERATION = auto()\n    CORE = auto() # notes, rests, chords, etc.\n    ERROR = auto()\n    NOTE_REST = auto()\n    NOTE = auto()\n    DURATION = auto()\n    PITCH = auto()\n    ALTERATION = auto()\n    DECORATION = auto()\n    REST = auto()\n    CHORD = auto()\n    EMPTY = auto()  # placeholders, null interpretation\n    SIGNATURES = auto()\n    CLEF = auto()\n    TIME_SIGNATURE = auto()\n    METER_SYMBOL = auto()\n    KEY_SIGNATURE = auto()\n    KEY_TOKEN = auto()\n    ENGRAVED_SYMBOLS = auto()\n    OTHER_CONTEXTUAL = auto()\n    BARLINES = auto()\n    COMMENTS = auto()\n    FIELD_COMMENTS = auto()\n    LINE_COMMENTS = auto()\n    DYNAMICS = auto()\n    HARMONY = auto()\n    FINGERING = auto()\n    LYRICS = auto()\n    INSTRUMENTS = auto()\n    IMAGE_ANNOTATIONS = auto()\n    BOUNDING_BOXES = auto()\n    LINE_BREAK = auto()\n    OTHER = auto()\n    MHXM = auto()\n    ROOT = auto()\n\n    def __lt__(self, other):\n        \"\"\"\n        Compare two TokenCategory.\n        Args:\n            other (TokenCategory): The other category to compare.\n\n        Returns (bool): True if this category is lower than the other, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.CORE\n            True\n            &gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.STRUCTURAL\n            False\n            &gt;&gt;&gt; TokenCategory.CORE &lt; TokenCategory.STRUCTURAL\n            False\n            &gt;&gt;&gt; sorted([TokenCategory.STRUCTURAL, TokenCategory.CORE])\n            [TokenCategory.STRUCTURAL, TokenCategory.CORE]\n        \"\"\"\n        if isinstance(other, TokenCategory):\n            return self.value &lt; other.value\n        return NotImplemented\n\n    @classmethod\n    def all(cls) -&gt; Set[TokenCategory]:\n        f\"\"\"\n        Get all categories in the hierarchy.\n\n        Returns:\n            Set[TokenCategory]: The set of all categories in the hierarchy.\n\n        Examples:\n            &gt;&gt;&gt; import kernpy as kp\n            &gt;&gt;&gt; kp.TokenCategory.all()\n            set([&lt;TokenCategory.MHXM: 29&gt;, &lt;TokenCategory.COMMENTS: 19&gt;, &lt;TokenCategory.BARLINES: 18&gt;, &lt;TokenCategory.CORE: 2&gt;, &lt;TokenCategory.BOUNDING_BOXES: 27&gt;, &lt;TokenCategory.NOTE_REST: 3&gt;, &lt;TokenCategory.NOTE: 4&gt;, &lt;TokenCategory.ENGRAVED_SYMBOLS: 16&gt;, &lt;TokenCategory.SIGNATURES: 11&gt;, &lt;TokenCategory.REST: 8&gt;, &lt;TokenCategory.METER_SYMBOL: 14&gt;, &lt;TokenCategory.HARMONY: 23&gt;, &lt;TokenCategory.KEY_SIGNATURE: 15&gt;, &lt;TokenCategory.EMPTY: 10&gt;, &lt;TokenCategory.PITCH: 6&gt;, &lt;TokenCategory.LINE_COMMENTS: 21&gt;, &lt;TokenCategory.FINGERING: 24&gt;, &lt;TokenCategory.DECORATION: 7&gt;, &lt;TokenCategory.OTHER: 28&gt;, &lt;TokenCategory.INSTRUMENTS: 26&gt;, &lt;TokenCategory.STRUCTURAL: 1&gt;, &lt;TokenCategory.FIELD_COMMENTS: 20&gt;, &lt;TokenCategory.LYRICS: 25&gt;, &lt;TokenCategory.CLEF: 12&gt;, &lt;TokenCategory.DURATION: 5&gt;, &lt;TokenCategory.DYNAMICS: 22&gt;, &lt;TokenCategory.CHORD: 9&gt;, &lt;TokenCategory.TIME_SIGNATURE: 13&gt;, &lt;TokenCategory.OTHER_CONTEXTUAL: 17&gt;])\n        \"\"\"\n        return set([t for t in TokenCategory])\n\n    @classmethod\n    def tree(cls):\n        \"\"\"\n        Return a string representation of the category hierarchy\n        Returns (str): The string representation of the category hierarchy\n\n        Examples:\n            &gt;&gt;&gt; import kernpy as kp\n            &gt;&gt;&gt; print(kp.TokenCategory.tree())\n            .\n            \u251c\u2500\u2500 TokenCategory.STRUCTURAL\n            \u251c\u2500\u2500 TokenCategory.CORE\n            \u2502   \u251c\u2500\u2500 TokenCategory.NOTE_REST\n            \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.DURATION\n            \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.NOTE\n            \u2502   \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.PITCH\n            \u2502   \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.DECORATION\n            \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.REST\n            \u2502   \u251c\u2500\u2500 TokenCategory.CHORD\n            \u2502   \u2514\u2500\u2500 TokenCategory.EMPTY\n            \u251c\u2500\u2500 TokenCategory.SIGNATURES\n            \u2502   \u251c\u2500\u2500 TokenCategory.CLEF\n            \u2502   \u251c\u2500\u2500 TokenCategory.TIME_SIGNATURE\n            \u2502   \u251c\u2500\u2500 TokenCategory.METER_SYMBOL\n            \u2502   \u2514\u2500\u2500 TokenCategory.KEY_SIGNATURE\n            \u251c\u2500\u2500 TokenCategory.ENGRAVED_SYMBOLS\n            \u251c\u2500\u2500 TokenCategory.OTHER_CONTEXTUAL\n            \u251c\u2500\u2500 TokenCategory.BARLINES\n            \u251c\u2500\u2500 TokenCategory.COMMENTS\n            \u2502   \u251c\u2500\u2500 TokenCategory.FIELD_COMMENTS\n            \u2502   \u2514\u2500\u2500 TokenCategory.LINE_COMMENTS\n            \u251c\u2500\u2500 TokenCategory.DYNAMICS\n            \u251c\u2500\u2500 TokenCategory.HARMONY\n            \u251c\u2500\u2500 TokenCategory.FINGERING\n            \u251c\u2500\u2500 TokenCategory.LYRICS\n            \u251c\u2500\u2500 TokenCategory.INSTRUMENTS\n            \u251c\u2500\u2500 TokenCategory.BOUNDING_BOXES\n            \u2514\u2500\u2500 TokenCategory.OTHER\n        \"\"\"\n        return TokenCategoryHierarchyMapper.tree()\n\n    @classmethod\n    def is_child(cls, *, child: TokenCategory, parent: TokenCategory) -&gt; bool:\n        \"\"\"\n        Check if the child category is a child of the parent category.\n\n        Args:\n            child (TokenCategory): The child category.\n            parent (TokenCategory): The parent category.\n\n        Returns (bool): True if the child category is a child of the parent category, False otherwise.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.is_child(parent=parent, child=child)\n\n    @classmethod\n    def children(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the children of the target category.\n\n        Args:\n            target (TokenCategory): The target category.\n\n        Returns (List[TokenCategory]): The list of child categories of the target category.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.children(parent=target)\n\n    @classmethod\n    def valid(cls, *, include: Optional[Set[TokenCategory]] = None, exclude: Optional[Set[TokenCategory]] = None) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the valid categories based on the include and exclude sets.\n\n        Args:\n            include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n                If None, all categories are included.\n            exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n                If None, no categories are excluded.\n\n        Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.valid(include=include, exclude=exclude)\n\n    @classmethod\n    def leaves(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the leaves of the subtree of the target category.\n\n        Args:\n            target (TokenCategory): The target category.\n\n        Returns (List[TokenCategory]): The list of leaf categories of the target category.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.leaves(target=target)\n\n    @classmethod\n    def nodes(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the nodes of the subtree of the target category.\n\n        Args:\n            target (TokenCategory): The target category.\n\n        Returns (List[TokenCategory]): The list of node categories of the target category.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.nodes(parent=target)\n\n    @classmethod\n    def match(cls,\n              target: TokenCategory, *,\n              include: Optional[Set[TokenCategory]] = None,\n              exclude: Optional[Set[TokenCategory]] = None) -&gt; bool:\n        \"\"\"\n        Check if the target category matches the include and exclude sets.\n\n        Args:\n            target (TokenCategory): The target category.\n            include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n                If None, all categories are included.\n            exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n                If None, no categories are excluded.\n\n        Returns (bool): True if the target category matches the include and exclude sets, False otherwise.\n        \"\"\"\n        return TokenCategoryHierarchyMapper.match(category=target, include=include, exclude=exclude)\n\n    def __str__(self):\n        \"\"\"\n        Get the string representation of the category.\n\n        Returns (str): The string representation of the category.\n        \"\"\"\n        return self.name\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Compare two TokenCategory. Args:     other (TokenCategory): The other category to compare.</p> <p>Returns (bool): True if this category is lower than the other, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.CORE\nTrue\n&gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.STRUCTURAL\nFalse\n&gt;&gt;&gt; TokenCategory.CORE &lt; TokenCategory.STRUCTURAL\nFalse\n&gt;&gt;&gt; sorted([TokenCategory.STRUCTURAL, TokenCategory.CORE])\n[TokenCategory.STRUCTURAL, TokenCategory.CORE]\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __lt__(self, other):\n    \"\"\"\n    Compare two TokenCategory.\n    Args:\n        other (TokenCategory): The other category to compare.\n\n    Returns (bool): True if this category is lower than the other, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.CORE\n        True\n        &gt;&gt;&gt; TokenCategory.STRUCTURAL &lt; TokenCategory.STRUCTURAL\n        False\n        &gt;&gt;&gt; TokenCategory.CORE &lt; TokenCategory.STRUCTURAL\n        False\n        &gt;&gt;&gt; sorted([TokenCategory.STRUCTURAL, TokenCategory.CORE])\n        [TokenCategory.STRUCTURAL, TokenCategory.CORE]\n    \"\"\"\n    if isinstance(other, TokenCategory):\n        return self.value &lt; other.value\n    return NotImplemented\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory.__str__","title":"<code>__str__()</code>","text":"<p>Get the string representation of the category.</p> <p>Returns (str): The string representation of the category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Get the string representation of the category.\n\n    Returns (str): The string representation of the category.\n    \"\"\"\n    return self.name\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory.children","title":"<code>children(target)</code>  <code>classmethod</code>","text":"<p>Get the children of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of child categories of the target category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef children(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the children of the target category.\n\n    Args:\n        target (TokenCategory): The target category.\n\n    Returns (List[TokenCategory]): The list of child categories of the target category.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.children(parent=target)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory.is_child","title":"<code>is_child(*, child, parent)</code>  <code>classmethod</code>","text":"<p>Check if the child category is a child of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>TokenCategory</code> <p>The child category.</p> required <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns (bool): True if the child category is a child of the parent category, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef is_child(cls, *, child: TokenCategory, parent: TokenCategory) -&gt; bool:\n    \"\"\"\n    Check if the child category is a child of the parent category.\n\n    Args:\n        child (TokenCategory): The child category.\n        parent (TokenCategory): The parent category.\n\n    Returns (bool): True if the child category is a child of the parent category, False otherwise.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.is_child(parent=parent, child=child)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory.leaves","title":"<code>leaves(target)</code>  <code>classmethod</code>","text":"<p>Get the leaves of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of leaf categories of the target category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef leaves(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the leaves of the subtree of the target category.\n\n    Args:\n        target (TokenCategory): The target category.\n\n    Returns (List[TokenCategory]): The list of leaf categories of the target category.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.leaves(target=target)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory.match","title":"<code>match(target, *, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Check if the target category matches the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (bool): True if the target category matches the include and exclude sets, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef match(cls,\n          target: TokenCategory, *,\n          include: Optional[Set[TokenCategory]] = None,\n          exclude: Optional[Set[TokenCategory]] = None) -&gt; bool:\n    \"\"\"\n    Check if the target category matches the include and exclude sets.\n\n    Args:\n        target (TokenCategory): The target category.\n        include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n            If None, all categories are included.\n        exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n            If None, no categories are excluded.\n\n    Returns (bool): True if the target category matches the include and exclude sets, False otherwise.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.match(category=target, include=include, exclude=exclude)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory.nodes","title":"<code>nodes(target)</code>  <code>classmethod</code>","text":"<p>Get the nodes of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of node categories of the target category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef nodes(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the nodes of the subtree of the target category.\n\n    Args:\n        target (TokenCategory): The target category.\n\n    Returns (List[TokenCategory]): The list of node categories of the target category.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.nodes(parent=target)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory.tree","title":"<code>tree()</code>  <code>classmethod</code>","text":"<p>Return a string representation of the category hierarchy Returns (str): The string representation of the category hierarchy</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; print(kp.TokenCategory.tree())\n.\n\u251c\u2500\u2500 TokenCategory.STRUCTURAL\n\u251c\u2500\u2500 TokenCategory.CORE\n\u2502   \u251c\u2500\u2500 TokenCategory.NOTE_REST\n\u2502   \u2502   \u251c\u2500\u2500 TokenCategory.DURATION\n\u2502   \u2502   \u251c\u2500\u2500 TokenCategory.NOTE\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.PITCH\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.DECORATION\n\u2502   \u2502   \u2514\u2500\u2500 TokenCategory.REST\n\u2502   \u251c\u2500\u2500 TokenCategory.CHORD\n\u2502   \u2514\u2500\u2500 TokenCategory.EMPTY\n\u251c\u2500\u2500 TokenCategory.SIGNATURES\n\u2502   \u251c\u2500\u2500 TokenCategory.CLEF\n\u2502   \u251c\u2500\u2500 TokenCategory.TIME_SIGNATURE\n\u2502   \u251c\u2500\u2500 TokenCategory.METER_SYMBOL\n\u2502   \u2514\u2500\u2500 TokenCategory.KEY_SIGNATURE\n\u251c\u2500\u2500 TokenCategory.ENGRAVED_SYMBOLS\n\u251c\u2500\u2500 TokenCategory.OTHER_CONTEXTUAL\n\u251c\u2500\u2500 TokenCategory.BARLINES\n\u251c\u2500\u2500 TokenCategory.COMMENTS\n\u2502   \u251c\u2500\u2500 TokenCategory.FIELD_COMMENTS\n\u2502   \u2514\u2500\u2500 TokenCategory.LINE_COMMENTS\n\u251c\u2500\u2500 TokenCategory.DYNAMICS\n\u251c\u2500\u2500 TokenCategory.HARMONY\n\u251c\u2500\u2500 TokenCategory.FINGERING\n\u251c\u2500\u2500 TokenCategory.LYRICS\n\u251c\u2500\u2500 TokenCategory.INSTRUMENTS\n\u251c\u2500\u2500 TokenCategory.BOUNDING_BOXES\n\u2514\u2500\u2500 TokenCategory.OTHER\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef tree(cls):\n    \"\"\"\n    Return a string representation of the category hierarchy\n    Returns (str): The string representation of the category hierarchy\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; print(kp.TokenCategory.tree())\n        .\n        \u251c\u2500\u2500 TokenCategory.STRUCTURAL\n        \u251c\u2500\u2500 TokenCategory.CORE\n        \u2502   \u251c\u2500\u2500 TokenCategory.NOTE_REST\n        \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.DURATION\n        \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.NOTE\n        \u2502   \u2502   \u2502   \u251c\u2500\u2500 TokenCategory.PITCH\n        \u2502   \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.DECORATION\n        \u2502   \u2502   \u2514\u2500\u2500 TokenCategory.REST\n        \u2502   \u251c\u2500\u2500 TokenCategory.CHORD\n        \u2502   \u2514\u2500\u2500 TokenCategory.EMPTY\n        \u251c\u2500\u2500 TokenCategory.SIGNATURES\n        \u2502   \u251c\u2500\u2500 TokenCategory.CLEF\n        \u2502   \u251c\u2500\u2500 TokenCategory.TIME_SIGNATURE\n        \u2502   \u251c\u2500\u2500 TokenCategory.METER_SYMBOL\n        \u2502   \u2514\u2500\u2500 TokenCategory.KEY_SIGNATURE\n        \u251c\u2500\u2500 TokenCategory.ENGRAVED_SYMBOLS\n        \u251c\u2500\u2500 TokenCategory.OTHER_CONTEXTUAL\n        \u251c\u2500\u2500 TokenCategory.BARLINES\n        \u251c\u2500\u2500 TokenCategory.COMMENTS\n        \u2502   \u251c\u2500\u2500 TokenCategory.FIELD_COMMENTS\n        \u2502   \u2514\u2500\u2500 TokenCategory.LINE_COMMENTS\n        \u251c\u2500\u2500 TokenCategory.DYNAMICS\n        \u251c\u2500\u2500 TokenCategory.HARMONY\n        \u251c\u2500\u2500 TokenCategory.FINGERING\n        \u251c\u2500\u2500 TokenCategory.LYRICS\n        \u251c\u2500\u2500 TokenCategory.INSTRUMENTS\n        \u251c\u2500\u2500 TokenCategory.BOUNDING_BOXES\n        \u2514\u2500\u2500 TokenCategory.OTHER\n    \"\"\"\n    return TokenCategoryHierarchyMapper.tree()\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategory.valid","title":"<code>valid(*, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Get the valid categories based on the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef valid(cls, *, include: Optional[Set[TokenCategory]] = None, exclude: Optional[Set[TokenCategory]] = None) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the valid categories based on the include and exclude sets.\n\n    Args:\n        include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n            If None, all categories are included.\n        exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n            If None, no categories are excluded.\n\n    Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.\n    \"\"\"\n    return TokenCategoryHierarchyMapper.valid(include=include, exclude=exclude)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper","title":"<code>TokenCategoryHierarchyMapper</code>","text":"<p>Mapping of the TokenCategory hierarchy.</p> <p>This class is used to define the hierarchy of the TokenCategory. Useful related methods are provided.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>class TokenCategoryHierarchyMapper:\n    \"\"\"\n    Mapping of the TokenCategory hierarchy.\n\n    This class is used to define the hierarchy of the TokenCategory. Useful related methods are provided.\n    \"\"\"\n    \"\"\"\n    The hierarchy of the TokenCategory is a recursive dictionary that defines the parent-child relationships \\\n        between the categories. It's a tree.\n    \"\"\"\n    _hierarchy_typing = Dict[TokenCategory, '_hierarchy_typing']\n    hierarchy: _hierarchy_typing = {\n        TokenCategory.STRUCTURAL: {\n            TokenCategory.HEADER: {},  # each leave must be an empty dictionary\n            TokenCategory.SPINE_OPERATION: {},\n        },\n        TokenCategory.CORE: {\n            TokenCategory.NOTE_REST: {\n                TokenCategory.DURATION: {},\n                TokenCategory.NOTE: {\n                    TokenCategory.PITCH: {},\n                    TokenCategory.DECORATION: {},\n                    TokenCategory.ALTERATION: {},\n                },\n                TokenCategory.REST: {},\n            },\n            TokenCategory.CHORD: {},\n            TokenCategory.EMPTY: {},\n            TokenCategory.ERROR: {},\n        },\n        TokenCategory.SIGNATURES: {\n            TokenCategory.CLEF: {},\n            TokenCategory.TIME_SIGNATURE: {},\n            TokenCategory.METER_SYMBOL: {},\n            TokenCategory.KEY_SIGNATURE: {},\n            TokenCategory.KEY_TOKEN: {},\n        },\n        TokenCategory.ENGRAVED_SYMBOLS: {},\n        TokenCategory.OTHER_CONTEXTUAL: {},\n        TokenCategory.BARLINES: {},\n        TokenCategory.COMMENTS: {\n            TokenCategory.FIELD_COMMENTS: {},\n            TokenCategory.LINE_COMMENTS: {},\n        },\n        TokenCategory.DYNAMICS: {},\n        TokenCategory.HARMONY: {},\n        TokenCategory.FINGERING: {},\n        TokenCategory.LYRICS: {},\n        TokenCategory.INSTRUMENTS: {},\n        TokenCategory.IMAGE_ANNOTATIONS: {\n            TokenCategory.BOUNDING_BOXES: {},\n            TokenCategory.LINE_BREAK: {},\n        },\n        TokenCategory.OTHER: {},\n        TokenCategory.MHXM: {},\n        TokenCategory.ROOT: {},\n    }\n\n    @classmethod\n    def _is_child(cls, parent: TokenCategory, child: TokenCategory, *, tree: '_hierarchy_typing') -&gt; bool:\n        \"\"\"\n        Recursively check if `child` is in the subtree of `parent`.\n\n        Args:\n            parent (TokenCategory): The parent category.\n            child (TokenCategory): The category to check.\n            tree (_hierarchy_typing): The subtree to check.\n\n        Returns:\n            bool: True if `child` is a descendant of `parent`, False otherwise.\n        \"\"\"\n        # Base case: the parent is empty.\n        if len(tree.keys()) == 0:\n            return False\n\n        # Recursive case: explore the direct children of the parent.\n        return any(\n            direct_child == child or cls._is_child(direct_child, child, tree=tree[parent])\n            for direct_child in tree.get(parent, {})\n        )\n        # Vectorized version of the following code:\n        #direct_children = tree.get(parent, dict())\n        #for direct_child in direct_children.keys():\n        #    if direct_child == child or cls._is_child(direct_child, child, tree=tree[parent]):\n        #        return True\n\n    @classmethod\n    def is_child(cls, parent: TokenCategory, child: TokenCategory) -&gt; bool:\n        \"\"\"\n        Recursively check if `child` is in the subtree of `parent`. If `parent` is the same as `child`, return True.\n\n        Args:\n            parent (TokenCategory): The parent category.\n            child (TokenCategory): The category to check.\n\n        Returns:\n            bool: True if `child` is a descendant of `parent`, False otherwise.\n        \"\"\"\n        if parent == child:\n            return True\n        return cls._is_child(parent, child, tree=cls.hierarchy)\n\n    @classmethod\n    def children(cls, parent: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the direct children of the parent category.\n\n        Args:\n            parent (TokenCategory): The parent category.\n\n        Returns:\n            Set[TokenCategory]: The list of children categories of the parent category.\n        \"\"\"\n        return set(cls.hierarchy.get(parent, {}).keys())\n\n    @classmethod\n    def _nodes(cls, tree: _hierarchy_typing) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Recursively get all nodes in the given hierarchy tree.\n        \"\"\"\n        nodes = set(tree.keys())\n        for child in tree.values():\n            nodes.update(cls._nodes(child))\n        return nodes\n\n    @classmethod\n    def _find_subtree(cls, tree: '_hierarchy_typing', parent: TokenCategory) -&gt; Optional['_hierarchy_typing']:\n        \"\"\"\n        Recursively find the subtree for the given parent category.\n        \"\"\"\n        if parent in tree:\n            return tree[parent]  # Return subtree if parent is found at this level\n        for child, sub_tree in tree.items():\n            result = cls._find_subtree(sub_tree, parent)\n            if result is not None:\n                return result\n        return None  # Return None if parent is not found. It won't happer never\n\n\n    @classmethod\n    def nodes(cls, parent: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the all nodes of the subtree of the parent category.\n\n        Args:\n            parent (TokenCategory): The parent category.\n\n        Returns:\n            List[TokenCategory]: The list of nodes of the subtree of the parent category.\n        \"\"\"\n        subtree = cls._find_subtree(cls.hierarchy, parent)\n        return cls._nodes(subtree) if subtree is not None else set()\n\n    @classmethod\n    def valid(cls,\n              include: Optional[Set[TokenCategory]] = None,\n              exclude: Optional[Set[TokenCategory]] = None) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the valid categories based on the include and exclude sets.\n\n        Args:\n            include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n                If None, all categories are included.\n            exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n                If None, no categories are excluded.\n\n        Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.\n        \"\"\"\n        include = cls._validate_include(include)\n        exclude = cls._validate_exclude(exclude)\n\n        included_nodes = set.union(*[(cls.nodes(cat) | {cat}) for cat in include]) if len(include) &gt; 0 else include\n        excluded_nodes = set.union(*[(cls.nodes(cat) | {cat}) for cat in exclude]) if len(exclude) &gt; 0 else exclude\n        return included_nodes - excluded_nodes\n\n    @classmethod\n    def _leaves(cls, tree: '_hierarchy_typing') -&gt; Set[TokenCategory]:\n        \"\"\"\n        Recursively get all leaves (nodes without children) in the hierarchy tree.\n        \"\"\"\n        if not tree:\n            return set()\n        leaves = {node for node, children in tree.items() if not children}\n        for node, children in tree.items():\n            leaves.update(cls._leaves(children))\n        return leaves\n\n    @classmethod\n    def leaves(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get the leaves of the subtree of the target category.\n\n        Args:\n            target (TokenCategory): The target category.\n\n        Returns (List[TokenCategory]): The list of leaf categories of the target category.\n        \"\"\"\n        tree = cls._find_subtree(cls.hierarchy, target)\n        return cls._leaves(tree)\n\n\n    @classmethod\n    def _match(cls, category: TokenCategory, *,\n               include: Set[TokenCategory],\n               exclude: Set[TokenCategory]) -&gt; bool:\n        \"\"\"\n        Check if a category matches include/exclude criteria.\n        \"\"\"\n        # Include the category itself along with its descendants.\n        target_nodes = cls.nodes(category) | {category}\n\n        valid_categories = cls.valid(include=include, exclude=exclude)\n\n        # Check if any node in the target set is in the valid categories.\n        return len(target_nodes &amp; valid_categories) &gt; 0\n\n    @classmethod\n    def _validate_include(cls, include: Optional[Set[TokenCategory]]) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Validate the include set.\n        \"\"\"\n        if include is None:\n            return cls.all()\n        if isinstance(include, (list, tuple)):\n            include = set(include)\n        elif not isinstance(include, set):\n            include = {include}\n        if not all(isinstance(cat, TokenCategory) for cat in include):\n            raise ValueError('Invalid category: include and exclude must be a set of TokenCategory.')\n        return include\n\n    @classmethod\n    def _validate_exclude(cls, exclude: Optional[Set[TokenCategory]]) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Validate the exclude set.\n        \"\"\"\n        if exclude is None:\n            return set()\n        if isinstance(exclude, (list, tuple)):\n            exclude = set(exclude)\n        elif not isinstance(exclude, set):\n            exclude = {exclude}\n        if not all(isinstance(cat, TokenCategory) for cat in exclude):\n            raise ValueError(f'Invalid category: category must be a {TokenCategory.__name__}.')\n        return exclude\n\n\n    @classmethod\n    def match(cls, category: TokenCategory, *,\n              include: Optional[Set[TokenCategory]] = None,\n              exclude: Optional[Set[TokenCategory]] = None) -&gt; bool:\n        \"\"\"\n        Check if the category matches the include and exclude sets.\n            If include is None, all categories are included. \\\n            If exclude is None, no categories are excluded.\n\n        Args:\n            category (TokenCategory): The category to check.\n            include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n                If None, all categories are included.\n            exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n                If None, no categories are excluded.\n\n        Returns (bool): True if the category matches the include and exclude sets, False otherwise.\n\n        Examples:\n            &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST})\n            True\n            &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.REST})\n            True\n            &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.NOTE})\n            False\n            &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\n            True\n            &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.DURATION, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\n            False\n        \"\"\"\n        include = cls._validate_include(include)\n        exclude = cls._validate_exclude(exclude)\n\n        return cls._match(category, include=include, exclude=exclude)\n\n    @classmethod\n    def all(cls) -&gt; Set[TokenCategory]:\n        \"\"\"\n        Get all categories in the hierarchy.\n\n        Returns:\n            Set[TokenCategory]: The set of all categories in the hierarchy.\n        \"\"\"\n        return cls._nodes(cls.hierarchy)\n\n    @classmethod\n    def tree(cls) -&gt; str:\n        \"\"\"\n        Return a string representation of the category hierarchy,\n        formatted similar to the output of the Unix 'tree' command.\n\n        Example output:\n            .\n            \u251c\u2500\u2500 STRUCTURAL\n            \u251c\u2500\u2500 CORE\n            \u2502   \u251c\u2500\u2500 NOTE_REST\n            \u2502   \u2502   \u251c\u2500\u2500 DURATION\n            \u2502   \u2502   \u251c\u2500\u2500 NOTE\n            \u2502   \u2502   \u2502   \u251c\u2500\u2500 PITCH\n            \u2502   \u2502   \u2502   \u2514\u2500\u2500 DECORATION\n            \u2502   \u2502   \u2514\u2500\u2500 REST\n            \u2502   \u251c\u2500\u2500 CHORD\n            \u2502   \u2514\u2500\u2500 EMPTY\n            \u251c\u2500\u2500 SIGNATURES\n            \u2502   \u251c\u2500\u2500 CLEF\n            \u2502   \u251c\u2500\u2500 TIME_SIGNATURE\n            \u2502   \u251c\u2500\u2500 METER_SYMBOL\n            \u2502   \u2514\u2500\u2500 KEY_SIGNATURE\n            \u251c\u2500\u2500 ENGRAVED_SYMBOLS\n            \u251c\u2500\u2500 OTHER_CONTEXTUAL\n            \u251c\u2500\u2500 BARLINES\n            \u251c\u2500\u2500 COMMENTS\n            \u2502   \u251c\u2500\u2500 FIELD_COMMENTS\n            \u2502   \u2514\u2500\u2500 LINE_COMMENTS\n            \u251c\u2500\u2500 DYNAMICS\n            \u251c\u2500\u2500 HARMONY\n            ...\n        \"\"\"\n        def build_tree(tree: Dict[TokenCategory, '_hierarchy_typing'], prefix: str = \"\") -&gt; [str]:\n            lines_buffer = []\n            items = list(tree.items())\n            count = len(items)\n            for index, (category, subtree) in enumerate(items):\n                connector = \"\u2514\u2500\u2500 \" if index == count - 1 else \"\u251c\u2500\u2500 \"\n                lines_buffer.append(prefix + connector + str(category))\n                extension = \"    \" if index == count - 1 else \"\u2502   \"\n                lines_buffer.extend(build_tree(subtree, prefix + extension))\n            return lines_buffer\n\n        lines = [\".\"]\n        lines.extend(build_tree(cls.hierarchy))\n        return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.all","title":"<code>all()</code>  <code>classmethod</code>","text":"<p>Get all categories in the hierarchy.</p> <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>Set[TokenCategory]: The set of all categories in the hierarchy.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef all(cls) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get all categories in the hierarchy.\n\n    Returns:\n        Set[TokenCategory]: The set of all categories in the hierarchy.\n    \"\"\"\n    return cls._nodes(cls.hierarchy)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.children","title":"<code>children(parent)</code>  <code>classmethod</code>","text":"<p>Get the direct children of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>Set[TokenCategory]: The list of children categories of the parent category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef children(cls, parent: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the direct children of the parent category.\n\n    Args:\n        parent (TokenCategory): The parent category.\n\n    Returns:\n        Set[TokenCategory]: The list of children categories of the parent category.\n    \"\"\"\n    return set(cls.hierarchy.get(parent, {}).keys())\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.is_child","title":"<code>is_child(parent, child)</code>  <code>classmethod</code>","text":"<p>Recursively check if <code>child</code> is in the subtree of <code>parent</code>. If <code>parent</code> is the same as <code>child</code>, return True.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <code>child</code> <code>TokenCategory</code> <p>The category to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>child</code> is a descendant of <code>parent</code>, False otherwise.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef is_child(cls, parent: TokenCategory, child: TokenCategory) -&gt; bool:\n    \"\"\"\n    Recursively check if `child` is in the subtree of `parent`. If `parent` is the same as `child`, return True.\n\n    Args:\n        parent (TokenCategory): The parent category.\n        child (TokenCategory): The category to check.\n\n    Returns:\n        bool: True if `child` is a descendant of `parent`, False otherwise.\n    \"\"\"\n    if parent == child:\n        return True\n    return cls._is_child(parent, child, tree=cls.hierarchy)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.leaves","title":"<code>leaves(target)</code>  <code>classmethod</code>","text":"<p>Get the leaves of the subtree of the target category.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>TokenCategory</code> <p>The target category.</p> required <p>Returns (List[TokenCategory]): The list of leaf categories of the target category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef leaves(cls, target: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the leaves of the subtree of the target category.\n\n    Args:\n        target (TokenCategory): The target category.\n\n    Returns (List[TokenCategory]): The list of leaf categories of the target category.\n    \"\"\"\n    tree = cls._find_subtree(cls.hierarchy, target)\n    return cls._leaves(tree)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.match","title":"<code>match(category, *, include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Check if the category matches the include and exclude sets.     If include is None, all categories are included.             If exclude is None, no categories are excluded.</p> <p>Parameters:</p> Name Type Description Default <code>category</code> <code>TokenCategory</code> <p>The category to check.</p> required <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (bool): True if the category matches the include and exclude sets, False otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.REST})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.NOTE})\nFalse\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\nTrue\n&gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.DURATION, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\nFalse\n</code></pre> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef match(cls, category: TokenCategory, *,\n          include: Optional[Set[TokenCategory]] = None,\n          exclude: Optional[Set[TokenCategory]] = None) -&gt; bool:\n    \"\"\"\n    Check if the category matches the include and exclude sets.\n        If include is None, all categories are included. \\\n        If exclude is None, no categories are excluded.\n\n    Args:\n        category (TokenCategory): The category to check.\n        include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n            If None, all categories are included.\n        exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n            If None, no categories are excluded.\n\n    Returns (bool): True if the category matches the include and exclude sets, False otherwise.\n\n    Examples:\n        &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST})\n        True\n        &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.REST})\n        True\n        &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.NOTE_REST}, exclude={TokenCategory.NOTE})\n        False\n        &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.NOTE, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\n        True\n        &gt;&gt;&gt; TokenCategoryHierarchyMapper.match(TokenCategory.DURATION, include={TokenCategory.CORE}, exclude={TokenCategory.DURATION})\n        False\n    \"\"\"\n    include = cls._validate_include(include)\n    exclude = cls._validate_exclude(exclude)\n\n    return cls._match(category, include=include, exclude=exclude)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.nodes","title":"<code>nodes(parent)</code>  <code>classmethod</code>","text":"<p>Get the all nodes of the subtree of the parent category.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>TokenCategory</code> <p>The parent category.</p> required <p>Returns:</p> Type Description <code>Set[TokenCategory]</code> <p>List[TokenCategory]: The list of nodes of the subtree of the parent category.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef nodes(cls, parent: TokenCategory) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the all nodes of the subtree of the parent category.\n\n    Args:\n        parent (TokenCategory): The parent category.\n\n    Returns:\n        List[TokenCategory]: The list of nodes of the subtree of the parent category.\n    \"\"\"\n    subtree = cls._find_subtree(cls.hierarchy, parent)\n    return cls._nodes(subtree) if subtree is not None else set()\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.tree","title":"<code>tree()</code>  <code>classmethod</code>","text":"<p>Return a string representation of the category hierarchy, formatted similar to the output of the Unix 'tree' command.</p> Example output <p>. \u251c\u2500\u2500 STRUCTURAL \u251c\u2500\u2500 CORE \u2502   \u251c\u2500\u2500 NOTE_REST \u2502   \u2502   \u251c\u2500\u2500 DURATION \u2502   \u2502   \u251c\u2500\u2500 NOTE \u2502   \u2502   \u2502   \u251c\u2500\u2500 PITCH \u2502   \u2502   \u2502   \u2514\u2500\u2500 DECORATION \u2502   \u2502   \u2514\u2500\u2500 REST \u2502   \u251c\u2500\u2500 CHORD \u2502   \u2514\u2500\u2500 EMPTY \u251c\u2500\u2500 SIGNATURES \u2502   \u251c\u2500\u2500 CLEF \u2502   \u251c\u2500\u2500 TIME_SIGNATURE \u2502   \u251c\u2500\u2500 METER_SYMBOL \u2502   \u2514\u2500\u2500 KEY_SIGNATURE \u251c\u2500\u2500 ENGRAVED_SYMBOLS \u251c\u2500\u2500 OTHER_CONTEXTUAL \u251c\u2500\u2500 BARLINES \u251c\u2500\u2500 COMMENTS \u2502   \u251c\u2500\u2500 FIELD_COMMENTS \u2502   \u2514\u2500\u2500 LINE_COMMENTS \u251c\u2500\u2500 DYNAMICS \u251c\u2500\u2500 HARMONY ...</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef tree(cls) -&gt; str:\n    \"\"\"\n    Return a string representation of the category hierarchy,\n    formatted similar to the output of the Unix 'tree' command.\n\n    Example output:\n        .\n        \u251c\u2500\u2500 STRUCTURAL\n        \u251c\u2500\u2500 CORE\n        \u2502   \u251c\u2500\u2500 NOTE_REST\n        \u2502   \u2502   \u251c\u2500\u2500 DURATION\n        \u2502   \u2502   \u251c\u2500\u2500 NOTE\n        \u2502   \u2502   \u2502   \u251c\u2500\u2500 PITCH\n        \u2502   \u2502   \u2502   \u2514\u2500\u2500 DECORATION\n        \u2502   \u2502   \u2514\u2500\u2500 REST\n        \u2502   \u251c\u2500\u2500 CHORD\n        \u2502   \u2514\u2500\u2500 EMPTY\n        \u251c\u2500\u2500 SIGNATURES\n        \u2502   \u251c\u2500\u2500 CLEF\n        \u2502   \u251c\u2500\u2500 TIME_SIGNATURE\n        \u2502   \u251c\u2500\u2500 METER_SYMBOL\n        \u2502   \u2514\u2500\u2500 KEY_SIGNATURE\n        \u251c\u2500\u2500 ENGRAVED_SYMBOLS\n        \u251c\u2500\u2500 OTHER_CONTEXTUAL\n        \u251c\u2500\u2500 BARLINES\n        \u251c\u2500\u2500 COMMENTS\n        \u2502   \u251c\u2500\u2500 FIELD_COMMENTS\n        \u2502   \u2514\u2500\u2500 LINE_COMMENTS\n        \u251c\u2500\u2500 DYNAMICS\n        \u251c\u2500\u2500 HARMONY\n        ...\n    \"\"\"\n    def build_tree(tree: Dict[TokenCategory, '_hierarchy_typing'], prefix: str = \"\") -&gt; [str]:\n        lines_buffer = []\n        items = list(tree.items())\n        count = len(items)\n        for index, (category, subtree) in enumerate(items):\n            connector = \"\u2514\u2500\u2500 \" if index == count - 1 else \"\u251c\u2500\u2500 \"\n            lines_buffer.append(prefix + connector + str(category))\n            extension = \"    \" if index == count - 1 else \"\u2502   \"\n            lines_buffer.extend(build_tree(subtree, prefix + extension))\n        return lines_buffer\n\n    lines = [\".\"]\n    lines.extend(build_tree(cls.hierarchy))\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/#kernpy.core.TokenCategoryHierarchyMapper.valid","title":"<code>valid(include=None, exclude=None)</code>  <code>classmethod</code>","text":"<p>Get the valid categories based on the include and exclude sets.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to include. Defaults to None.                 If None, all categories are included.</p> <code>None</code> <code>exclude</code> <code>Optional[Set[TokenCategory]]</code> <p>The set of categories to exclude. Defaults to None.                 If None, no categories are excluded.</p> <code>None</code> <p>Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.</p> Source code in <code>kernpy/core/tokens.py</code> <pre><code>@classmethod\ndef valid(cls,\n          include: Optional[Set[TokenCategory]] = None,\n          exclude: Optional[Set[TokenCategory]] = None) -&gt; Set[TokenCategory]:\n    \"\"\"\n    Get the valid categories based on the include and exclude sets.\n\n    Args:\n        include (Optional[Set[TokenCategory]]): The set of categories to include. Defaults to None. \\\n            If None, all categories are included.\n        exclude (Optional[Set[TokenCategory]]): The set of categories to exclude. Defaults to None. \\\n            If None, no categories are excluded.\n\n    Returns (Set[TokenCategory]): The list of valid categories based on the include and exclude sets.\n    \"\"\"\n    include = cls._validate_include(include)\n    exclude = cls._validate_exclude(exclude)\n\n    included_nodes = set.union(*[(cls.nodes(cat) | {cat}) for cat in include]) if len(include) &gt; 0 else include\n    excluded_nodes = set.union(*[(cls.nodes(cat) | {cat}) for cat in exclude]) if len(exclude) &gt; 0 else exclude\n    return included_nodes - excluded_nodes\n</code></pre>"},{"location":"reference/#kernpy.core.Tokenizer","title":"<code>Tokenizer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Tokenizer interface. All tokenizers must implement this interface.</p> <p>Tokenizers are responsible for converting a token into a string representation.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>class Tokenizer(ABC):\n    \"\"\"\n    Tokenizer interface. All tokenizers must implement this interface.\n\n    Tokenizers are responsible for converting a token into a string representation.\n    \"\"\"\n    def __init__(self, *, token_categories: Set['TokenCategory']):\n        \"\"\"\n        Create a new Tokenizer.\n\n        Args:\n            token_categories Set[TokenCategory]: List of categories to be tokenized.\n                If None, an exception will be raised.\n        \"\"\"\n        if token_categories is None:\n            raise ValueError('Categories must be provided. Found None.')\n\n        self.token_categories = token_categories\n\n\n    @abstractmethod\n    def tokenize(self, token: Token) -&gt; str:\n        \"\"\"\n        Tokenize a token into a string representation.\n\n        Args:\n            token (Token): Token to be tokenized.\n\n        Returns (str): Tokenized string representation.\n\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/#kernpy.core.Tokenizer.__init__","title":"<code>__init__(*, token_categories)</code>","text":"<p>Create a new Tokenizer.</p> <p>Parameters:</p> Name Type Description Default <code>token_categories</code> <code>Set[TokenCategory]</code> <p>List of categories to be tokenized. If None, an exception will be raised.</p> required Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>def __init__(self, *, token_categories: Set['TokenCategory']):\n    \"\"\"\n    Create a new Tokenizer.\n\n    Args:\n        token_categories Set[TokenCategory]: List of categories to be tokenized.\n            If None, an exception will be raised.\n    \"\"\"\n    if token_categories is None:\n        raise ValueError('Categories must be provided. Found None.')\n\n    self.token_categories = token_categories\n</code></pre>"},{"location":"reference/#kernpy.core.Tokenizer.tokenize","title":"<code>tokenize(token)</code>  <code>abstractmethod</code>","text":"<p>Tokenize a token into a string representation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Token</code> <p>Token to be tokenized.</p> required <p>Returns (str): Tokenized string representation.</p> Source code in <code>kernpy/core/tokenizers.py</code> <pre><code>@abstractmethod\ndef tokenize(self, token: Token) -&gt; str:\n    \"\"\"\n    Tokenize a token into a string representation.\n\n    Args:\n        token (Token): Token to be tokenized.\n\n    Returns (str): Tokenized string representation.\n\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#kernpy.core.TokensTraversal","title":"<code>TokensTraversal</code>","text":"<p>               Bases: <code>TreeTraversalInterface</code></p> Source code in <code>kernpy/core/document.py</code> <pre><code>class TokensTraversal(TreeTraversalInterface):\n    def __init__(\n            self,\n            non_repeated: bool,\n            filter_by_categories\n    ):\n        \"\"\"\n        Create an instance of `TokensTraversal`.\n        Args:\n            non_repeated: If True, only unique tokens are returned. If False, all tokens are returned.\n            filter_by_categories: A list of categories to filter the tokens. If None, all tokens are returned.\n        \"\"\"\n        self.tokens = []\n        self.seen_encodings = []\n        self.non_repeated = non_repeated\n        self.filter_by_categories = [t for t in TokenCategory] if filter_by_categories is None else filter_by_categories\n\n    def visit(self, node):\n        if (node.token\n                and (not self.non_repeated or node.token.encoding not in self.seen_encodings)\n                and (self.filter_by_categories is None or node.token.category in self.filter_by_categories)\n        ):\n            self.tokens.append(node.token)\n            if self.non_repeated:\n                self.seen_encodings.append(node.token.encoding)\n</code></pre>"},{"location":"reference/#kernpy.core.TokensTraversal.__init__","title":"<code>__init__(non_repeated, filter_by_categories)</code>","text":"<p>Create an instance of <code>TokensTraversal</code>. Args:     non_repeated: If True, only unique tokens are returned. If False, all tokens are returned.     filter_by_categories: A list of categories to filter the tokens. If None, all tokens are returned.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>def __init__(\n        self,\n        non_repeated: bool,\n        filter_by_categories\n):\n    \"\"\"\n    Create an instance of `TokensTraversal`.\n    Args:\n        non_repeated: If True, only unique tokens are returned. If False, all tokens are returned.\n        filter_by_categories: A list of categories to filter the tokens. If None, all tokens are returned.\n    \"\"\"\n    self.tokens = []\n    self.seen_encodings = []\n    self.non_repeated = non_repeated\n    self.filter_by_categories = [t for t in TokenCategory] if filter_by_categories is None else filter_by_categories\n</code></pre>"},{"location":"reference/#kernpy.core.TraversalFactory","title":"<code>TraversalFactory</code>","text":"Source code in <code>kernpy/core/document.py</code> <pre><code>class TraversalFactory:\n    class Categories(Enum):\n        METACOMMENTS = \"metacomments\"\n        TOKENS = \"tokens\"\n\n    @classmethod\n    def create(\n            cls,\n            traversal_type: str,\n            non_repeated: bool,\n            filter_by_categories: Optional[Sequence[TokenCategory]]\n    ) -&gt; TreeTraversalInterface:\n        \"\"\"\n        Create an instance of `TreeTraversalInterface` based on the `traversal_type`.\n        Args:\n            non_repeated:\n            filter_by_categories:\n            traversal_type: The type of traversal to use. Possible values are:\n                - \"metacomments\"\n                - \"tokens\"\n\n        Returns: An instance of `TreeTraversalInterface`.\n        \"\"\"\n        if traversal_type == cls.Categories.METACOMMENTS.value:\n            return MetacommentsTraversal()\n        elif traversal_type == cls.Categories.TOKENS.value:\n            return TokensTraversal(non_repeated, filter_by_categories)\n\n        raise ValueError(f\"Unknown traversal type: {traversal_type}\")\n</code></pre>"},{"location":"reference/#kernpy.core.TraversalFactory.create","title":"<code>create(traversal_type, non_repeated, filter_by_categories)</code>  <code>classmethod</code>","text":"<p>Create an instance of <code>TreeTraversalInterface</code> based on the <code>traversal_type</code>. Args:     non_repeated:     filter_by_categories:     traversal_type: The type of traversal to use. Possible values are:         - \"metacomments\"         - \"tokens\"</p> <p>Returns: An instance of <code>TreeTraversalInterface</code>.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>@classmethod\ndef create(\n        cls,\n        traversal_type: str,\n        non_repeated: bool,\n        filter_by_categories: Optional[Sequence[TokenCategory]]\n) -&gt; TreeTraversalInterface:\n    \"\"\"\n    Create an instance of `TreeTraversalInterface` based on the `traversal_type`.\n    Args:\n        non_repeated:\n        filter_by_categories:\n        traversal_type: The type of traversal to use. Possible values are:\n            - \"metacomments\"\n            - \"tokens\"\n\n    Returns: An instance of `TreeTraversalInterface`.\n    \"\"\"\n    if traversal_type == cls.Categories.METACOMMENTS.value:\n        return MetacommentsTraversal()\n    elif traversal_type == cls.Categories.TOKENS.value:\n        return TokensTraversal(non_repeated, filter_by_categories)\n\n    raise ValueError(f\"Unknown traversal type: {traversal_type}\")\n</code></pre>"},{"location":"reference/#kernpy.core.TreeTraversalInterface","title":"<code>TreeTraversalInterface</code>","text":"<p>               Bases: <code>ABC</code></p> <p>TreeTraversalInterface class.</p> <p>This class is used to traverse the tree. The <code>TreeTraversalInterface</code> class is responsible for implementing the <code>visit</code> method.</p> Source code in <code>kernpy/core/document.py</code> <pre><code>class TreeTraversalInterface(ABC):\n    \"\"\"\n    TreeTraversalInterface class.\n\n    This class is used to traverse the tree. The `TreeTraversalInterface` class is responsible for implementing\n    the `visit` method.\n    \"\"\"\n\n    @abstractmethod\n    def visit(self, node):\n        pass\n</code></pre>"},{"location":"reference/#kernpy.core.agnostic_distance","title":"<code>agnostic_distance(first_pitch, second_pitch)</code>","text":"<p>Calculate the distance in semitones between two pitches.</p> <p>Parameters:</p> Name Type Description Default <code>first_pitch</code> <code>AgnosticPitch</code> <p>The first pitch to compare.</p> required <code>second_pitch</code> <code>AgnosticPitch</code> <p>The second pitch to compare.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The distance in semitones between the two pitches.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('E4'))\n4\n&gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('B3'))\n-1\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def agnostic_distance(\n    first_pitch: AgnosticPitch,\n    second_pitch: AgnosticPitch,\n) -&gt; int:\n    \"\"\"\n    Calculate the distance in semitones between two pitches.\n\n    Args:\n        first_pitch (AgnosticPitch): The first pitch to compare.\n        second_pitch (AgnosticPitch): The second pitch to compare.\n\n    Returns:\n        int: The distance in semitones between the two pitches.\n\n    Examples:\n        &gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('E4'))\n        4\n        &gt;&gt;&gt; agnostic_distance(AgnosticPitch('C4'), AgnosticPitch('B3'))\n        -1\n    \"\"\"\n    def semitone_index(p: AgnosticPitch) -&gt; int:\n        # base letter:\n        letter = p.name.replace('+', '').replace('-', '')\n        base = LETTER_TO_SEMITONES[letter]\n        # accidentals: '+' is one sharp, '-' one flat\n        alteration = p.name.count('+') - p.name.count('-')\n        return p.octave * 12 + base + alteration\n\n    return semitone_index(second_pitch) - semitone_index(first_pitch)\n</code></pre>"},{"location":"reference/#kernpy.core.create","title":"<code>create(content, strict=False)</code>","text":"<pre><code>Create a Document object from a string encoded in Humdrum **kern format.\n\nArgs:\n    content: String encoded in Humdrum **kern format\n    strict: If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.\n\nReturns (Document, list): Document object and list of error messages. Empty list if no errors.\n\nExamples:\n    &gt;&gt;&gt; import kernpy as kp\n    &gt;&gt;&gt; document, errors = kp.create('**kern\n</code></pre> <p>4e 4f 4g - ')         &gt;&gt;&gt; if len(errors) &gt; 0:         &gt;&gt;&gt;     print(errors)         ['Error: Invalid kern spine: 1', 'Error: Invalid *kern spine: 2']</p> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'loads' instead.\")\ndef create(\n        content: str,\n        strict=False\n) -&gt; (Document, []):\n    \"\"\"\n    Create a Document object from a string encoded in Humdrum **kern format.\n\n    Args:\n        content: String encoded in Humdrum **kern format\n        strict: If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.\n\n    Returns (Document, list): Document object and list of error messages. Empty list if no errors.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.create('**kern\\n4e\\n4f\\n4g\\n*-\\n')\n        &gt;&gt;&gt; if len(errors) &gt; 0:\n        &gt;&gt;&gt;     print(errors)\n        ['Error: Invalid **kern spine: 1', 'Error: Invalid **kern spine: 2']\n    \"\"\"\n    return Generic.create(\n        content=content,\n        strict=strict\n    )\n</code></pre>"},{"location":"reference/#kernpy.core.deprecated","title":"<code>deprecated(reason)</code>","text":"<p>Decorator to mark a function or class as deprecated.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>The reason why the function/class is deprecated.</p> required Example <p>@deprecated(\"Use new_function instead.\") def old_function():     pass</p> Source code in <code>kernpy/util/helpers.py</code> <pre><code>def deprecated(reason: str):\n    \"\"\"\n    Decorator to mark a function or class as deprecated.\n\n    Args:\n        reason (str): The reason why the function/class is deprecated.\n\n    Example:\n        @deprecated(\"Use new_function instead.\")\n        def old_function():\n            pass\n    \"\"\"\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            warnings.warn(\n                f\"'{func.__name__}' is deprecated: {reason}\",\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"reference/#kernpy.core.distance","title":"<code>distance(first_encoding, second_encoding, *, first_format=NotationEncoding.HUMDRUM.value, second_format=NotationEncoding.HUMDRUM.value)</code>","text":"<p>Calculate the distance in semitones between two pitches.</p> <p>Parameters:</p> Name Type Description Default <code>first_encoding</code> <code>str</code> <p>The first pitch to compare.</p> required <code>second_encoding</code> <code>str</code> <p>The second pitch to compare.</p> required <code>first_format</code> <code>str</code> <p>The encoding format of the first pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>second_format</code> <code>str</code> <p>The encoding format of the second pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The distance in semitones between the two pitches.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; distance('C4', 'E4')\n4\n&gt;&gt;&gt; distance('C4', 'B3')\n-1\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def distance(\n    first_encoding: str,\n    second_encoding: str,\n    *,\n    first_format: str = NotationEncoding.HUMDRUM.value,\n    second_format: str = NotationEncoding.HUMDRUM.value,\n) -&gt; int:\n    \"\"\"\n    Calculate the distance in semitones between two pitches.\n\n    Args:\n        first_encoding (str): The first pitch to compare.\n        second_encoding (str): The second pitch to compare.\n        first_format (str): The encoding format of the first pitch. Default is HUMDRUM.\n        second_format (str): The encoding format of the second pitch. Default is HUMDRUM.\n\n    Returns:\n        int: The distance in semitones between the two pitches.\n\n    Examples:\n        &gt;&gt;&gt; distance('C4', 'E4')\n        4\n        &gt;&gt;&gt; distance('C4', 'B3')\n        -1\n    \"\"\"\n    first_importer = PitchImporterFactory.create(first_format)\n    first_pitch: AgnosticPitch = first_importer.import_pitch(first_encoding)\n\n    second_importer = PitchImporterFactory.create(second_format)\n    second_pitch: AgnosticPitch = second_importer.import_pitch(second_encoding)\n\n    return agnostic_distance(first_pitch, second_pitch)\n</code></pre>"},{"location":"reference/#kernpy.core.ekern_to_krn","title":"<code>ekern_to_krn(input_file, output_file)</code>","text":"<p>Convert one .ekrn file to .krn file.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Filepath to the input **ekern</p> required <code>output_file</code> <code>str</code> <p>Filepath to the output **kern</p> required <p>Returns:     None</p> Example Source code in <code>kernpy/core/exporter.py</code> <pre><code>def ekern_to_krn(\n        input_file: str,\n        output_file: str\n) -&gt; None:\n    \"\"\"\n    Convert one .ekrn file to .krn file.\n\n    Args:\n        input_file (str): Filepath to the input **ekern\n        output_file (str): Filepath to the output **kern\n    Returns:\n        None\n\n    Example:\n        # Convert .ekrn to .krn\n        &gt;&gt;&gt; ekern_to_krn('path/to/file.ekrn', 'path/to/file.krn')\n\n        # Convert a list of .ekrn files to .krn files\n        ```python\n        ekrn_files = your_modue.get_files()\n\n        # Use the wrapper to avoid stopping the process if an error occurs\n        def ekern_to_krn_wrapper(ekern_file, kern_file):\n            try:\n                ekern_to_krn(ekrn_files, output_folder)\n            except Exception as e:\n                print(f'Error:{e}')\n\n        # Convert all the files\n        for ekern_file in ekrn_files:\n            output_file = ekern_file.replace('.ekrn', '.krn')\n            ekern_to_krn_wrapper(ekern_file, output_file)\n        ```\n    \"\"\"\n    with open(input_file, 'r') as file:\n        content = file.read()\n\n    kern_content = get_kern_from_ekern(content)\n\n    with open(output_file, 'w') as file:\n        file.write(kern_content)\n</code></pre>"},{"location":"reference/#kernpy.core.ekern_to_krn--convert-ekrn-to-krn","title":"Convert .ekrn to .krn","text":"<p>ekern_to_krn('path/to/file.ekrn', 'path/to/file.krn')</p>"},{"location":"reference/#kernpy.core.ekern_to_krn--convert-a-list-of-ekrn-files-to-krn-files","title":"Convert a list of .ekrn files to .krn files","text":"<pre><code>ekrn_files = your_modue.get_files()\n\n# Use the wrapper to avoid stopping the process if an error occurs\ndef ekern_to_krn_wrapper(ekern_file, kern_file):\n    try:\n        ekern_to_krn(ekrn_files, output_folder)\n    except Exception as e:\n        print(f'Error:{e}')\n\n# Convert all the files\nfor ekern_file in ekrn_files:\n    output_file = ekern_file.replace('.ekrn', '.krn')\n    ekern_to_krn_wrapper(ekern_file, output_file)\n</code></pre>"},{"location":"reference/#kernpy.core.export","title":"<code>export(document, options)</code>","text":"<p>Export a Document object to a string.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to export</p> required <code>options</code> <code>ExportOptions</code> <p>Export options</p> required <p>Returns: Exported string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; options = kp.ExportOptions()\n&gt;&gt;&gt; content = kp.export(document, options)\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'dumps' instead.\")\ndef export(\n        document: Document,\n        options: ExportOptions\n) -&gt; str:\n    \"\"\"\n    Export a Document object to a string.\n\n    Args:\n        document: Document object to export\n        options: Export options\n\n    Returns: Exported string\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n        &gt;&gt;&gt; options = kp.ExportOptions()\n        &gt;&gt;&gt; content = kp.export(document, options)\n    \"\"\"\n    return Generic.export(\n        document=document,\n        options=options\n    )\n</code></pre>"},{"location":"reference/#kernpy.core.get_kern_from_ekern","title":"<code>get_kern_from_ekern(ekern_content)</code>","text":"<p>Read the content of a ekern file and return the kern content.</p> <p>Parameters:</p> Name Type Description Default <code>ekern_content</code> <code>str</code> <p>The content of the **ekern file.</p> required <p>Returns:     The content of the **kern file.</p> Example <pre><code># Read **ekern file\nekern_file = 'path/to/file.ekrn'\nwith open(ekern_file, 'r') as file:\n    ekern_content = file.read()\n\n# Get **kern content\nkern_content = get_kern_from_ekern(ekern_content)\nwith open('path/to/file.krn', 'w') as file:\n    file.write(kern_content)\n\n</code></pre> Source code in <code>kernpy/core/exporter.py</code> <pre><code>def get_kern_from_ekern(ekern_content: str) -&gt; str:\n    \"\"\"\n    Read the content of a **ekern file and return the **kern content.\n\n    Args:\n        ekern_content: The content of the **ekern file.\n    Returns:\n        The content of the **kern file.\n\n    Example:\n        ```python\n        # Read **ekern file\n        ekern_file = 'path/to/file.ekrn'\n        with open(ekern_file, 'r') as file:\n            ekern_content = file.read()\n\n        # Get **kern content\n        kern_content = get_kern_from_ekern(ekern_content)\n        with open('path/to/file.krn', 'w') as file:\n            file.write(kern_content)\n\n        ```\n    \"\"\"\n    content = ekern_content.replace(\"**ekern\", \"**kern\")  # TODO Constante seg\u00fan las cabeceras\n    content = content.replace(TOKEN_SEPARATOR, \"\")\n    content = content.replace(DECORATION_SEPARATOR, \"\")\n\n    return content\n</code></pre>"},{"location":"reference/#kernpy.core.get_spine_types","title":"<code>get_spine_types(document, spine_types=None)</code>","text":"<p>Get the spines of a Document object.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to get spines from</p> required <code>spine_types</code> <code>Optional[Sequence[str]]</code> <p>List of spine types to get. If None, all spines are returned.</p> <code>None</code> <p>Returns (List[str]): List of spines</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n&gt;&gt;&gt; kp.get_spine_types(document)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, None)\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern'])\n['**kern', '**kern', '**kern', '**kern']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root'])\n['**kern', '**kern', '**kern', '**kern', '**root']\n&gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root', '**harm'])\n['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n&gt;&gt;&gt; kp.get_spine_types(document, [])\n[]\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'spine_types' instead.\")\ndef get_spine_types(\n        document: Document,\n        spine_types: Optional[Sequence[str]] = None\n) -&gt; List[str]:\n    \"\"\"\n    Get the spines of a Document object.\n\n    Args:\n        document (Document): Document object to get spines from\n        spine_types (Optional[Sequence[str]]): List of spine types to get. If None, all spines are returned.\n\n    Returns (List[str]): List of spines\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n        &gt;&gt;&gt; kp.get_spine_types(document)\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; kp.get_spine_types(document, None)\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; kp.get_spine_types(document, ['**kern'])\n        ['**kern', '**kern', '**kern', '**kern']\n        &gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root'])\n        ['**kern', '**kern', '**kern', '**kern', '**root']\n        &gt;&gt;&gt; kp.get_spine_types(document, ['**kern', '**root', '**harm'])\n        ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n        &gt;&gt;&gt; kp.get_spine_types(document, [])\n        []\n    \"\"\"\n    return Generic.get_spine_types(\n        document=document,\n        spine_types=spine_types\n    )\n</code></pre>"},{"location":"reference/#kernpy.core.kern_to_ekern","title":"<code>kern_to_ekern(input_file, output_file)</code>","text":"<p>Convert one .krn file to .ekrn file</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Filepath to the input **kern</p> required <code>output_file</code> <code>str</code> <p>Filepath to the output **ekern</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example Source code in <code>kernpy/core/exporter.py</code> <pre><code>def kern_to_ekern(\n        input_file: str,\n        output_file: str\n) -&gt; None:\n    \"\"\"\n    Convert one .krn file to .ekrn file\n\n    Args:\n        input_file (str): Filepath to the input **kern\n        output_file (str): Filepath to the output **ekern\n\n    Returns:\n        None\n\n    Example:\n        # Convert .krn to .ekrn\n        &gt;&gt;&gt; kern_to_ekern('path/to/file.krn', 'path/to/file.ekrn')\n\n        # Convert a list of .krn files to .ekrn files\n        ```python\n        krn_files = your_module.get_files()\n\n        # Use the wrapper to avoid stopping the process if an error occurs\n        def kern_to_ekern_wrapper(krn_file, ekern_file):\n            try:\n                kern_to_ekern(krn_file, ekern_file)\n            except Exception as e:\n                print(f'Error:{e}')\n\n        # Convert all the files\n        for krn_file in krn_files:\n            output_file = krn_file.replace('.krn', '.ekrn')\n            kern_to_ekern_wrapper(krn_file, output_file)\n        ```\n\n    \"\"\"\n    importer = Importer()\n    document = importer.import_file(input_file)\n\n    if len(importer.errors):\n        raise Exception(f'ERROR: {input_file} has errors {importer.get_error_messages()}')\n\n    export_options = ExportOptions(spine_types=['**kern'], token_categories=BEKERN_CATEGORIES,\n                                   kern_type=Encoding.eKern)\n    exporter = Exporter()\n    exported_ekern = exporter.export_string(document, export_options)\n\n    with open(output_file, 'w') as file:\n        file.write(exported_ekern)\n</code></pre>"},{"location":"reference/#kernpy.core.kern_to_ekern--convert-krn-to-ekrn","title":"Convert .krn to .ekrn","text":"<p>kern_to_ekern('path/to/file.krn', 'path/to/file.ekrn')</p>"},{"location":"reference/#kernpy.core.kern_to_ekern--convert-a-list-of-krn-files-to-ekrn-files","title":"Convert a list of .krn files to .ekrn files","text":"<pre><code>krn_files = your_module.get_files()\n\n# Use the wrapper to avoid stopping the process if an error occurs\ndef kern_to_ekern_wrapper(krn_file, ekern_file):\n    try:\n        kern_to_ekern(krn_file, ekern_file)\n    except Exception as e:\n        print(f'Error:{e}')\n\n# Convert all the files\nfor krn_file in krn_files:\n    output_file = krn_file.replace('.krn', '.ekrn')\n    kern_to_ekern_wrapper(krn_file, output_file)\n</code></pre>"},{"location":"reference/#kernpy.core.read","title":"<code>read(path, strict=False)</code>","text":"<p>Read a Humdrum **kern file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>File path to read</p> required <code>strict</code> <code>Optional[bool]</code> <p>If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.</p> <code>False</code> <p>Returns (Document, List[str]): Document object and list of error messages. Empty list if no errors.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n</code></pre> <pre><code>&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; if len(errors) &gt; 0:\n&gt;&gt;&gt;     print(errors)\n['Error: Invalid **kern spine: 1', 'Error: Invalid **kern spine: 2']\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'load' instead.\")\ndef read(\n        path: Union[str, Path],\n        strict: Optional[bool] = False\n) -&gt; (Document, List[str]):\n    \"\"\"\n    Read a Humdrum **kern file.\n\n    Args:\n        path (Union[str, Path]): File path to read\n        strict (Optional[bool]): If True, raise an error if the **kern file has any errors. Otherwise, return a list of errors.\n\n    Returns (Document, List[str]): Document object and list of error messages. Empty list if no errors.\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, _ = kp.read('path/to/file.krn')\n\n        &gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n        &gt;&gt;&gt; if len(errors) &gt; 0:\n        &gt;&gt;&gt;     print(errors)\n        ['Error: Invalid **kern spine: 1', 'Error: Invalid **kern spine: 2']\n    \"\"\"\n    return Generic.read(\n        path=Path(path),\n        strict=strict\n    )\n</code></pre>"},{"location":"reference/#kernpy.core.store","title":"<code>store(document, path, options)</code>","text":"<p>Store a Document object to a file.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to store</p> required <code>path</code> <code>Union[str, Path]</code> <p>File path to store</p> required <code>options</code> <code>ExportOptions</code> <p>Export options</p> required <p>Returns: None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; options = kp.ExportOptions()\n&gt;&gt;&gt; kp.store(document, 'path/to/store.krn', options)\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'dump' instead.\")\ndef store(\n        document: Document,\n        path: Union[str, Path],\n        options: ExportOptions\n) -&gt; None:\n    \"\"\"\n    Store a Document object to a file.\n\n    Args:\n        document (Document): Document object to store\n        path (Union[str, Path]): File path to store\n        options (ExportOptions): Export options\n\n    Returns: None\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n        &gt;&gt;&gt; options = kp.ExportOptions()\n        &gt;&gt;&gt; kp.store(document, 'path/to/store.krn', options)\n\n    \"\"\"\n    Generic.store(\n        document=document,\n        path=Path(path),\n        options=options\n    )\n</code></pre>"},{"location":"reference/#kernpy.core.store_graph","title":"<code>store_graph(document, path)</code>","text":"<p>Create a graph representation of a Document object using Graphviz. Save the graph to a file.</p> <p>Parameters:</p> Name Type Description Default <code>document</code> <code>Document</code> <p>Document object to create graph from</p> required <code>path</code> <code>str</code> <p>File path to save the graph</p> required <p>Returns (None): None</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import kernpy as kp\n&gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n&gt;&gt;&gt; kp.store_graph(document, 'path/to/graph.dot')\n</code></pre> Source code in <code>kernpy/core/generic.py</code> <pre><code>@deprecated(\"Use 'graph' instead.\")\ndef store_graph(\n        document: Document,\n        path: Union[str, Path]\n) -&gt; None:\n    \"\"\"\n    Create a graph representation of a Document object using Graphviz. Save the graph to a file.\n\n    Args:\n        document (Document): Document object to create graph from\n        path (str): File path to save the graph\n\n    Returns (None): None\n\n    Examples:\n        &gt;&gt;&gt; import kernpy as kp\n        &gt;&gt;&gt; document, errors = kp.read('path/to/file.krn')\n        &gt;&gt;&gt; kp.store_graph(document, 'path/to/graph.dot')\n    \"\"\"\n    return Generic.store_graph(\n        document=document,\n        path=Path(path)\n    )\n</code></pre>"},{"location":"reference/#kernpy.core.transpose","title":"<code>transpose(input_encoding, interval, input_format=NotationEncoding.HUMDRUM.value, output_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose a pitch by a given interval.</p> <p>The pitch must be in the American notation.</p> <p>Parameters:</p> Name Type Description Default <code>input_encoding</code> <code>str</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>input_format</code> <code>str</code> <p>The encoding format of the pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>output_format</code> <code>str</code> <p>The encoding format of the transposed pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>str</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', output_format='kern')\n'fff'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\n'fff'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\n'gg'\n&gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction=Direction.DOWN.value)\n'gg'\n&gt;&gt;&gt; transpose('ccc#', IntervalsByName['P4'])\n'fff#'\n&gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format='american')\n'Bb4'\n&gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format=NotationEncoding.AMERICAN.value)\n'Bb4'\n&gt;&gt;&gt; transpose('C3', IntervalsByName['P4'], input_format='american', direction='down')\n'G2'\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def transpose(\n        input_encoding: str,\n        interval: int,\n        input_format: str = NotationEncoding.HUMDRUM.value,\n        output_format: str = NotationEncoding.HUMDRUM.value,\n        direction: str = Direction.UP.value\n) -&gt; str:\n    \"\"\"\n    Transpose a pitch by a given interval.\n\n    The pitch must be in the American notation.\n\n    Args:\n        input_encoding (str): The pitch to transpose.\n        interval (int): The interval to transpose the pitch.\n        input_format (str): The encoding format of the pitch. Default is HUMDRUM.\n        output_format (str): The encoding format of the transposed pitch. Default is HUMDRUM.\n        direction (str): The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.\n\n    Returns:\n        str: The transposed pitch.\n\n    Examples:\n        &gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', output_format='kern')\n        'fff'\n        &gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\n        'fff'\n        &gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\n        'gg'\n        &gt;&gt;&gt; transpose('ccc', IntervalsByName['P4'], input_format='kern', direction=Direction.DOWN.value)\n        'gg'\n        &gt;&gt;&gt; transpose('ccc#', IntervalsByName['P4'])\n        'fff#'\n        &gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format='american')\n        'Bb4'\n        &gt;&gt;&gt; transpose('G4', IntervalsByName['m3'], input_format=NotationEncoding.AMERICAN.value)\n        'Bb4'\n        &gt;&gt;&gt; transpose('C3', IntervalsByName['P4'], input_format='american', direction='down')\n        'G2'\n\n\n    \"\"\"\n    importer = PitchImporterFactory.create(input_format)\n    pitch: AgnosticPitch = importer.import_pitch(input_encoding)\n\n    transposed_pitch = transpose_agnostics(pitch, interval, direction=direction)\n\n    exporter = PitchExporterFactory.create(output_format)\n    content = exporter.export_pitch(transposed_pitch)\n\n    return content\n</code></pre>"},{"location":"reference/#kernpy.core.transpose_agnostic_to_encoding","title":"<code>transpose_agnostic_to_encoding(agnostic_pitch, interval, output_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose an AgnosticPitch by a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>agnostic_pitch</code> <code>AgnosticPitch</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>output_format</code> <code>Optional[str]</code> <p>The encoding format of the transposed pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>Optional[str]</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns (str):     str: The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'])\n'F4'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\n'G3'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C#', 4), IntervalsByName['P4'])\n'F#4'\n&gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\n'Bb4'\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def transpose_agnostic_to_encoding(\n        agnostic_pitch: AgnosticPitch,\n        interval: int,\n        output_format: str = NotationEncoding.HUMDRUM.value,\n        direction: str = Direction.UP.value\n) -&gt; str:\n    \"\"\"\n    Transpose an AgnosticPitch by a given interval.\n\n    Args:\n        agnostic_pitch (AgnosticPitch): The pitch to transpose.\n        interval (int): The interval to transpose the pitch.\n        output_format (Optional[str]): The encoding format of the transposed pitch. Default is HUMDRUM.\n        direction (Optional[str]): The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.\n\n    Returns (str):\n        str: The transposed pitch.\n\n    Examples:\n        &gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'])\n        'F4'\n        &gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\n        'G3'\n        &gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('C#', 4), IntervalsByName['P4'])\n        'F#4'\n        &gt;&gt;&gt; transpose_agnostic_to_encoding(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\n        'Bb4'\n    \"\"\"\n    exporter = PitchExporterFactory.create(output_format)\n    transposed_pitch = transpose_agnostics(agnostic_pitch, interval, direction=direction)\n    content = exporter.export_pitch(transposed_pitch)\n\n    return content\n</code></pre>"},{"location":"reference/#kernpy.core.transpose_agnostics","title":"<code>transpose_agnostics(input_pitch, interval, direction=Direction.UP.value)</code>","text":"<p>Transpose an AgnosticPitch by a given interval.</p> <p>Parameters:</p> Name Type Description Default <code>input_pitch</code> <code>AgnosticPitch</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>direction</code> <code>str</code> <p>The direction of the transposition. 'UP' or 'DOWN'. Default is 'UP'.</p> <code>UP.value</code> Returns <p>AgnosticPitch: The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'])\nAgnosticPitch('F', 4)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\nAgnosticPitch('G', 3)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C#', 4), IntervalsByName['P4'])\nAgnosticPitch('F#', 4)\n&gt;&gt;&gt; transpose_agnostics(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\nAgnosticPitch('Bb', 4)\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def transpose_agnostics(\n        input_pitch: AgnosticPitch,\n        interval: int,\n        direction: str = Direction.UP.value\n) -&gt; AgnosticPitch:\n    \"\"\"\n    Transpose an AgnosticPitch by a given interval.\n\n    Args:\n        input_pitch (AgnosticPitch): The pitch to transpose.\n        interval (int): The interval to transpose the pitch.\n        direction (str): The direction of the transposition. 'UP' or 'DOWN'. Default is 'UP'.\n\n    Returns :\n        AgnosticPitch: The transposed pitch.\n\n    Examples:\n        &gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'])\n        AgnosticPitch('F', 4)\n        &gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C', 4), IntervalsByName['P4'], direction='down')\n        AgnosticPitch('G', 3)\n        &gt;&gt;&gt; transpose_agnostics(AgnosticPitch('C#', 4), IntervalsByName['P4'])\n        AgnosticPitch('F#', 4)\n        &gt;&gt;&gt; transpose_agnostics(AgnosticPitch('G', 4), IntervalsByName['m3'], direction='down')\n        AgnosticPitch('Bb', 4)\n\n    \"\"\"\n    return AgnosticPitch.to_transposed(input_pitch, interval, direction)\n</code></pre>"},{"location":"reference/#kernpy.core.transpose_encoding_to_agnostic","title":"<code>transpose_encoding_to_agnostic(input_encoding, interval, input_format=NotationEncoding.HUMDRUM.value, direction=Direction.UP.value)</code>","text":"<p>Transpose a pitch by a given interval.</p> <p>The pitch must be in the American notation.</p> <p>Parameters:</p> Name Type Description Default <code>input_encoding</code> <code>str</code> <p>The pitch to transpose.</p> required <code>interval</code> <code>int</code> <p>The interval to transpose the pitch.</p> required <code>input_format</code> <code>str</code> <p>The encoding format of the pitch. Default is HUMDRUM.</p> <code>HUMDRUM.value</code> <code>direction</code> <code>str</code> <p>The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.</p> <code>UP.value</code> <p>Returns:</p> Name Type Description <code>AgnosticPitch</code> <code>AgnosticPitch</code> <p>The transposed pitch.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern')\nAgnosticPitch('fff', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\nAgnosticPitch('fff', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\nAgnosticPitch('gg', 3)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('ccc#', IntervalsByName['P4'])\nAgnosticPitch('fff#', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('G4', IntervalsByName['m3'], input_format='american')\nAgnosticPitch('Bb4', 4)\n&gt;&gt;&gt; transpose_encoding_to_agnostic('C3', IntervalsByName['P4'], input_format='american', direction='down')\nAgnosticPitch('G2', 2)\n</code></pre> Source code in <code>kernpy/core/transposer.py</code> <pre><code>def transpose_encoding_to_agnostic(\n        input_encoding: str,\n        interval: int,\n        input_format: str = NotationEncoding.HUMDRUM.value,\n        direction: str = Direction.UP.value\n) -&gt; AgnosticPitch:\n    \"\"\"\n    Transpose a pitch by a given interval.\n\n    The pitch must be in the American notation.\n\n    Args:\n        input_encoding (str): The pitch to transpose.\n        interval (int): The interval to transpose the pitch.\n        input_format (str): The encoding format of the pitch. Default is HUMDRUM.\n        direction (str): The direction of the transposition.'UP' or 'DOWN' Default is 'UP'.\n\n    Returns:\n        AgnosticPitch: The transposed pitch.\n\n    Examples:\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern')\n        AgnosticPitch('fff', 4)\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format=NotationEncoding.HUMDRUM.value)\n        AgnosticPitch('fff', 4)\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('ccc', IntervalsByName['P4'], input_format='kern', direction='down')\n        AgnosticPitch('gg', 3)\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('ccc#', IntervalsByName['P4'])\n        AgnosticPitch('fff#', 4)\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('G4', IntervalsByName['m3'], input_format='american')\n        AgnosticPitch('Bb4', 4)\n        &gt;&gt;&gt; transpose_encoding_to_agnostic('C3', IntervalsByName['P4'], input_format='american', direction='down')\n        AgnosticPitch('G2', 2)\n\n    \"\"\"\n    importer = PitchImporterFactory.create(input_format)\n    pitch: AgnosticPitch = importer.import_pitch(input_encoding)\n\n    return transpose_agnostics(pitch, interval, direction=direction)\n</code></pre>"},{"location":"reference/#kernpy.util.StoreCache","title":"<code>StoreCache</code>","text":"<p>A simple cache that stores the result of a callback function</p> Source code in <code>kernpy/util/store_cache.py</code> <pre><code>class StoreCache:\n    \"\"\"\n    A simple cache that stores the result of a callback function\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.memory = {}\n\n    def request(self, callback, request):\n        \"\"\"\n        Request a value from the cache. If the value is not in the cache, it will be calculated by the callback function\n        Args:\n            callback (function): The callback function that will be called to calculate the value\n            request (any): The request that will be passed to the callback function\n\n        Returns (any): The value that was requested\n\n        Examples:\n            &gt;&gt;&gt; def add_five(x):\n            ...     return x + 5\n            &gt;&gt;&gt; store_cache = StoreCache()\n            &gt;&gt;&gt; store_cache.request(callback, 5)  # Call the callback function\n            10\n            &gt;&gt;&gt; store_cache.request(callback, 5)  # Return the value from the cache, without calling the callback function\n            10\n        \"\"\"\n        if request in self.memory:\n            return self.memory[request]\n        else:\n            result = callback(request)\n            self.memory[request] = result\n            return result\n</code></pre>"},{"location":"reference/#kernpy.util.StoreCache.__init__","title":"<code>__init__()</code>","text":"<p>Constructor</p> Source code in <code>kernpy/util/store_cache.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.memory = {}\n</code></pre>"},{"location":"reference/#kernpy.util.StoreCache.request","title":"<code>request(callback, request)</code>","text":"<p>Request a value from the cache. If the value is not in the cache, it will be calculated by the callback function Args:     callback (function): The callback function that will be called to calculate the value     request (any): The request that will be passed to the callback function</p> <p>Returns (any): The value that was requested</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def add_five(x):\n...     return x + 5\n&gt;&gt;&gt; store_cache = StoreCache()\n&gt;&gt;&gt; store_cache.request(callback, 5)  # Call the callback function\n10\n&gt;&gt;&gt; store_cache.request(callback, 5)  # Return the value from the cache, without calling the callback function\n10\n</code></pre> Source code in <code>kernpy/util/store_cache.py</code> <pre><code>def request(self, callback, request):\n    \"\"\"\n    Request a value from the cache. If the value is not in the cache, it will be calculated by the callback function\n    Args:\n        callback (function): The callback function that will be called to calculate the value\n        request (any): The request that will be passed to the callback function\n\n    Returns (any): The value that was requested\n\n    Examples:\n        &gt;&gt;&gt; def add_five(x):\n        ...     return x + 5\n        &gt;&gt;&gt; store_cache = StoreCache()\n        &gt;&gt;&gt; store_cache.request(callback, 5)  # Call the callback function\n        10\n        &gt;&gt;&gt; store_cache.request(callback, 5)  # Return the value from the cache, without calling the callback function\n        10\n    \"\"\"\n    if request in self.memory:\n        return self.memory[request]\n    else:\n        result = callback(request)\n        self.memory[request] = result\n        return result\n</code></pre>"},{"location":"get-started/tutorial/","title":"Tutorial: Learning <code>kernpy</code> in 5 minutes.","text":"<p>This is a short introduction to <code>kernpy</code>. It will guide you through the main concepts and show you how to use the package in a few minutes.</p> <p>When using <code>kernpy</code>, you should be familiar with the Humdrum **kern encodings. You can easily find information in:</p> <ul> <li>Verovio Humdrum Viewer</li> <li>Verovio Humdrum Viewer Documentation</li> </ul>"},{"location":"get-started/tutorial/#running-the-code","title":"Running the code","text":"<p><code>kernpy</code> is able to be run as a normal snippet of code or as a module by command line interface.</p>"},{"location":"get-started/tutorial/#we-will-import-kernpy-as-the-following-way","title":"We will import <code>kernpy</code> as the following way:","text":"<pre><code>import kernpy as kp\n</code></pre>"},{"location":"get-started/tutorial/#what-is-humdrum-kern","title":"What is Humdrum **kern?","text":"<p>First of all, let's see what a Humdrum **kern file looks like:</p> <pre><code>**kern  **text  **kern  **dynam **text\n*clefG2 *   *clefG2 *   *\n*M4/4   *   *   *   *\n=1  =1  =1  =1  =1\n4g  kern    4c  p   kern-\n4f  kern    4d  &lt;   -py\n4g  kern    4e  (   mo-\n4c  kern-   4f  (   -du-\n.   .   .   [   .\n=2  =2  =2  =2  =2\n2c  -py 2g  f   -le\n.   .   .   &gt;   .\n4B  kern    4f  )   is\n4A  kern-   4d  )   the\n=   =   =   =   =\n1G  -py 1c  ]   best\n==  ==  ==  ==  ==\n*-  *-  *-  *-  *-\n</code></pre> <p></p>"},{"location":"get-started/tutorial/#lets-code","title":"Let's code!","text":""},{"location":"get-started/tutorial/#basic-usage","title":"Basic Usage","text":"<p>Load a <code>**kern</code>/<code>**mens</code> file into a <code>kp.Document</code>.</p> <pre><code>import kernpy as kp\n\n# Read a **kern file\ndocument, errors = kp.load(\"path/to/file.krn\")\n</code></pre> <p>Load a <code>**kern</code>/<code>**mens</code> from a string into a <code>kp.Document</code>.</p> <pre><code>import kernpy as kp\n\ndocument, errors = kp.loads(\"**kern\\n*clefC3\\n*k[b-e-a-]\\n*M3/4\\n4e-\\n4g\\n4c\\n=1\\n4r\\n2cc;\\n==\\n*-\")\n</code></pre> <p>Create a new standardized file from a <code>kp.Document</code>.</p> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile.krn\")\n</code></pre> <p>Save the document in a string from a <code>kp.Document</code>.</p> <pre><code>import kernpy as kp\n\ncontent = kp.dumps(document)\n````\n\n### Exploring different options when creating new files\n\nOnly use the specified spines in `spine_types`.\n```python\nimport kernpy as kp\n\nkp.dump(document, \"newfile_core.krn\",\n        spine_types=['**kern'])\nkp.dump(document, \"newfile_lyrics.krn\",\n        spine_types=['**text])\nkp.dump(document, \"newfile_core_and_lyrics.krn\",\n        spine_types=['*+text'])\n</code></pre> <ul> <li>Use <code>include</code> for selecting the kern semantic categories to use**. The output only contains what is passed. By default, all the categories are included.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_only_clefs.krn\",\n        include={kp.TokenCategory.CLEF})\nkp.dump(document, \"newfile_only_durations_and_bounding_boxes.krn\",\n        include={kp.TokenCategory.DURATION, kp.TokenCategory.BOUNDING_BOXES})\n</code></pre> <ul> <li>Use <code>exclude</code> for selecting the kern semantic categories to not use**. The output contains everything except what is passed. By default, any category is excluded.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_without_pitches.krn\",\n        exclude={kp.TokenCategory.PITCH})\nkp.dump(document, \"newfile_without_durations_or_rests.krn\",\n        exclude={kp.TokenCategory.BARLINES, kp.TokenCategory.REST})\n</code></pre> <ul> <li>Use <code>include</code> and <code>exclude</code> together to select the kern semantic categories to use**. The output combines both.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_custom.krn\",\n        include=kp.BEKERN_CATEGORIES,  # Preloaded set of simple categories\n        exclude={kp.TokenCategory.PITCH})\n</code></pre> <ul> <li>Use <code>tokenizer</code> to select how the categories are split. By default, the <code>normalizedKern</code> tokenizer is used.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_normalized.krn\",\n        tokenizer=kp.Encoding.normalizedKern)  # Default tokenizer\n</code></pre> <p>Select the proper Humdrum **kern tokenizer:</p> <p><code>kernpy</code> provides different tokenizers to export the content each symbol in different formats.</p> Encoding Tokenized Description kern 2.bb-_L Traditional Humdrum **kern encoding ekern 2@.@bb@-\u00b7_\u00b7L Extended Humdrum **kern encoding <p>Use the <code>Encoding</code> enum class to select the tokenizer:</p> <pre><code>import kernpy as kp\n\ndoc, _ = kp.load('resource_dir/legacy/chor048.krn')\n\nkern_content = kp.dumps(doc, tokenizer=kp.Encoding.normalizedKern)\nekern_content = kp.dumps(doc, tokenizer=kp.Encoding.eKern)\n</code></pre> <ul> <li>Use <code>from_measure</code> and <code>to_measure</code> to select the measures to export. By default, all the measures are exported.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_1_to_10.krn\",\n        from_measure=1,  # First from measure 1\n        to_measure=10)   # Last measure exported\n</code></pre> <ul> <li>Use <code>spine_ids</code> to select the spines to export. By default, all the spines are exported.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_1_and_2.krn\",\n        spine_ids=[0, 1])  # Export only the first and the second spine\n</code></pre> <ul> <li>Use <code>show_measure_numbers</code> to select if the measure numbers are shown. By default, the measure numbers are shown.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile_no_measure_numbers.krn\",\n        show_measure_numbers=False)  # Do not show measure numbers\n</code></pre> <ul> <li>Use all the options at the same time.</li> </ul> <pre><code>import kernpy as kp\n\nkp.dump(document, \"newfile.krn\",\n        spine_types=['**kern'],  # Export only the **kern spines\n        include=kp.BEKERN_CATEGORIES,  # Token categories to include\n        exclude={kp.TokenCategory.PITCH},  # Token categories to exclude\n        tokenizer=kp.Encoding.eKern,  # Kern encoding\n        from_measure=1,  # First from measure 1\n        to_measure=10,  # Last measure exported\n        spine_ids=[0, 1],  # Export only the first and the second spine\n        show_measure_numbers=False,  # Do not show measure numbers\n        )\n</code></pre>"},{"location":"get-started/tutorial/#exploring-kernpy-utilities","title":"Exploring <code>kernpy</code> utilities.","text":"<ul> <li>Spines analysis   Retrieve all the spine types of the document.</li> </ul> <pre><code>import kernpy as kp\n\nkp.spine_types(document)\n# ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n\nkp.spine_types(document, spine_types=None)\n# ['**kern', '**kern', '**kern', '**kern', '**root', '**harm']\n\nkp.spine_types(document, spine_types=['**kern'])\n# ['**kern', '**kern', '**kern', '**kern']\n</code></pre> <ul> <li>Get specific **kern spines.</li> </ul> <pre><code>import kernpy as kp\n\ndef how_many_instrumental_spines(document):\n    print(kp.spine_types(document, ['**kern']))\n    return len(kp.spine_types(document, ['**kern']))\n# ['**kern', '**kern', '**kern', '**kern']\n# 4\n\ndef has_voice(document):\n    return len(kp.spine_types(document, ['**text'])) &gt; 0\n# True\n</code></pre>"},{"location":"get-started/tutorial/#how-many-measures-are-there-in-the-document-which-measures-do-you-want-to-export","title":"How many measures are there in the document? Which measures do you want to export?","text":"<p>After reading the score into the <code>Document</code> object. You can get some useful data:</p> <pre><code>first_measure: int = document.get_first_measure()\nlast_measure: int = document.measures_count()\n</code></pre> <p>Iterate over all the measures of the document.</p> <pre><code>import kernpy as kp\n\ndoc, _ = kp.load('resource_dir/legacy/chor048.krn')  # 10 measures score\nfor i in range(doc.get_first_measure(), doc.measures_count(), 1):  # from 1 to 11, step 1\n    # Export only the i-th measure (1 long measure scores)\n    content_ith_measure = kp.dumps(doc, from_measure=i, to_measure=i)\n\n    # Export the i-th measure and the next 4 measures (5 long measure scores)\n    if i + 4 &lt;= doc.measures_count():\n        content_longer = kp.dumps(doc, from_measure=i, to_measure=i + 4)\n    ...\n</code></pre> <p>It is easier to iterate over all the measures using the <code>for measure in doc</code>: loop (using the <code>__ iter__</code> method):</p> <pre><code>import kernpy as kp\n\nfor measure in doc:\n    content = kp.dumps(doc, from_measure=measure, to_measure=measure)\n    ...\n</code></pre> <p>Exploring the page bounding boxes.</p> <pre><code>import kernpy as kp\n\n# Iterate over the pages using the bounding boxes\ndoc, _ = kp.load('kern_having_bounding_boxes.krn')\n\n# Inspect the bounding boxes\nprint(doc.page_bounding_boxes)\n\n\ndef are_there_bounding_boxes(doc):\n    return len(doc.get_all_tokens(filter_by_categories=[kp.TokenCategory.BOUNDING_BOXES])) &gt; 0\n\n\n# True\n\n# Iterate over the pages\nfor page_label, bounding_box_measure in doc.page_bounding_boxes.items():\n    print(f\"Page: {page_label}\"\n          f\"Bounding box: {bounding_box_measure}\"\n          f\"from_measure: {bounding_box_measure.from_measure}\"\n          f\"to_measure+1: {bounding_box_measure.to_measure}\")  # TODO: Check bounds\n    kp.dump(doc, f\"foo_{page_label}.ekrn\",\n            spine_types=['**kern'],\n            token_categories=kp.BEKERN_CATEGORIES,\n            tokenizer=kp.Encoding.eKern,\n            from_measure=bounding_box_measure.from_measure,\n            to_measure=bounding_box_measure.to_measure - 1  # TODO: Check bounds            \n            )\n</code></pre>"},{"location":"get-started/tutorial/#merge-different-full-kern-scores","title":"Merge different full kern scores","text":"<pre><code>import kernpy as kp\n# NOT AVAILABLE YET!!!\n# Pay attention to `kp.merge` too.\n\n# Concat two valid documents\nscore_a = '**kern\\n*clefG2\\n=1\\n4c\\n4d\\n4e\\n4f\\n*-\\n'\nscore_b = '**kern\\n*clefG2\\n=1\\n4a\\n4c\\n4d\\n4c\\n*-\\n'\nconcatenated = kp.merge([score_a, score_b])\n</code></pre>"},{"location":"get-started/tutorial/#concatenate-sorted-fragments-of-the-same-score","title":"Concatenate sorted fragments of the same score","text":"<pre><code>import kernpy as kp\n\nfragment_a = '**kern\\n*clefG2\\n=1\\n4c\\n4d\\n4e\\n4f\\n*-\\n'\nfragment_b = '=2\\n4a\\n4c\\n4d\\n4c\\n*-\\n=3\\n4a\\n4c\\n4d\\n4c\\n*-\\n'\nfragment_c = '=4\\n4a\\n4c\\n4d\\n4c\\n*-\\n=5\\n4a\\n4c\\n4d\\n4c\\n*-\\n'\nfragment_d = '=6\\n4a\\n4c\\n4d\\n4c\\n*-\\n=7\\n4a\\n4c\\n4d\\n4c\\n*-\\n==*-'\nfragments = [fragment_a, fragment_b, fragment_c, fragment_d]\n\ndoc_merged, indexes = kp.concat(fragments)\nfor index_pair in indexes:\n    from_measure, to_measure = index_pair\n    print(f'From measure: {from_measure}, To measure: {to_measure}')\n    print(kp.dumps(doc_merged, from_measure=from_measure, to_measure=to_measure))\n\n# Sometimes is useful having a different separator between the fragments rather than the default one (newline)...\ndoc_merged, indexes = kp.concat(fragments, separator='')\n</code></pre>"},{"location":"get-started/tutorial/#inspect-the-document-class-functions","title":"Inspect the <code>Document</code> class functions","text":"<pre><code>import kernpy as kp\ndoc, _ = kp.load('resource_dir/legacy/chor048.krn')  # 10 measures score\n\nfrequencies = doc.frequencies()  # All the token categories\nfiltered_frequencies = doc.frequencies(filter_by_categories=[kp.TokenCategory.SIGNATURES])\nfrequencies['*k[f#c#]']\n# {\n#   'occurrences': 4,\n#   'category': SIGNATURES,\n# }\n\n# Get all the tokens in the document\nall_tokens: [kp.Token] = doc.get_all_tokens()\nall_tokens_encodings: [str] = doc.get_all_tokens_encodings()\n\n# Get the unique tokens in the document (vocabulary)\nunique_tokens: [kp.Token] = doc.get_unique_tokens()\nunique_token_encodings: [str] = doc.get_unique_token_encodings()\n\n# Get the line comments in the document\ndocument.get_metacomments()\n# ['!!!COM: Coltrane', '!!!voices: 1', '!!!OPR: Blue Train']\ndocument.get_metacomments(KeyComment='COM')\n# ['!!!COM: Coltrane']\ndocument.get_metacomments(KeyComment='COM', clear=True)\n# ['Coltrane']\ndocument.get_metacomments(KeyComment='non_existing_key')\n# []\n</code></pre>"},{"location":"get-started/tutorial/#next-steps","title":"Next steps","text":"<p>Congratulations! You have learned the basics of <code>kernpy</code>. Now you can start using the package in your projects.</p> <p>Go to the API reference to learn more about the <code>kernpy</code> API.</p>"}]}